
do
    if _G.OBLIVION_DEBUG == nil then
        _G.OBLIVION_DEBUG = true
    end
    if type(_G.__oblivion_dbg) ~= "function" then
        _G.__oblivion_dbg = function(...)
            if _G.OBLIVION_DEBUG then
                print("[OBLIVION]", ...)
            end
        end
    end
    pcall(function()
        game:GetService("ScriptContext").Error:Connect(function(message, stackTrace)
            if _G.OBLIVION_DEBUG then
                warn("[OBLIVION][ERROR]", message)
                if stackTrace then
                    warn("[OBLIVION][TRACE]", stackTrace)
                end
            end
        end)
    end)
end

do
    _G.__oblivion_dbg("BOOT: env setup start")
    local env = _G
    local __raw_isfile = env.isfile or isfile
    local __raw_isfolder = env.isfolder or isfolder
    local __raw_makefolder = env.makefolder or makefolder
    local __raw_writefile = env.writefile or writefile
    local __raw_readfile = env.readfile or readfile
    local __raw_queue_on_teleport = env.queue_on_teleport or (env.syn and env.syn.queue_on_teleport) or queue_on_teleport
    local __raw_setclipboard = env.setclipboard or env.toclipboard or setclipboard
    local VirtualInputManager = game:GetService("VirtualInputManager")

    env.readfile = (type(__raw_readfile) == "function" and function(path)
        local ok, content = pcall(__raw_readfile, path)
        if ok then
            return content
        end
        return nil
    end) or function()
        return nil
    end

    env.writefile = (type(__raw_writefile) == "function" and function(path, content)
        return pcall(__raw_writefile, path, content)
    end) or function()
        return false
    end

    env.isfile = function(path)
        if type(__raw_isfile) == "function" then
            local ok, exists = pcall(__raw_isfile, path)
            if ok then
                return exists == true
            end
        end
        return env.readfile(path) ~= nil
    end

    env.isfolder = function(path)
        if type(__raw_isfolder) == "function" then
            local ok, exists = pcall(__raw_isfolder, path)
            if ok then
                return exists == true
            end
        end
        return false
    end

    env.makefolder = (type(__raw_makefolder) == "function" and function(path)
        pcall(__raw_makefolder, path)
    end) or function()
    end

    env.queue_on_teleport = (type(__raw_queue_on_teleport) == "function" and __raw_queue_on_teleport) or function()
    end

    env.setclipboard = (type(__raw_setclipboard) == "function" and __raw_setclipboard) or function()
    end

    if not env.mouse1click then
        env.mouse1click = function()
            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
            task.wait()
            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
        end
    end

    if not env.mouse2click then
        env.mouse2click = function()
            VirtualInputManager:SendMouseButtonEvent(0, 0, 1, true, game, 1)
            task.wait()
            VirtualInputManager:SendMouseButtonEvent(0, 0, 1, false, game, 1)
        end
    end

    if not env.Drawing then
        env.Drawing = {}
        env.Drawing.Fonts = { UI = 0, System = 1, Plex = 2, Monospace = 3 }
        env.Drawing.new = function(class)
            local obj = {}
            local props = {
                Visible = false,
                Color = Color3.new(1, 1, 1),
                Transparency = 1,
                Thickness = 1,
                From = Vector2.new(),
                To = Vector2.new(),
                Position = Vector2.new(),
                Size = Vector2.new(),
                Text = "",
                Center = false,
                Outline = false,
                OutlineColor = Color3.new(0, 0, 0),
                Font = 0,
                Radius = 10,
                Filled = false,
                NumSides = 10
            }
            setmetatable(obj, {
                __index = props,
                __newindex = function(self, key, value)
                    props[key] = value
                end
            })
            obj.Remove = function() end
            obj.Destroy = function() end
            return obj
        end
    end

    _G.isfile = env.isfile
    _G.isfolder = env.isfolder
    _G.makefolder = env.makefolder
    _G.writefile = env.writefile
    _G.readfile = env.readfile
    _G.mouse1click = env.mouse1click
    _G.mouse2click = env.mouse2click
    _G.Drawing = env.Drawing
    _G.queue_on_teleport = env.queue_on_teleport
    _G.setclipboard = env.setclipboard
    _G.__oblivion_dbg("BOOT: env setup done")
end
insert = table.insert
find = table.find
random = math.random
huge = math.huge
Vector2New = Vector2.new
Vector3New = Vector3.new
CFrameNew = CFrame.new
library_source = nil
do
    _G.__oblivion_dbg("BOOT: downloading MacLib")
    local ok, body = pcall(function()
        return game:HttpGet("https://pastebin.com/raw/YQni2KG9")
    end)
    if ok then
        library_source = body
        _G.__oblivion_dbg("BOOT: MacLib downloaded bytes", type(body) == "string" and #body or -1)
    else
        _G.__oblivion_dbg("BOOT: MacLib download failed", tostring(body))
    end
end
if type(library_source) == "string" then
    library_source = library_source:gsub('globe%s*=%s*"rbxassetid://%d+"', 'globe = "rbxassetid://4677859281"')
    library_source = library_source:gsub('globe%s*=%s*"%d+"', 'globe = "rbxassetid://4677859281"')
end
local function createDummy()
    local dummy = {}
    setmetatable(dummy, {
        __index = function(self, key)
            return dummy
        end,
        __call = function(self, ...)
            return dummy
        end,
        __newindex = function(self, key, value)
            rawset(self, key, value)
        end
    })
    return dummy
end

if type(library_source) == "string" then
    _G.__oblivion_dbg("BOOT: loading MacLib")
    local success, result = pcall(function()
        local fn = loadstring(library_source)
        if type(fn) ~= "function" then
            error("loadstring returned " .. typeof(fn))
        end
        return fn()
    end)
    if success and result then
        MacLib = result
        _G.__oblivion_dbg("BOOT: MacLib loaded")
    else
        MacLib = createDummy()
        _G.__oblivion_dbg("BOOT: MacLib load failed", tostring(result))
    end
else
    MacLib = createDummy()
    _G.__oblivion_dbg("BOOT: MacLib source missing")
end
do
    local function detectFSRoot()
        if type(isfolder) ~= "function" then
            return nil
        end
        local ok1, hasLower = pcall(isfolder, "workspace")
        if ok1 and hasLower then
            return "workspace"
        end
        local ok2, hasUpper = pcall(isfolder, "Workspace")
        if ok2 and hasUpper then
            return "Workspace"
        end
        return nil
    end
    local function ensureFolder(path)
        if type(path) ~= "string" or path == "" then
            return false
        end
        if type(makefolder) ~= "function" or type(isfolder) ~= "function" then
            return false
        end
        local norm = path:gsub("\\", "/")
        local cur = ""
        for part in norm:gmatch("[^/]+") do
            cur = (cur == "" and part or (cur .. "/" .. part))
            local ok, exists = pcall(isfolder, cur)
            if not (ok and exists) then
                pcall(makefolder, cur)
            end
        end
        return true
    end
    local root = detectFSRoot()
    local folder = root and (root .. "/Oblivion") or "Oblivion"
    pcall(function()
        _G.__oblivion_dbg("BOOT: setting MacLib folder", folder)
        ensureFolder(folder)
        if MacLib and type(MacLib.SetFolder) == "function" then
            MacLib:SetFolder(folder)
        end
    end)
end
wcamera = workspace.CurrentCamera
localplayer = game.Players.LocalPlayer
runs = game:GetService("RunService")
uis = game:GetService("UserInputService")
tweens = game:GetService("TweenService")
gui = game:GetService("GuiService")
scriptloading = true
if not _G.allvars then _G.allvars = {} end
if _G.allvars.camthirdp == nil then _G.allvars.camthirdp = false end
_G.thirdpshow = true
_G.allvars._rt = _G.allvars._rt or { connections = {}, unloaded = false }
if not _G.allvars._rt.track then
    function _G.allvars._rt.track(conn)
        if conn then
            table.insert(_G.allvars._rt.connections, conn)
        end
        return conn
    end
    function _G.allvars._rt.disconnect(conn)
        if conn and conn.Disconnect then
            pcall(function() conn:Disconnect() end)
        end
    end
    function _G.allvars._rt.disconnectAll()
        local conns = _G.allvars._rt.connections
        for i = #conns, 1, -1 do
            local conn = conns[i]
            conns[i] = nil
            _G.allvars._rt.disconnect(conn)
        end
    end
end
if not _G.allvars._rt.originalCamera then
    _G.allvars._rt.originalCamera = {
        CameraMode = localplayer and localplayer.CameraMode,
        CameraMinZoomDistance = localplayer and localplayer.CameraMinZoomDistance,
        CameraMaxZoomDistance = localplayer and localplayer.CameraMaxZoomDistance
    }
end
if not _G.allvars._rt.originalInput then
    _G.allvars._rt.originalInput = {
        MouseBehavior = Enum.MouseBehavior.Default,
        MouseIconEnabled = true
    }
    pcall(function() _G.allvars._rt.originalInput.MouseBehavior = uis.MouseBehavior end)
    pcall(function() _G.allvars._rt.originalInput.MouseIconEnabled = uis.MouseIconEnabled end)
end
_G.allvars._rt.restoreInputState = _G.allvars._rt.restoreInputState or function()
    local original = _G.allvars and _G.allvars._rt and _G.allvars._rt.originalInput
    if not original then return end
    pcall(function() uis.MouseBehavior = original.MouseBehavior or Enum.MouseBehavior.Default end)
    pcall(function() uis.MouseIconEnabled = (original.MouseIconEnabled ~= false) end)
end
_G.allvars._rt.setThirdPersonInputLock = _G.allvars._rt.setThirdPersonInputLock or function(locked)
    local rt = _G.allvars and _G.allvars._rt
    if rt then
        rt.thirdPerson = rt.thirdPerson or {}
    end
    local tp = rt and rt.thirdPerson
    if tp and tp.inputLocked == locked then
        return
    end
    if tp then
        tp.inputLocked = locked
    end
    if locked then
        pcall(function() uis.MouseBehavior = Enum.MouseBehavior.LockCenter end)
        pcall(function() uis.MouseIconEnabled = false end)
    else
        pcall(function() uis.MouseBehavior = Enum.MouseBehavior.Default end)
        pcall(function() uis.MouseIconEnabled = true end)
    end
end
if _G.allvars and _G.allvars._rt and gui then
    if _G.allvars._rt.thirdPersonMenuConn then
        _G.allvars._rt.disconnect(_G.allvars._rt.thirdPersonMenuConn)
        _G.allvars._rt.thirdPersonMenuConn = nil
    end
    _G.allvars._rt.thirdPersonMenuConn = _G.allvars._rt.track(gui:GetPropertyChangedSignal("MenuIsOpen"):Connect(function()
        local rt = _G.allvars and _G.allvars._rt
        if not rt then
            return
        end
        if not (_G.allvars and _G.allvars.camthirdp) then
            return
        end
        local open = false
        pcall(function() open = gui.MenuIsOpen end)
        if open then
            if rt.setThirdPersonInputLock then
                rt.setThirdPersonInputLock(false)
            end
        else
            local char = localplayer and localplayer.Character
            local hum = char and char:FindFirstChild("Humanoid")
            if hum and rt.setThirdPersonShiftLock then
                rt.setThirdPersonShiftLock(true, hum)
            end
            if _G.SetThirdPersonCamera then
                _G.SetThirdPersonCamera()
            end
            if rt.setThirdPersonInputLock then
                rt.setThirdPersonInputLock(true)
            end
            task.defer(function()
                local rt2 = _G.allvars and _G.allvars._rt
                if rt2 and rt2.setThirdPersonInputLock then
                    rt2.setThirdPersonInputLock(true)
                end
            end)
        end
    end))
end
_G.allvars._rt.setThirdPersonShiftLock = _G.allvars._rt.setThirdPersonShiftLock or function(enabled, humanoid)
    local rt = _G.allvars and _G.allvars._rt
    if rt then
        rt.thirdPerson = rt.thirdPerson or {}
    end
    local tp = rt and rt.thirdPerson
    if enabled then
        if tp then
            if humanoid and ((tp.enabled ~= true) or (tp.humanoid ~= humanoid) or (tp.originalAutoRotate == nil)) then
                tp.originalAutoRotate = humanoid.AutoRotate
            end
            tp.enabled = true
            tp.humanoid = humanoid
        end
        pcall(function() uis.MouseBehavior = Enum.MouseBehavior.LockCenter end)
        pcall(function() uis.MouseIconEnabled = false end)
        if humanoid then
            pcall(function() humanoid.AutoRotate = false end)
        end
    else
        if tp then
            tp.enabled = false
        end
        local originalAutoRotate = tp and tp.originalAutoRotate
        if humanoid and originalAutoRotate ~= nil then
            pcall(function() humanoid.AutoRotate = originalAutoRotate end)
        end
        if _G.allvars and _G.allvars._rt and _G.allvars._rt.restoreInputState then
            _G.allvars._rt.restoreInputState()
        end
    end
end
_G.allvars._rt.clearThirdPersonShiftLock = _G.allvars._rt.clearThirdPersonShiftLock or function()
    local rt = _G.allvars and _G.allvars._rt
    local tp = rt and rt.thirdPerson
    local hum = (tp and tp.humanoid) or (localplayer.Character and localplayer.Character:FindFirstChild("Humanoid"))
    if _G.allvars and _G.allvars._rt and _G.allvars._rt.setThirdPersonShiftLock then
        _G.allvars._rt.setThirdPersonShiftLock(false, hum)
    end
end
waterplatforms = workspace:FindFirstChild("ArdourWaterPlatforms") or Instance.new("Folder", workspace)
waterplatforms.Name = "ArdourWaterPlatforms"
JesusEnabled = false
nofall = false
instafall = false
if MacLib then
    oldLoadConfig = MacLib.LoadConfig
    MacLib.LoadConfig = function(self, config)
        local prevLoading = (_G.__OBLIVION_CONFIG_LOADING == true)
        _G.__OBLIVION_CONFIG_LOADING = true
        _G.RH_IsConfigLoadingDesync = true
        local ok, result = pcall(function()
            return oldLoadConfig(self, config)
        end)
        local function coerceColor3(v)
            if typeof(v) == "Color3" then
                return v
            end
            if type(v) ~= "table" then
                return nil
            end
            local r = v.R or v.r
            local g = v.G or v.g
            local b = v.B or v.b
            if type(r) ~= "number" or type(g) ~= "number" or type(b) ~= "number" then
                return nil
            end
            if r > 1 or g > 1 or b > 1 then
                return Color3.fromRGB(
                    math.clamp(math.floor(r + 0.5), 0, 255),
                    math.clamp(math.floor(g + 0.5), 0, 255),
                    math.clamp(math.floor(b + 0.5), 0, 255)
                )
            end
            return Color3.new(math.clamp(r, 0, 1), math.clamp(g, 0, 1), math.clamp(b, 0, 1))
        end
        local function normalizeValue(v)
            local c = coerceColor3(v)
            if c then
                return c
            end
            if type(v) ~= "table" then
                return v
            end
            if v.Toggle ~= nil then return v.Toggle end
            if v.Value ~= nil then return v.Value end
            if v.Number ~= nil then return v.Number end
            if v.Amount ~= nil then return v.Amount end
            if v.Slider ~= nil then return v.Slider end
            if v.Key ~= nil then return v.Key end
            if v.Color ~= nil then return v.Color end
            if v.RGB ~= nil then return v.RGB end
            if #v == 1 then return v[1] end
            return v
        end
        local function applyValueToElement(element, value)
            if not element then
                return
            end
            local normalized = normalizeValue(value)
            local originalCb = rawget(element, "Callback") or element.Callback
            local cbFired = false
            if type(originalCb) == "function" then
                pcall(function()
                    element.Callback = function(...)
                        cbFired = true
                        return originalCb(...)
                    end
                end)
            end
            local function tryApply(v)
                if type(element.UpdateState) == "function" then
                    if pcall(function() element:UpdateState(v) end) then return true end
                end
                if type(element.UpdateValue) == "function" then
                    if pcall(function() element:UpdateValue(v) end) then return true end
                end
                if type(element.set_value) == "function" then
                    if pcall(function() element:set_value(v) end) then return true end
                end
                if type(element.SetValue) == "function" then
                    if pcall(function() element:SetValue(v) end) then return true end
                end
                if type(element.Set) == "function" then
                    if pcall(function() element:Set(v) end) then return true end
                end
                if type(element.UpdateVisuals) == "function" then
                    if pcall(function() element:UpdateVisuals(v) end) then return true end
                end
                return false
            end
            local applied = false
            if normalized ~= value then
                applied = tryApply(normalized)
            end
            if not applied then
                applied = tryApply(value)
            end
            if type(originalCb) == "function" then
                pcall(function()
                    element.Callback = originalCb
                end)
                if not cbFired then
                    pcall(function()
                        originalCb(normalized)
                    end)
                end
            end
        end
        local function syncMultipointIfPresent(flags, elements)
            local function toNumber(v)
                v = normalizeValue(v)
                return tonumber(v)
            end
            local head = toNumber(flags and flags.MultipointHeadPercent)
            local body = toNumber(flags and flags.MultipointBodyPercent)
            if head == nil and body ~= nil then
                head = 100 - body
            end
            if head == nil then
                return
            end
            head = math.floor(head + 0.5)
            if head < 0 then head = 0 end
            if head > 100 then head = 100 end
            body = 100 - head
            if flags then
                flags.MultipointHeadPercent = head
                flags.MultipointBodyPercent = body
            end
            multipointHeadPercent = head
            multipointBodyPercent = body
            multipointPercentSyncing = true
            applyValueToElement(elements and elements.MultipointHeadPercent, head)
            applyValueToElement(elements and elements.MultipointBodyPercent, body)
            multipointPercentSyncing = false
            multipointCacheVersion = (multipointCacheVersion or 0) + 1
        end
        task.defer(function()
            local flags = rawget(self, "Flags") or self.Flags
            local elements = rawget(self, "Elements") or self.Elements
            for _ = 1, 30 do
                flags = rawget(self, "Flags") or self.Flags
                elements = rawget(self, "Elements") or self.Elements
                if type(flags) == "table" and type(elements) == "table" then
                    for flagName, value in pairs(flags) do
                        local element = elements[flagName]
                        if element then
                            applyValueToElement(element, value)
                        end
                    end
                    syncMultipointIfPresent(flags, elements)
                end
                task.wait(0.05)
            end
            _G.__OBLIVION_CONFIG_LOADING = prevLoading
            _G.RH_IsConfigLoadingDesync = false
            pcall(function()
                if ESP and ESP._ui and ESP._ui._espBoxSyncVisibility then
                    ESP._ui._espBoxSyncVisibility()
                end
                if ESP and ESP._ui and ESP._ui._syncESPVisibility then
                    ESP._ui._syncESPVisibility()
                end
            end)
            pcall(function()
                local combatUI = _G.__RAIL_UI and _G.__RAIL_UI.combat
                if combatUI and combatUI.sync then
                    combatUI.sync()
                end
            end)
            pcall(function()
                if LootESP and LootESP._ui and LootESP._ui._syncLootVisibility then
                    LootESP._ui._syncLootVisibility()
                end
            end)
            pcall(function()
                local gunmodUI = _G.__RAIL_UI and _G.__RAIL_UI.gunmod
                if gunmodUI and gunmodUI.sync then
                    gunmodUI.sync()
                end
            end)
        end)
        if ok then
            return result
        end
        return nil
    end
end
allvars = _G.allvars
allvars.noswaybool = allvars.noswaybool or false
allvars.instaequip = allvars.instaequip or false
allvars.customRapidFireEnabled = allvars.customRapidFireEnabled or false
allvars.multitaps = allvars.multitaps or 1
allvars.espdead = false
allvars.worldnomines = false
allvars.camthirdp = false
allvars._units = allvars._units or { studsPerMeter = 3.5714285714 }
thirdpshow = (_G.thirdpshow == true)
if not allvars.espchamstransparency then allvars.espchamstransparency = 0.5 end
ESP = ESP or {}
ESP.Highlights = ESP.Highlights or {}
aimbool = false
aimdebug1 = false
aimselftrack = false
aimbots = false
aimvischeck = true
aimdistcheck = false
aimbang = true
aimtrigger = false
aimtarget = nil
aimtargetpart = nil
aimdynamicfov = false
aimpart = "Multipoint"
multipointHeadPercent = 60
multipointBodyPercent = 40
multipointPercentSyncing = false
multipointCacheVersion = 0
rageInstaHitEnabled = false
detectedmods = {}
mdetect = false
if not allvars.detectmods then allvars.detectmods = false end
aimfov = 150
aimsnapline = Drawing.new("Line")
snaplinebool = false
aimdistance = 1000
aimchance = 100
aimfovcircle = Drawing.new("Circle")
aimtargetname = Drawing.new("Text")
aimtargetshots = Drawing.new("Text")
multiShotEnabled = false
multiShotCount = 1
rapidFireEnabled = false
rapidFireValue = 0.1
allvars._rapidFire = allvars._rapidFire or {
    stateByTool = setmetatable({}, {__mode = "k"}),
    originalByState = setmetatable({}, {__mode = "k"}),
    refreshRunning = false
}
function allvars._rapidFire:getCurrentTool()
    local char = localplayer.Character
    if not char then
        return nil
    end
    for _, child in ipairs(char:GetChildren()) do
        if child:IsA("Tool") then
            return child
        end
    end
    return nil
end
function allvars._rapidFire:applyToState(state)
    if type(state) ~= "table" then
        return false
    end
    local settings = rawget(state, "settings")
    if rapidFireEnabled then
        if self.originalByState[state] == nil then
            local orig = nil
            if type(settings) == "table" and type(rawget(settings, "FireRate")) == "number" then
                orig = rawget(settings, "FireRate")
            elseif type(rawget(state, "FireRate")) == "number" then
                orig = rawget(state, "FireRate")
            end
            self.originalByState[state] = orig
        end
        if type(settings) == "table" then
            settings.FireRate = rapidFireValue
        end
        state.FireRate = rapidFireValue
        return true
    end
    local orig = self.originalByState[state]
    if orig ~= nil then
        if type(settings) == "table" then
            settings.FireRate = orig
        end
        state.FireRate = orig
        return true
    end
    return false
end
function allvars._rapidFire:findWeaponStateForTool(tool)
    if not tool or not getgc then
        return nil
    end
    for _, obj in ipairs(getgc(true)) do
        if type(obj) == "table" and type(rawget(obj, "FireRate")) == "number" and rawget(obj, "timeNow") ~= nil then
            local itemProperties = rawget(obj, "itemProperties")
            if itemProperties and typeof(itemProperties) == "Instance" then
                local ok, propsTool = pcall(function()
                    return itemProperties.Tool
                end)
                if ok and propsTool == tool then
                    return obj
                end
            end
            local weapon = rawget(obj, "weapon")
            if weapon and typeof(weapon) == "Instance" then
                local ok, propsTool = pcall(function()
                    return weapon.Value.ItemProperties.Tool
                end)
                if ok and propsTool == tool then
                    return obj
                end
            end
        end
    end
    return nil
end
function allvars._rapidFire:refreshForCurrentTool()
    local tool = self:getCurrentTool()
    if not tool then
        return false
    end
    local cached = self.stateByTool[tool]
    if cached and rawget(cached, "weapon") == tool and rawget(cached, "timeNow") ~= nil then
        return self:applyToState(cached)
    end
    local state = self:findWeaponStateForTool(tool)
    if state then
        self.stateByTool[tool] = state
        return self:applyToState(state)
    end
    return false
end
function allvars._rapidFire:scheduleRefresh()
    if self.refreshRunning then
        return
    end
    self.refreshRunning = true
    task.spawn(function()
        local tries = 0
        while tries < 10 do
            tries = tries + 1
            pcall(function()
                self:refreshForCurrentTool()
            end)
            local tool = self:getCurrentTool()
            if tool and self.stateByTool[tool] then
                break
            end
            task.wait(0.12)
        end
        self.refreshRunning = false
    end)
end
function allvars._rapidFire:bindCharacter(char)
    char.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            task.defer(function()
                self:scheduleRefresh()
            end)
        end
    end)
    char.ChildRemoved:Connect(function(child)
        if child:IsA("Tool") then
            task.defer(function()
                self:scheduleRefresh()
            end)
        end
    end)
end
if localplayer.Character then
    allvars._rapidFire:bindCharacter(localplayer.Character)
end
localplayer.CharacterAdded:Connect(function(char)
    allvars._rapidFire:bindCharacter(char)
end)
local aimogfunc = nil
local aimmodfunc = nil
local function getSafeBulletModule()
    local success, result = pcall(function()
        return game.ReplicatedStorage.Modules.FPS.Bullet
    end)
    if success and result then
        return result
    end
    return nil
end
local function shouldHookBullet()
    return aimbool or multiShotEnabled or rapidFireEnabled
end
local function ensureBulletHook()
    if not aimmodfunc then
        return
    end
    local bulletModule = getSafeBulletModule()
    if not bulletModule then
        return
    end
    local ok, mod = pcall(function()
        return require(bulletModule)
    end)
    if not ok or type(mod) ~= "table" then
        return
    end
    if aimogfunc == nil and type(mod.CreateBullet) == "function" and mod.CreateBullet ~= aimmodfunc then
        aimogfunc = mod.CreateBullet
    end
    if shouldHookBullet() then
        if mod.CreateBullet ~= aimmodfunc then
            mod.CreateBullet = aimmodfunc
        end
    else
        if aimogfunc and mod.CreateBullet ~= aimogfunc then
            mod.CreateBullet = aimogfunc
        end
    end
end
local aimignoreparts = {}
local globalammo = nil
local selftrack_data = {}
local selftrack_update = 0
if not _G.CurrentAmmoCache then
    _G.CurrentAmmoCache = {
        AmmoName = nil,
        MuzzleVelocity = 1000,
        ProjectileDrop = 0,
        DragCoefficient = 0.01,
        ArmorPen = 10,
        Damage = 0,
        Pellets = 1,
        LastUpdate = 0,
        UpdateInterval = 0.5
    }
end
local function updateAmmoCache(ammoObject)
    if not ammoObject then
        return false
    end
    local currentTime = tick()
    local ammoName = ammoObject.Name
    if _G.CurrentAmmoCache and _G.CurrentAmmoCache.AmmoName == ammoName and
       (currentTime - _G.CurrentAmmoCache.LastUpdate) < _G.CurrentAmmoCache.UpdateInterval then
        return false
    end
    local success, data = pcall(function()
        return {
            MuzzleVelocity = ammoObject:GetAttribute("MuzzleVelocity") or 1000,
            ProjectileDrop = ammoObject:GetAttribute("ProjectileDrop") or 0,
            DragCoefficient = ammoObject:GetAttribute("DragCoefficient") or 0.01,
            ArmorPen = ammoObject:GetAttribute("ArmorPen") or 10,
            Damage = ammoObject:GetAttribute("Damage") or 0,
            Pellets = ammoObject:GetAttribute("Pellets") or 1
        }
    end)
    if success and data then
        _G.CurrentAmmoCache.AmmoName = ammoName
        _G.CurrentAmmoCache.MuzzleVelocity = data.MuzzleVelocity
        _G.CurrentAmmoCache.ProjectileDrop = data.ProjectileDrop
        _G.CurrentAmmoCache.DragCoefficient = data.DragCoefficient
        _G.CurrentAmmoCache.ArmorPen = data.ArmorPen
        _G.CurrentAmmoCache.Damage = data.Damage
        _G.CurrentAmmoCache.Pellets = data.Pellets
        _G.CurrentAmmoCache.LastUpdate = currentTime
    end
    return false
end
local function getAmmoStats()
    if globalammo then
        updateAmmoCache(globalammo)
    end
    local cache = _G.CurrentAmmoCache or {}
    return {
        MuzzleVelocity = cache.MuzzleVelocity or 1000,
        ProjectileDrop = cache.ProjectileDrop or 0,
        DragCoefficient = cache.DragCoefficient or 0.01,
        ArmorPen = cache.ArmorPen or 10,
        Damage = cache.Damage or 0,
        Pellets = cache.Pellets or 1
    }
end
local hitsoundbool = false
local hitsoundhead = "Ding"
local hitsoundbody = "Blackout"
local hitsoundlib = {
    ["TF2"]       = "rbxassetid://8255306220",
    ["Gamesense"] = "rbxassetid://4817809188",
    ["Rust"]      = "rbxassetid://1255040462",
    ["Neverlose"] = "rbxassetid://8726881116",
    ["Bubble"]    = "rbxassetid://198598793",
    ["Quake"]     = "rbxassetid://1455817260",
    ["Among-Us"]  = "rbxassetid://7227567562",
    ["Ding"]      = "rbxassetid://2868331684",
    ["Minecraft"] = "rbxassetid://6361963422",
    ["Blackout"]  = "rbxassetid://3748776946",
    ["Osu!"]      = "rbxassetid://7151989073",
}
local hitsoundlibUI = {}
for i,v in hitsoundlib do
    hitsoundlibUI[v] = i
end
localplayer.CharacterAdded:Connect(function(lchar)
    if localplayer.PlayerGui:WaitForChild("MainGui") then
        localplayer.PlayerGui.MainGui.ChildAdded:Connect(function(Sound)
            if Sound:IsA("Sound") and hitsoundbool then
                if Sound.SoundId == "rbxassetid://4585351098" or Sound.SoundId == "rbxassetid://4585382589" then
                    Sound.SoundId = hitsoundlib[hitsoundhead]
                elseif Sound.SoundId == "rbxassetid://4585382046" or Sound.SoundId == "rbxassetid://4585364605" then
                    Sound.SoundId = hitsoundlib[hitsoundbody]
                end
            end
        end)
    end
end)
if localplayer.PlayerGui:FindFirstChild("MainGui") then
    localplayer.PlayerGui.MainGui.ChildAdded:Connect(function(Sound)
        if Sound:IsA("Sound") and hitsoundbool then
            if Sound.SoundId == "rbxassetid://4585351098" or Sound.SoundId == "rbxassetid://4585382589" then
                Sound.SoundId = hitsoundlib[hitsoundhead]
            elseif Sound.SoundId == "rbxassetid://4585382046" or Sound.SoundId == "rbxassetid://4585364605" then
                Sound.SoundId = hitsoundlib[hitsoundbody]
            end
        end
    end)
end
local aimFRIENDLIST = {}
local friendlistmode = "Blacklist"
local friendlistbots = false
pcall(function()
    local fpsmod = require(game.ReplicatedStorage.Modules.FPS)
    if fpsmod and type(fpsmod.updateClient) == "function" then
        local originalUpdateClient = fpsmod.updateClient
        fpsmod.updateClient = function(a1,a2,a3)
            local r1,r2,r3 = originalUpdateClient(a1,a2,a3)
            if allvars._rapidFire and a1 then
                pcall(function()
                    allvars._rapidFire:applyToState(a1)
                end)
            end
            if allvars.noswaybool and a1 and a1.springs then
                local sp = a1.springs
                local zero = Vector3.new()
                sp.sway.Position = zero
                sp.walkCycle.Position = zero
                sp.sprintCycle.Position = zero
                sp.strafeTilt.Position = zero
                sp.jumpTilt.Position = zero
                sp.sway.Speed = 0
                sp.walkCycle.Speed = 0
                sp.sprintCycle.Speed = 0
                sp.strafeTilt.Speed = 0
                sp.jumpTilt.Speed = 0
                pcall(function() sp.sway.Velocity = zero end)
                pcall(function() sp.walkCycle.Velocity = zero end)
                pcall(function() sp.sprintCycle.Velocity = zero end)
                pcall(function() sp.strafeTilt.Velocity = zero end)
                pcall(function() sp.jumpTilt.Velocity = zero end)
                pcall(function() sp.recoilRot.Position = zero end)
                pcall(function() sp.recoilRot.Velocity = zero end)
                pcall(function() sp.recoilPos.Position = zero end)
                pcall(function() sp.recoilPos.Velocity = zero end)
                pcall(function() sp.cameraRecoil.Position = zero end)
                pcall(function() sp.cameraRecoil.Velocity = zero end)
            elseif a1 and a1.springs then
                local sp = a1.springs
                sp.sway.Speed = 4
                sp.walkCycle.Speed = 4
                sp.sprintCycle.Speed = 4
                sp.strafeTilt.Speed = 4
                sp.jumpTilt.Speed = 4
            end
            return r1,r2,r3
        end
    end
end)
local function getCenter()
    local cam = wcamera or Workspace.CurrentCamera
    local viewport = cam and cam.ViewportSize
    if not viewport then
        return Vector2.new(0, 0)
    end
    return Vector2.new(viewport.X * 0.5, viewport.Y * 0.5)
end
local function getTargetModel(target)
    if typeof(target) ~= "Instance" then
        return nil
    end
    if target:IsA("Player") then
        local char = target.Character
        if char and char:IsA("Model") then
            return char
        end
        return nil
    end
    if target:IsA("Model") then
        return target
    end
    return nil
end
local function getTrackerWorldPos(target, fallbackPart)
    local model = getTargetModel(target)
    if model then
        local hrp = model:FindFirstChild("HumanoidRootPart")
        if hrp and hrp:IsA("BasePart") then
            return hrp.Position
        end
        local pp = model.PrimaryPart
        if pp and pp:IsA("BasePart") then
            return pp.Position
        end
        local torso = model:FindFirstChild("UpperTorso") or model:FindFirstChild("LowerTorso") or model:FindFirstChild("Torso")
        if torso and torso:IsA("BasePart") then
            return torso.Position
        end
        local head = model:FindFirstChild("Head")
        if head and head:IsA("BasePart") then
            return head.Position
        end
        local ok, cf = pcall(function()
            local boxCf = model:GetBoundingBox()
            return boxCf
        end)
        if ok and cf and typeof(cf) == "CFrame" then
            return cf.Position
        end
        local anyPart = model:FindFirstChildWhichIsA("BasePart", true)
        if anyPart then
            return anyPart.Position
        end
    end
    if typeof(fallbackPart) == "Instance" and fallbackPart:IsA("BasePart") then
        return fallbackPart.Position
    end
    return nil
end
local function worldToScreenPoint2D(worldPos, cam)
    cam = cam or Workspace.CurrentCamera
    if not cam then
        return nil
    end
    local v3 = cam:WorldToViewportPoint(worldPos)
    if not v3 or v3.Z <= 0 then
        return nil
    end
    return Vector2.new(v3.X, v3.Y)
end
local function LerpColor3(a, b, t)
    t = math.clamp(t, 0, 1)
    return Color3.new(
        a.R + (b.R - a.R) * t,
        a.G + (b.G - a.G) * t,
        a.B + (b.B - a.B) * t
    )
end
local CollectBodyParts
local _espBodyPartsCache = setmetatable({}, { __mode = "k" })
local function GetCachedBodyParts(model)
    if typeof(model) ~= "Instance" or not model:IsA("Model") then
        return {}
    end
    local now = os.clock()
    local entry = _espBodyPartsCache[model]
    if entry and entry.parts and now < entry.expiresAt then
        local p = entry.parts[1]
        if p and p.Parent then
            return entry.parts
        end
    end
    if type(CollectBodyParts) ~= "function" then
        return {}
    end
    local parts = CollectBodyParts(model)
    _espBodyPartsCache[model] = { parts = parts, expiresAt = now + 0.35 }
    return parts
end
local function ApplyUnifiedCornerGradient(cornerLines, cornerGradients, w, h, thickness, cornerLen, rot, useGrad, c1, c2, solid)
    if not cornerLines or not cornerGradients then
        return
    end
    if not useGrad then
        for name, line in pairs(cornerLines) do
            local grad = cornerGradients[name]
            if grad then
                grad.Enabled = false
            end
            if line then
                line.BackgroundColor3 = solid
            end
        end
        return
    end

    local rad = math.rad(rot)
    local dx, dy = math.cos(rad), math.sin(rad)
    local function proj(x, y)
        return x * dx + y * dy
    end
    local p00 = proj(0, 0)
    local p10 = proj(w, 0)
    local p01 = proj(0, h)
    local p11 = proj(w, h)
    local minP = math.min(p00, p10, p01, p11)
    local maxP = math.max(p00, p10, p01, p11)
    local denom = maxP - minP
    if denom <= 0 then
        denom = 1
    end
    local function tFrom(x, y)
        return math.clamp((proj(x, y) - minP) / denom, 0, 1)
    end
    local function setRect(name, x, y, rw, rh)
        local line = cornerLines[name]
        local grad = cornerGradients[name]
        if not line or not grad then
            return
        end
        local t1 = tFrom(x, y)
        local t2 = tFrom(x + rw, y)
        local t3 = tFrom(x, y + rh)
        local t4 = tFrom(x + rw, y + rh)
        local tMin = math.min(t1, t2, t3, t4)
        local tMax = math.max(t1, t2, t3, t4)
        line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        grad.Enabled = true
        grad.Rotation = rot
        grad.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, LerpColor3(c1, c2, tMin)),
            ColorSequenceKeypoint.new(1, LerpColor3(c1, c2, tMax))
        }
    end

    setRect("CornerTopLeftH", 0, 0, cornerLen, thickness)
    setRect("CornerTopLeftV", 0, 0, thickness, cornerLen)
    setRect("CornerTopRightH", w - cornerLen, 0, cornerLen, thickness)
    setRect("CornerTopRightV", w - thickness, 0, thickness, cornerLen)
    setRect("CornerBottomLeftH", 0, h - thickness, cornerLen, thickness)
    setRect("CornerBottomLeftV", 0, h - cornerLen, thickness, cornerLen)
    setRect("CornerBottomRightH", w - cornerLen, h - thickness, cornerLen, thickness)
    setRect("CornerBottomRightV", w - thickness, h - cornerLen, thickness, cornerLen)
end
CollectBodyParts = function(model)
    if typeof(model) ~= "Instance" or not model:IsA("Model") then
        return {}
    end
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    local useR15 = humanoid and humanoid.RigType == Enum.HumanoidRigType.R15
    local whitelist = {}
    if useR15 then
        whitelist.Head = true
        whitelist.UpperTorso = true
        whitelist.LowerTorso = true
        whitelist.LeftUpperArm = true
        whitelist.LeftLowerArm = true
        whitelist.LeftHand = true
        whitelist.RightUpperArm = true
        whitelist.RightLowerArm = true
        whitelist.RightHand = true
        whitelist.LeftUpperLeg = true
        whitelist.LeftLowerLeg = true
        whitelist.LeftFoot = true
        whitelist.RightUpperLeg = true
        whitelist.RightLowerLeg = true
        whitelist.RightFoot = true
    else
        whitelist.Head = true
        whitelist.Torso = true
        whitelist["Left Arm"] = true
        whitelist["Right Arm"] = true
        whitelist["Left Leg"] = true
        whitelist["Right Leg"] = true
    end
    local parts = {}
    for _, inst in ipairs(model:GetDescendants()) do
        if inst:IsA("BasePart") then
            local n = inst.Name
            if whitelist[n] then
                parts[#parts + 1] = inst
            else
                local nl = string.lower(n)
                if string.find(nl, "hitbox", 1, true) then
                    parts[#parts + 1] = inst
                end
            end
        end
    end
    if #parts == 0 then
        local hrp = model:FindFirstChild("HumanoidRootPart")
        if hrp and hrp:IsA("BasePart") then
            parts[1] = hrp
        else
            local anyPart = model:FindFirstChildWhichIsA("BasePart", true)
            if anyPart then
                parts[1] = anyPart
            end
        end
    end
    return parts
end
local function ComputeViewportBoundsFromParts(parts, cam)
    if not cam then
        return nil
    end
    local minX, minY = math.huge, math.huge
    local maxX, maxY = -math.huge, -math.huge
    local any = false
    for i = 1, #parts do
        local part = parts[i]
        if part and part.Parent then
            local cf = part.CFrame
            local pos = cf.Position
            local right = cf.RightVector
            local up = cf.UpVector
            local look = cf.LookVector
            local size = part.Size
            local ex = size.X * 0.5
            local ey = size.Y * 0.5
            local ez = size.Z * 0.5

            local function sample(dx, dy, dz)
                local p = pos + right * dx + up * dy + look * dz
                local v = cam:WorldToViewportPoint(p)
                if v and v.Z > 0 then
                    any = true
                    local x, y = v.X, v.Y
                    if x < minX then minX = x end
                    if x > maxX then maxX = x end
                    if y < minY then minY = y end
                    if y > maxY then maxY = y end
                end
            end

            sample(-ex, -ey, -ez)
            sample(-ex, -ey,  ez)
            sample(-ex,  ey, -ez)
            sample(-ex,  ey,  ez)
            sample( ex, -ey, -ez)
            sample( ex, -ey,  ez)
            sample( ex,  ey, -ez)
            sample( ex,  ey,  ez)
        end
    end
    if not any or minX >= maxX or minY >= maxY then
        return nil
    end
    return minX, maxX, minY, maxY
end
aimfovcircle.Visible = false
aimfovcircle.Radius = aimfov
aimfovcircle.Thickness = 0.5
aimfovcircle.Filled = false
aimfovcircle.Transparency = 0.2
aimfovcircle.Color = Color3.fromRGB(255, 255, 255)
aimfovcircle.Position = getCenter()
aimtargetname.Text = "None"
aimtargetname.Position = getCenter() + Vector2.new(0, aimfov + 20)
aimtargetname.Size = 24
aimtargetname.Color = Color3.fromRGB(255,255,255)
aimtargetname.Visible = false
aimtargetname.Center = true
aimtargetname.Outline = true
aimtargetname.OutlineColor = Color3.new(0, 0, 0)
aimtargetname.Font = 3
aimtargetshots.Text = " "
aimtargetshots.Position = getCenter() + Vector2.new(0, aimfov + 30)
aimtargetshots.Size = 20
aimtargetshots.Color = Color3.fromRGB(255,255,255)
aimtargetshots.Visible = false
aimtargetshots.Center = true
aimtargetshots.Outline = true
aimtargetshots.OutlineColor = Color3.new(0, 0, 0)
aimsnapline.From = Vector2.new(20, 20)
aimsnapline.To = Vector2.new(50, 50)
aimsnapline.Color = Color3.fromRGB(255,255,255)
aimsnapline.Thickness = 1
aimsnapline.Visible = false
_G.allvars._rt.track(runs.RenderStepped:Connect(function()
    local center = getCenter()
    aimfovcircle.Position = center
    aimfovcircle.Radius = aimfov
    if not targetNameVisibilityConnection then
        aimtargetname.Position = center + Vector2.new(0, aimfov + 20)
    end
    aimtargetshots.Position = center + Vector2.new(0, aimfov + 30)
end))
for i,v in ipairs(workspace:GetDescendants()) do
    if v:GetAttribute("PassThrough") then
        table.insert(aimignoreparts, v)
    end
end
local sharedRayParams = RaycastParams.new()
sharedRayParams.IgnoreWater = true
sharedRayParams.CollisionGroup = "WeaponRay"
sharedRayParams.FilterType = Enum.RaycastFilterType.Exclude
local fallbackRayParams = RaycastParams.new()
fallbackRayParams.IgnoreWater = true
fallbackRayParams.FilterType = Enum.RaycastFilterType.Exclude
local FunctionLibraryExtension = require(game.ReplicatedStorage.Modules.FunctionLibraryExtension)
local sharedIgnoreList = {}
local function isvisible(char, object, customPos)
    if not localplayer.Character or not localplayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    if aimvischeck == false then
        return true
    end
    local cam = wcamera or workspace.CurrentCamera
    local origin = (cam and cam.CFrame and cam.CFrame.Position) or (localplayer.Character.HumanoidRootPart.Position + Vector3.new(0, 1.5, 0))
    local pos = customPos or object.Position
    local dir = pos - origin
    local dist = dir.Magnitude + 5
    dir = dir.Unit
    table.clear(sharedIgnoreList)
    table.insert(sharedIgnoreList, localplayer.Character)
    if wcamera then table.insert(sharedIgnoreList, wcamera) end
    if workspace.CurrentCamera and workspace.CurrentCamera ~= wcamera then
        table.insert(sharedIgnoreList, workspace.CurrentCamera)
    end
    if aimignoreparts then
        for i = 1, #aimignoreparts do
            table.insert(sharedIgnoreList, aimignoreparts[i])
        end
    end
    sharedRayParams.FilterDescendantsInstances = sharedIgnoreList
    fallbackRayParams.FilterDescendantsInstances = sharedIgnoreList
    local targetChar = char
    if not char:IsA("Model") then
        targetChar = char.Character
    end
    local ray = workspace:Raycast(origin, dir * dist, sharedRayParams)
    if not ray then
        ray = workspace:Raycast(origin, dir * dist, fallbackRayParams)
        if not ray then
            return true
        end
    end
    if ray and ray.Instance:IsDescendantOf(targetChar) then
        return true
    elseif ray and ray.Instance.Name ~= "Terrain" and not ray.Instance:GetAttribute("NoPen") then
        local ammoStats = getAmmoStats()
        if ammoStats then
            local armorpen4 = ammoStats.ArmorPen
            local armorpen1, newpos2 = FunctionLibraryExtension.Penetration(FunctionLibraryExtension, ray.Instance, ray.Position, dir, armorpen4)
            if armorpen1 and newpos2 then
                local neworigin = ray.Position + dir * 0.01
                local newray = workspace:Raycast(neworigin, dir * (dist - (neworigin - origin).Magnitude), sharedRayParams)
                if newray and newray.Instance:IsDescendantOf(targetChar) then
                    return true
                end
            end
        end
    end
    return false
end
local function predictpos(targetPart, bulletSpeed)
    if not targetPart or not bulletSpeed or bulletSpeed <= 0 then
        return targetPart and targetPart.Position or Vector3.new(0, 0, 0)
    end
    local targetPos = targetPart.Position
    local targetVel = targetPart.AssemblyLinearVelocity or targetPart.Velocity or Vector3.new(0, 0, 0)
    local shooterPos = wcamera.CFrame.Position
    if targetVel.Magnitude < 0.1 then
        return targetPos
    end
    local distance = (shooterPos - targetPos).Magnitude
    local timeToHit = distance / bulletSpeed
    local predictedPos = targetPos + (targetVel * timeToHit)
    return predictedPos
end
local function predict_velocity(Origin, Destination, DestinationVelocity, ProjectileSpeed)
    local Distance = (Destination - Origin).Magnitude
    local TimeToHit = (Distance / ProjectileSpeed)
    local Predicted = Destination + DestinationVelocity * TimeToHit
    local Delta = (Predicted - Origin).Magnitude / ProjectileSpeed
    TimeToHit = TimeToHit + (Delta / ProjectileSpeed)
    local Actual = Destination + DestinationVelocity * TimeToHit
    return Actual
end
local function predict_velocity_insta_hit(origin, destination, velocity, speed)
    local destinationVelocity = velocity or Vector3.new()
    local predicted = predict_velocity(origin, destination, destinationVelocity, speed)
    return predicted
end
local function predict_drop(Origin, Destination, ProjectileSpeed, ProjectileDrop)
    if ProjectileDrop == 0 then return 0 end
    local Distance = (Destination - Origin).Magnitude
    local TimeToHit = (Distance / ProjectileSpeed)
    TimeToHit = TimeToHit + (Distance / ProjectileSpeed)
    local DropTime = ProjectileDrop * TimeToHit ^ 2
    if tostring(DropTime):find("nan") or (Distance <= 100) then
        return 0
    end
    return DropTime
end
local LinePool = {
    Lines = {},
    MaxSize = 20,
    ActiveLines = {},
    CleanupInterval = 2,
    LastCleanup = tick()
}
function LinePool:GetLine()
    local currentTime = tick()
    if currentTime - self.LastCleanup > self.CleanupInterval then
        self:Cleanup()
        self.LastCleanup = currentTime
    end
    for i, line in ipairs(self.Lines) do
        if not line.InUse then
            line.InUse = true
            line.LastUsed = tick()
            table.insert(self.ActiveLines, line)
            return line.Object
        end
    end
    if #self.Lines < self.MaxSize then
        local newLine = Drawing.new("Line")
        newLine.Visible = false
        newLine.Thickness = 1
        newLine.Transparency = 1
        local lineData = {
            Object = newLine,
            InUse = true,
            LastUsed = tick()
        }
        table.insert(self.Lines, lineData)
        table.insert(self.ActiveLines, lineData)
        return newLine
    end
    local oldestLine = nil
    local oldestTime = math.huge
    for _, lineData in ipairs(self.Lines) do
        if lineData.LastUsed < oldestTime then
            oldestLine = lineData
            oldestTime = lineData.LastUsed
        end
    end
    if oldestLine then
        oldestLine.InUse = true
        oldestLine.LastUsed = tick()
        oldestLine.Object.Visible = false
        return oldestLine.Object
    end
    local tempLine = Drawing.new("Line")
    tempLine.Visible = false
    tempLine.Thickness = 1
    tempLine.Transparency = 1
    return tempLine
end
function LinePool:ReleaseLine(line)
    for i, lineData in ipairs(self.Lines) do
        if lineData.Object == line then
            lineData.InUse = false
            line.Visible = false
            for j, activeLine in ipairs(self.ActiveLines) do
                if activeLine == lineData then
                    table.remove(self.ActiveLines, j)
                    break
                end
            end
            break
        end
    end
end
function LinePool:ReleaseAll()
    for i, lineData in ipairs(self.Lines) do
        lineData.InUse = false
        lineData.Object.Visible = false
    end
    self.ActiveLines = {}
end
function LinePool:Cleanup()
    local currentTime = tick()
    local inactiveTime = 10
    for i = #self.Lines, 1, -1 do
        local lineData = self.Lines[i]
        if not lineData.InUse and (currentTime - lineData.LastUsed > inactiveTime) then
            pcall(function()
                lineData.Object:Remove()
            end)
            table.remove(self.Lines, i)
        end
    end
end
_G.allvars._rt.track(runs.Heartbeat:Connect(function()
    if #LinePool.Lines > LinePool.MaxSize * 0.8 then
        LinePool:Cleanup()
    end
end))
local function getMultiPoints(part)
    if not part then return {} end
    local points = {part.Position}
    if not part:IsA("BasePart") then return points end
    local size = part.Size
    local cf = part.CFrame
    table.insert(points, (cf * CFrame.new(0, size.Y/2 - 0.1, 0)).Position)
    table.insert(points, (cf * CFrame.new(0, -size.Y/2 + 0.1, 0)).Position)
    table.insert(points, (cf * CFrame.new(size.X/2 - 0.1, 0, 0)).Position)
    table.insert(points, (cf * CFrame.new(-size.X/2 + 0.1, 0, 0)).Position)
    return points
end
pcall(function()
    aimogfunc = require(game.ReplicatedStorage.Modules.FPS.Bullet).CreateBullet
end)
local MultipointCache = setmetatable({}, {__mode = "k"})
local MultipointTypeCache = setmetatable({}, {__mode = "k"})
local function choosetarget()
        if _G.AimChooseTargetImpl and _G.AimChooseTargetImpl ~= choosetarget then
            return _G.AimChooseTargetImpl()
        end
        local cent = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2)
        local cdist = math.huge
        local ctar = nil
        local cpart = nil
        local restar = nil
        local predist = math.huge
        local ammodistance = 999999999
        if aimdistcheck then
            local ammoStats = getAmmoStats()
            ammodistance = ammoStats.MuzzleVelocity * 1.5
        end
        local function chooseTpart(charact)
            if aimpart == "Head" then
                return charact:FindFirstChild("Head")
            elseif aimpart == "HeadTop" then
                return charact:FindFirstChild("HeadTopHitBox")
            elseif aimpart == "Face" then
                return charact:FindFirstChild("FaceHitBox")
            elseif aimpart == "Torso" then
                return charact:FindFirstChild("UpperTorso")
            elseif aimpart == "Multipoint" then
                local ver = multipointCacheVersion or 0
                local pickEntry = MultipointTypeCache[charact]
                local pick = nil
                if type(pickEntry) == "table" then
                    if pickEntry.Version == ver then
                        pick = pickEntry.Pick
                    end
                else
                    pick = pickEntry
                end
                if not pick then
                    local headP = tonumber(multipointHeadPercent) or 50
                    if headP < 0 then headP = 0 end
                    if headP > 100 then headP = 100 end
                    pick = (math.random(0, 99) < headP) and "Head" or "Body"
                    MultipointTypeCache[charact] = { Version = ver, Pick = pick }
                end
                local cachedEntry = MultipointCache[charact]
                local cached = nil
                if type(cachedEntry) == "table" then
                    if cachedEntry.Version == ver then
                        cached = cachedEntry.Part
                    end
                else
                    cached = cachedEntry
                end
                if cached and cached:IsDescendantOf(charact) and isvisible(charact, cached) then
                    return cached
                end
                local priorityParts
                if pick == "Head" then
                    priorityParts = {"Head", "HeadTopHitBox", "FaceHitBox", "UpperTorso", "HumanoidRootPart"}
                else
                    priorityParts = {"UpperTorso", "LowerTorso", "HumanoidRootPart", "Head"}
                end
                if localplayer.Character and localplayer.Character.PrimaryPart and charact.PrimaryPart then
                     local d = (localplayer.Character.PrimaryPart.Position - charact.PrimaryPart.Position).Magnitude
                     if d > 150 then
                         if pick == "Head" then
                             priorityParts = {"Head", "UpperTorso", "HumanoidRootPart"}
                         else
                             priorityParts = {"UpperTorso", "HumanoidRootPart", "Head"}
                         end
                     end
                end
                for _, partName in ipairs(priorityParts) do
                    local part = charact:FindFirstChild(partName)
                    if part and part ~= cached and isvisible(charact, part) then
                        MultipointCache[charact] = { Version = ver, Part = part }
                        return part
                    end
                end
                if pick == "Body" then
                    return charact:FindFirstChild("UpperTorso") or charact:FindFirstChild("LowerTorso") or charact:FindFirstChild("HumanoidRootPart") or charact:FindFirstChild("Head")
                end
                return charact:FindFirstChild("Head") or charact:FindFirstChild("UpperTorso") or charact:FindFirstChild("HumanoidRootPart")
            elseif aimpart == "Scripted" then
                local head = charact:FindFirstChild("Head")
                local upperTorso = charact:FindFirstChild("UpperTorso")
                if not isvisible(charact, head) then
                    return upperTorso
                else
                    return head
                end
            else
                return charact:FindFirstChild("Head")
            end
        end
        if aimbots then
            if not _G.AimbotBotCache then
                _G.AimbotBotCache = {
                    bots = {},
                    connections = {}
                }
                local function isBot(model)
                    return model:IsA("Model") and model:FindFirstChild("Humanoid") and model:FindFirstChild("HumanoidRootPart") and not game.Players:GetPlayerFromCharacter(model)
                end
                local function addBot(model)
                    if isBot(model) and not table.find(_G.AimbotBotCache.bots, model) then
                        table.insert(_G.AimbotBotCache.bots, model)
                    end
                end
                local function removeBot(model)
                    local idx = table.find(_G.AimbotBotCache.bots, model)
                    if idx then
                        table.remove(_G.AimbotBotCache.bots, idx)
                    end
                end
                task.spawn(function()
                    for _, descendant in pairs(workspace:GetDescendants()) do
                        addBot(descendant)
                    end
                end)
                local conn = workspace.DescendantAdded:Connect(function(descendant)
                    if descendant:IsA("Model") then
                         task.spawn(function()
                             if descendant:WaitForChild("Humanoid", 5) and descendant:WaitForChild("HumanoidRootPart", 5) then
                                 addBot(descendant)
                             end
                         end)
                    elseif descendant:IsA("Humanoid") or descendant.Name == "HumanoidRootPart" then
                         if descendant.Parent and descendant.Parent:IsA("Model") then
                             addBot(descendant.Parent)
                         end
                    end
                end)
                table.insert(_G.AimbotBotCache.connections, conn)
                local conn2 = workspace.DescendantRemoving:Connect(function(descendant)
                    removeBot(descendant)
                end)
                table.insert(_G.AimbotBotCache.connections, conn2)
            end
            if math.random() < 0.05 then
                 for i = #_G.AimbotBotCache.bots, 1, -1 do
                    local bot = _G.AimbotBotCache.bots[i]
                    if not bot or not bot.Parent or not bot:FindFirstChild("Humanoid") or bot.Humanoid.Health <= 0 then
                        table.remove(_G.AimbotBotCache.bots, i)
                    end
                 end
            end
            for _, bot in ipairs(_G.AimbotBotCache.bots) do
                if bot and bot.Parent and bot:FindFirstChild("Humanoid") and bot:FindFirstChild("HumanoidRootPart") and bot.Humanoid.Health > 0 then
                    if friendlistbots then
                        if friendlistmode == "Blacklist" then
                            if table.find(aimFRIENDLIST, bot.Name) ~= nil then
                                continue
                            end
                        elseif friendlistmode == "Whitelist" then
                            if table.find(aimFRIENDLIST, bot.Name) == nil then
                                continue
                            end
                        end
                    end
                    local potroot = chooseTpart(bot)
                    if potroot and potroot.Position and localplayer.Character and localplayer.Character.PrimaryPart then
                        local spoint = wcamera:WorldToScreenPoint(potroot.Position)
                        local optpoint = Vector2.new(spoint.X, spoint.Y)
                        local dist = (optpoint - cent).Magnitude
                        local betweendist = (localplayer.Character.PrimaryPart.Position - potroot.Position).Magnitude / allvars._units.studsPerMeter
                        local betweendistSTUDS = (localplayer.Character.PrimaryPart.Position - potroot.Position).Magnitude
                        if dist <= aimfov and dist < cdist and betweendist < aimdistance and betweendistSTUDS < ammodistance and spoint.Z > 0 then
                            local canvis = isvisible(bot, potroot)
                            if canvis then
                                cdist = dist
                                ctar = bot
                                cpart = potroot
                            end
                            if dist < predist then
                                predist = dist
                                restar = bot
                            end
                        end
                    end
                end
            end
        end
        for _, pottar in pairs(game.Players:GetPlayers()) do
            if pottar ~= localplayer and pottar.Character and pottar.Character:FindFirstChild("Humanoid") and pottar.Character.Humanoid.Health > 0 and localplayer.Character and localplayer.Character.PrimaryPart ~= nil then
                if friendlistmode == "Blacklist" then
                    if table.find(aimFRIENDLIST, pottar.Name) ~= nil then
                        continue
                    end
                elseif friendlistmode == "Whitelist" then
                    if table.find(aimFRIENDLIST, pottar.Name) == nil then
                        continue
                    end
                end
                local potroot = chooseTpart(pottar.Character)
                if potroot and potroot.Position then
                    local spoint = wcamera:WorldToScreenPoint(potroot.Position)
                    local optpoint = Vector2.new(spoint.X, spoint.Y)
                    local dist = (optpoint - cent).Magnitude
                    local betweendist = (localplayer.Character.PrimaryPart.Position - potroot.Position).Magnitude / allvars._units.studsPerMeter
                    local betweendistSTUDS = (localplayer.Character.PrimaryPart.Position - potroot.Position).Magnitude
                    if dist <= aimfov and dist < cdist and betweendist < aimdistance and betweendistSTUDS < ammodistance and spoint.Z > 0 then
                        local canvis = isvisible(pottar.Character, potroot)
                        if canvis then
                            cdist = dist
                            ctar = pottar
                            cpart = potroot
                        end
                        if dist < predist then
                            predist = dist
                            restar = pottar
                        end
                    end
                end
            end
        end
        if ctar == nil then
            aimtarget = nil
            aimtargetpart = nil
            if restar then
                aimpretarget = restar
            else
                aimpretarget = nil
            end
        else
            aimtarget = ctar
            aimtargetpart = cpart
            aimpretarget = restar
        end
    end
    local function createSilentCamera(realCamera, desiredCFrame)
        local fakeCamera = {
            CFrame = desiredCFrame
        }
        local meta = {
            __index = function(self, key)
                if key == "CFrame" then
                    return desiredCFrame
                end
                local target = realCamera
                if not target then return nil end
                local val = target[key]
                if type(val) == "function" then
                    return function(_, ...)
                        return val(target, ...)
                    end
                end
                return val
            end,
            __newindex = function(self, key, value)
                if key == "CFrame" then
                    rawset(self, key, value)
                else
                    local target = realCamera
                    if target then
                        target[key] = value
                    end
                end
            end
        }
        return setmetatable(fakeCamera, meta)
    end
    local function hasWeaponEquipped()
        local camera = workspace.CurrentCamera
        if not camera then return false end
        local viewModel = camera:FindFirstChild("ViewModel")
        if not viewModel then return false end
        local item = viewModel:FindFirstChild("Item")
        if not item then return false end
        local hasGunPart = false
        for _, part in ipairs(item:GetDescendants()) do
            if part:IsA("BasePart") and (part.Name == "AimPart" or part.Name == "Gunmuzzle" or part.Name:match("Barrel")) then
                hasGunPart = true
                break
            end
        end
        return hasGunPart
    end
    local function createBulletTracer()
        local RunService = game:GetService("RunService")
        if not _G.ScriptData or not _G.ScriptData.bulletTracerEnabled then return end
        if not hasWeaponEquipped() then return end
        local camera = workspace.CurrentCamera
        if not camera then return end
        local startPos = camera.CFrame.Position
        local viewModel = camera:FindFirstChild("ViewModel")
        local muzzle = nil
        local aimPart = nil
        if viewModel then
            local weapon = viewModel:FindFirstChild("Item")
            if weapon then
                for _, part in pairs(weapon:GetDescendants()) do
                    if part:IsA("BasePart") then
                        if part.Name == "Gunmuzzle" then
                            muzzle = part
                        elseif part.Name == "AimPart" then
                            aimPart = part
                        end
                    end
                end
            end
        end
        if muzzle then
            startPos = muzzle.Position
        elseif aimPart then
            startPos = aimPart.Position
        end
        local direction = camera.CFrame.LookVector
        local endPos = nil
        if aimbool and aimtarget and aimtargetpart and isvisible(aimtarget:IsA("Model") and aimtarget or aimtarget.Character, aimtargetpart) then
            local targetPos = aimtargetpart.Position
            if aimtype == "Prediction" then
                local ammoStats = getAmmoStats()
                local bulletSpeed = ammoStats.MuzzleVelocity
                targetPos = predictpos(aimtargetpart, bulletSpeed)
            end
            direction = (targetPos - startPos).Unit
            endPos = targetPos
        else
            endPos = startPos + direction * (_G.ScriptData.bulletTracerMaxDistance or 1300)
            local ray = Ray.new(startPos, direction * (_G.ScriptData.bulletTracerMaxDistance or 1300))
            local ignoreList = {localplayer.Character, camera, viewModel}
            local hit, hitPos = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
            if hit then
                endPos = hitPos
            end
        end
        local beamPart = Instance.new("Part")
        beamPart.Name = "BulletTracer"
        beamPart.Size = Vector3.new(_G.ScriptData.bulletTracerWidth or 0.2, 0.1, 0.1)
        beamPart.Transparency = 1
        beamPart.CanCollide = false
        beamPart.Anchored = true
        beamPart.CFrame = CFrame.new(startPos)
        beamPart.Parent = workspace
        local startAttachment = Instance.new("Attachment", beamPart)
        startAttachment.WorldPosition = startPos
        local endAttachment = Instance.new("Attachment", beamPart)
        endAttachment.WorldPosition = endPos
        local beam = Instance.new("Beam")
        beam.Attachment0 = startAttachment
        beam.Attachment1 = endAttachment
        beam.Texture = _G.ScriptData.bulletTracerTexture or "http://www.roblox.com/asset/?id=446111271"
        beam.TextureMode = Enum.TextureMode.Wrap
        beam.TextureLength = 1
        beam.TextureSpeed = _G.ScriptData.bulletTracerSpeed or 5
        beam.FaceCamera = true
        beam.Color = ColorSequence.new(_G.ScriptData.bulletTracerColor or Color3.fromRGB(255, 255, 255))
        beam.Width0 = _G.ScriptData.bulletTracerWidth or 0.2
        beam.Width1 = _G.ScriptData.bulletTracerWidth or 0.2
        beam.LightEmission = 1
        beam.Parent = beamPart
        local tracerLifetime = _G.ScriptData.bulletTracerLifetime or 1
        local startTime = tick()
        local beamRef = setmetatable({value = beam}, {__mode = "v"})
        local beamPartRef = setmetatable({value = beamPart}, {__mode = "v"})
        local maxTracers = 10
        if not _G.ScriptData.activeBulletTracers then
            _G.ScriptData.activeBulletTracers = {}
        end
        while #_G.ScriptData.activeBulletTracers >= maxTracers do
            local oldestTracer = table.remove(_G.ScriptData.activeBulletTracers, 1)
            if oldestTracer and oldestTracer.part then
                pcall(function()
                    if oldestTracer.part:IsDescendantOf(workspace) then
                        oldestTracer.part:Destroy()
                    end
                end)
            end
        end
        table.insert(_G.ScriptData.activeBulletTracers, {
            part = beamPart,
            beam = beam,
            startTime = startTime
        })
        local bulletAnimation = RunService.RenderStepped:Connect(function()
            local currentTime = tick() - startTime
            local beam = beamRef and beamRef.value
            local beamPart = beamPartRef and beamPartRef.value
            if currentTime >= tracerLifetime or not beam or not beamPart or not beam.Parent or not beamPart:IsDescendantOf(workspace) then
                if bulletAnimation then
                    pcall(function() bulletAnimation:Disconnect() end)
                    bulletAnimation = nil
                end
                if beamPart and beamPart:IsDescendantOf(workspace) then
                    if beam then
                        pcall(function() beam.Enabled = false end)
                    end
                    pcall(function() beamPart:Destroy() end)
                end
                return
            end
            local fadeStartTime = tracerLifetime * (_G.ScriptData.bulletTracerFadeoutPoint or 0.7)
            if currentTime > fadeStartTime then
                local fadeProgress = (currentTime - fadeStartTime) / (tracerLifetime - fadeStartTime)
                local transparencySequence = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, fadeProgress),
                    NumberSequenceKeypoint.new(1, 1)
                })
                beam.Transparency = transparencySequence
                if fadeProgress > 0.9 then
                    local widthScale = 1 - ((fadeProgress - 0.9) * 10)
                    beam.Width0 = (_G.ScriptData.bulletTracerWidth or 0.2) * widthScale
                    beam.Width1 = (_G.ScriptData.bulletTracerWidth or 0.2) * widthScale
                end
            end
        end)
    end
    local overrideBarrelPos = false
    local currentBarrel = nil
    local old_index
    aimmodfunc = function(prikol, p49, p50, p_u_51, p52, p_unused, p53, p54, p55)
        if rapidFireEnabled then
            pcall(function()
                 if prikol and prikol.settings then
                      prikol.settings.FireRate = rapidFireValue
                      prikol.FireRate = rapidFireValue
                 end
            end)
        end
        if _G.ScriptData and _G.ScriptData.bulletTracerEnabled then
            task.spawn(createBulletTracer)
        end
        choosetarget()
        local target = aimtarget
        local target_part = aimtargetpart
        local function fireWithCamera(cam)
            local result = {aimogfunc(prikol, p49, p50, p_u_51, cam, p_unused, p53, p54, p55)}
            if multiShotEnabled and multiShotCount > 1 then
                local extra = multiShotCount - 1
                for _ = 1, extra do
                    aimogfunc(prikol, p49, p50, p_u_51, cam, p_unused, p53, p54, p55)
                end
            end
            return result
        end
        if not aimbool then
            return unpack(fireWithCamera(p52))
        end
        if target == nil or target_part == nil then
            return unpack(fireWithCamera(p52))
        end
        if aimvischeck then
            local targetChar = target:IsA("Model") and target or target.Character
            local canShoot = isvisible(targetChar, target_part)
            if not canShoot then
                return unpack(fireWithCamera(p52))
            end
        end
        local success_lib, v_u_4 = pcall(function()
            return require(game.ReplicatedStorage.Modules:WaitForChild("FunctionLibraryExtension"))
        end)
        if not success_lib then
            return unpack(fireWithCamera(p52))
        end
        local camPos = v_u_4:GetEstimatedCameraPosition(localplayer)
        local tempOldPos = nil
        local targetPos
        local success, v65 = pcall(function()
            return game:GetService("ReplicatedStorage").AmmoTypes:FindFirstChild(p53)
        end)
        if success and v65 then
            globalammo = v65
            updateAmmoCache(globalammo)
        end
        local bulsp = 1000
        local buldrop = 0
        if success and v65 then
            bulsp = v65:GetAttribute("MuzzleVelocity") or 1000
            buldrop = v65:GetAttribute("ProjectileDrop") or 0
        end
        local origin = camPos
        local targetVelocity = target_part.AssemblyLinearVelocity or target_part.Velocity or Vector3.new(0, 0, 0)
        local basePos = aimtargetposition or target_part.Position
        local desiredPos
        if rageInstaHitEnabled then
            desiredPos = basePos
        else
            desiredPos = predict_velocity(origin, basePos, targetVelocity, bulsp)
        end
        local targetPos = desiredPos
        local chance = aimchance or 100
        if chance < 100 then
            chance = math.clamp(chance, 0, 100)
            local roll = math.random(1, 100)
            if roll > chance then
                local dir = desiredPos - origin
                local dist = dir.Magnitude
                if dist > 0 then
                    dir = dir / dist
                    local right = dir:Cross(Vector3.new(0, 1, 0))
                    if right.Magnitude < 1e-3 then
                        right = dir:Cross(Vector3.new(0, 0, 1))
                    end
                    if right.Magnitude > 0 then
                        right = right.Unit
                        local sideSign = (math.random(0, 1) == 0) and -1 or 1
                        local sideAmount = math.clamp(dist * 0.05, 3, 12)
                        local upAmount = math.random(-3, 3)
                        targetPos = desiredPos + right * sideAmount * sideSign + Vector3.new(0, upAmount, 0)
                    end
                end
            end
        end
        local silentCFrame = CFrame.new(camPos, targetPos)
        local silentCamera = createSilentCamera(p52, silentCFrame)
        return unpack(fireWithCamera(silentCamera))
    end
do
    local old_namecall
    old_namecall = hookmetamethod(game, "__namecall", function(self, ...)
        local args = {...}
        local method = getnamecallmethod()
        if method == "InvokeServer" and self.Name == "FireProjectile" then
            if aimbool and rageInstaHitEnabled and aimtargetpart then
                args[3] = 0/0
                return old_namecall(self, unpack(args))
            end
        end
        if method == "FireServer" and self.Name == "ProjectileInflict" then
            if aimbool and rageInstaHitEnabled then
                 args[4] = 0/0
                 return old_namecall(self, unpack(args))
            end
        end
        if method == "Raycast" and aimbool and rageInstaHitEnabled and aimtargetpart then
            args[2] = (aimtargetpart.Position - args[1])
            return old_namecall(self, unpack(args))
        end
        return old_namecall(self, unpack(args))
    end)
    local old_index
    old_index = hookmetamethod(game, "__index", function(self, key)
        if rapidFireEnabled and key == "FireRate" and not checkcaller() then
            return rapidFireValue
        end
        return old_index(self, key)
    end)
end
local Window
if MacLib then
    _G.__oblivion_dbg("BOOT: creating Window")
    Window = MacLib:Window({
        Title = "Oblivion (Paid) ",
        Subtitle = "by Oblivion",
        Size = UDim2.fromOffset(868, 650),
        DragStyle = 2,
        ShowUserInfo = true,
        Keybind = Enum.KeyCode.RightControl,
        AcrylicBlur = false,
    })
    _G.__oblivion_dbg("BOOT: Window created", Window ~= nil)
else
    _G.__oblivion_dbg("BOOT: Window skipped (MacLib missing)")
end
do
    local function tagWindow()
        if not Window or not Window.Frame then
            return false
        end
        local sg = Window.Frame:FindFirstAncestorWhichIsA("ScreenGui")
        if not sg then
            return false
        end
        pcall(function()
            sg:SetAttribute("OblivionOwned", true)
        end)
        _G.allvars._rt.windowScreenGui = sg
        return true
    end
    task.defer(function()
        for _ = 1, 80 do
            if tagWindow() then
                _G.__oblivion_dbg("BOOT: Window tagged")
                break
            end
            task.wait(0.05)
        end
    end)
end
do
    if Window then
        local globalSettings = {
            UIBlurToggle = Window:GlobalSetting({
                Name = "UI Transparency",
                Default = false,
                Callback = function(bool)
                    Window:SetAcrylicBlurState(bool)
                end,
            }),
            ShowUserInfo = Window:GlobalSetting({
                Name = "User Info",
                Default = true,
                Callback = function(bool)
                    if typeof(Window.SetUserInfoState) == "function" then
                        Window:SetUserInfoState(bool)
                    elseif typeof(Window.ToggleUserInfo) == "function" then
                        Window:ToggleUserInfo(bool)
                    else
                        pcall(function()
                            if Window.Settings then
                                Window.Settings.ShowUserInfo = bool
                            end
                            if Window.Frame and Window.Frame:FindFirstChild("Bottom") then
                                local bottom = Window.Frame.Bottom
                                for _, child in pairs(bottom:GetChildren()) do
                                    if child:IsA("ImageLabel") or child:IsA("ImageButton") then
                                        child.Visible = bool
                                    elseif child:IsA("TextLabel") or child:IsA("TextBox") or child:IsA("TextButton") then
                                        child.Visible = bool
                                    elseif child:IsA("Frame") and (child.Name:find("User") or child.Name:find("Avatar") or child.Name:find("Profile")) then
                                        child.Visible = bool
                                    end
                                end
                                local bottomLeft = bottom:FindFirstChild("BottomLeft") or bottom:FindFirstChild("Left")
                                if bottomLeft then
                                    bottomLeft.Visible = bool
                                end
                                if not bool then
                                    local allHidden = true
                                    for _, child in pairs(bottom:GetChildren()) do
                                        if child.Visible then
                                            allHidden = false
                                            break
                                        end
                                    end
                                    if allHidden then
                                        bottom.Visible = false
                                    end
                                else
                                    bottom.Visible = true
                                end
                            end
                            local function processDescendants(parent)
                                for _, child in pairs(parent:GetChildren()) do
                                    if (child.Name:find("User") or child.Name:find("Avatar") or
                                        child.Name:find("Profile") or child.Name:find("Name")) and
                                   (child:IsA("Frame") or child:IsA("ImageLabel") or
                                    child:IsA("TextLabel") or child:IsA("ViewportFrame")) then
                                        child.Visible = bool
                                    end
                                    processDescendants(child)
                                end
                            end
                            if Window.Frame then
                                processDescendants(Window.Frame)
                            end
                        end)
                    end
                end,
            }),
            Watermark = Window:GlobalSetting({
                Name = "Watermark",
                Default = true,
                Callback = function(bool)
                    if _G.CustomWatermark then
                        _G.CustomWatermark.Enabled = bool
                    end
                end,
            })
        }
        if _G.allvars and _G.allvars._rt then
            _G.allvars._rt.globalSettings = globalSettings
        end
    end
end
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local SilentAim = {
    Enabled = false,
    TeamCheck = false,
    AimPart = "Head",
    Sensitivity = 0,
    CircleSides = 64,
    CircleColor = Color3.fromRGB(255, 255, 255),
    CircleTransparency = 0,
    CircleRadius = 220,
    CircleFilled = false,
    CircleVisible = false,
    CircleThickness = 0,
    FOVCircle = nil,
    LockedPlayerGUI = nil,
    UsernameLabel = nil,
    TrackerEnabled = false,
    TrackerColor = Color3.fromRGB(255, 255, 255),
    TrackerWidth = 1,
    TrackerTransparency = 1,
    Tracker2D = nil,
    Holding = false,
    CurrentTarget = nil,
    IsAiming = true,
    PredictionEnabled = true,
    PredictionSpeed = 500
}
local ESP = {
    Enabled = false,
    TeamCheck = false,
    MaxDistance = 10000,
    FontSize = 11,
    FadeOut = {
        OnDistance = true,
        OnDeath = false,
        OnLeave = false,
    },
    Drawing = {
        Chams = {
            Enabled = false,
            XRay = true,
            FillRGB = Color3.fromRGB(0, 0, 0),
            Fill_Transparency = 50,
            OutlineRGB = Color3.fromRGB(128, 0, 128),
            Outline_Transparency = 50,
            MaxDistance = 150,
            HideOriginalModels = true,
            VisibleCheck = true,
        },
        Names = {
            Enabled = false,
            RGB = Color3.fromRGB(255, 255, 255),
        },
        InventoryValue = {
             RGB = Color3.fromRGB(100, 255, 100)
        },
        Flags = {
            Enabled = false,
        },
        GazeLine = {
            Enabled = false,
            RGB = Color3.fromRGB(255, 0, 0),
            Thickness = 0.5,
            Length = 10,
        },
        Distances = {
            Enabled = false,
            Position = "Text",
            RGB = Color3.fromRGB(255, 255, 255),
        },
        Weapons = {
            Enabled = false,
            Icon = false,
            WeaponTextRGB = Color3.fromRGB(255, 255, 255),
            Outlined = false,
            Gradient = false,
            GradientRGB1 = Color3.fromRGB(255, 255, 255),
            GradientRGB2 = Color3.fromRGB(119, 120, 255),
            Ammo = false,
        },
        Healthbar = {
            Enabled = false,
            HealthText = true,
            Lerp = false,
            HealthTextRGB = Color3.fromRGB(119, 120, 255),
            Width = 2.5,
            Gradient = true,
            GradientRGB1 = Color3.fromRGB(255, 0, 0),
            GradientRGB2 = Color3.fromRGB(0, 255, 0),
        },
        Boxes = {
            BoxType = "Default",
            Dynamic = false,
            Animate = false,
            RotationSpeed = 300,
            Gradient = true,
            GradientRGB1 = Color3.fromRGB(255, 255, 255),
            GradientRGB2 = Color3.fromRGB(0, 0, 0),
            GradientFill = true,
            GradientFillRGB1 = Color3.fromRGB(255, 255, 255),
            GradientFillRGB2 = Color3.fromRGB(0, 0, 0),
            Image = {
                Enabled = false,
                Image = "rbxassetid://7488932287",
                Preset = "Cat",
                Custom = "",
                Transparency = 0.35,
                Color = Color3.fromRGB(255, 255, 255),
                ScaleType = Enum.ScaleType.Stretch,
            },
            Filled = {
                Enabled = false,
                Transparency = 0.75,
                RGB = Color3.fromRGB(0, 0, 0),
            },
            Full = {
                Enabled = false,
                RGB = Color3.fromRGB(255, 255, 255),
            },
            Corner = {
                Enabled = false,
                RGB = Color3.fromRGB(255, 255, 255),
            },
        },
        Skeleton = {
            Enabled = false,
            Color = Color3.fromRGB(255, 255, 255),
            Thickness = 1
        },
        Arrows = {
            Enabled = false,
            Color = Color3.fromRGB(255, 0, 0),
            Radius = 300,
            Size = 20,
            Outline = true,
            OutlineColor = Color3.fromRGB(0, 0, 0)
        }
    },
    Connections = {
        RunService = RunService,
    },
    Fonts = {},
    ShowAIBots = false,
    ShowUnloadedPlayers = false,
    GazeLines = {},
    Skeletons = {},
    ArrowCache = {},
    Options = {
        TeamcheckRGB = Color3.fromRGB(0, 255, 0),
        FriendcheckRGB = Color3.fromRGB(0, 255, 0),
        HighlightRGB = Color3.fromRGB(255, 0, 0),
        VisibleCheck = true,
    }
}
ESP.SetBoxImage = function(image)
    local cfg = ESP.Drawing and ESP.Drawing.Boxes and ESP.Drawing.Boxes.Image
    if not cfg then
        return
    end
    if type(image) == "number" then
        image = "rbxassetid://" .. tostring(image)
    end
    if type(image) ~= "string" then
        return
    end
    image = tostring(image)
    if image ~= "" and not string.find(image, "://", 1, true) then
        if string.match(image, "^%d+$") then
            image = "rbxassetid://" .. image
        end
    end
    if ESP and ESP._ui and ESP._ui._normalizeDecalAsset then
        image = ESP._ui._normalizeDecalAsset(image)
    end
    cfg.Image = image
    if ESP and ESP._ui and ESP._ui._extractAssetId then
        local id = ESP._ui._extractAssetId(image)
        if id and ESP._ui._resolveDecalToTextureAsync then
            ESP._ui._resolveDecalToTextureAsync(id)
        end
    end
end
_G.SetESPBoxImage = ESP.SetBoxImage
local _chamsEnv = _G
if type(_chamsEnv) == "table" then
    if _chamsEnv.CurrentChamsType == nil then
        _chamsEnv.CurrentChamsType = "Default"
    end
    if _chamsEnv.CurrentHandChamsType == nil then
        _chamsEnv.CurrentHandChamsType = "material"
    end
end
if type(_G) == "table" then
    if _G.CurrentChamsType == nil then
        _G.CurrentChamsType = (type(_chamsEnv) == "table" and _chamsEnv.CurrentChamsType) or "Default"
    end
    if _G.CurrentHandChamsType == nil then
        _G.CurrentHandChamsType = (type(_chamsEnv) == "table" and _chamsEnv.CurrentHandChamsType) or "material"
    end
end
local CurrentChamsType = (type(_chamsEnv) == "table" and _chamsEnv.CurrentChamsType) or (type(_G) == "table" and _G.CurrentChamsType) or "Default"
local CurrentHandChamsType = (type(_chamsEnv) == "table" and _chamsEnv.CurrentHandChamsType) or (type(_G) == "table" and _G.CurrentHandChamsType) or "material"
local ChamsToggleState = ESP.Drawing.Chams.Enabled
local function StopBeastChams()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local CoreGui = game:GetService("CoreGui")
    local LocalPlayer = Players.LocalPlayer
    local guiName = (ESP and ESP._BeastChamsGuiName) or "BeastChams_V10_Protected"
    local renderStepName = (ESP and ESP._BeastChamsRenderStepName) or ("BeastChams_Update_" .. tostring(guiName)):gsub("[^%w_]", "_")
    local hiddenParts = ESP and ESP._BeastChamsHiddenParts
    if hiddenParts then
        for part, oldLtm in pairs(hiddenParts) do
            if part and part.Parent and part:IsA("BasePart") then
                pcall(function()
                    part.LocalTransparencyModifier = oldLtm or 0
                end)
            end
            hiddenParts[part] = nil
        end
    end
    if ESP then
        ESP._BeastChams_SetHidden = nil
    end
    pcall(function()
        RunService:UnbindFromRenderStep(renderStepName)
    end)
    local pg = LocalPlayer and LocalPlayer:FindFirstChild("PlayerGui")
    if pg then
        local g1 = pg:FindFirstChild(guiName)
        if g1 then
            pcall(function()
                g1:Destroy()
            end)
        end
    end
    local g2 = CoreGui:FindFirstChild(guiName)
    if g2 then
        pcall(function()
            g2:Destroy()
        end)
    end
    if _G.BeastChams_DisablePlayers then
        pcall(_G.BeastChams_DisablePlayers)
    end
    if _G.BeastChams_Stop then
        pcall(_G.BeastChams_Stop)
    end
    if _G.Chams_Stop then
        pcall(_G.Chams_Stop)
    end
end
do
    local InsertService = game:GetService("InsertService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local STARS_ROLL_DEG = 45
    local GALAXY_ROLL_DEG = -45
    local GLASS_TRANSPARENCY = 0.93
    local GLASS_COLOR = Color3.new(1, 1, 1)
    local HANDS_GLASS_TRANSPARENCY = 0.99
    local USE_HEAD_OVERLAY = true
    local HEAD_OVERLAY_SCALE = 1.02
    local HEAD_TEMPLATE_PATH = {"CharacterMaskClonables", "HeadNormal"}
    local PLANE_DISTANCE = 5
    local COSMOS_SCALE_MULT = 2.2
    local COSMOS_SCALE_MIN = 1.2
    local COSMOS_SCALE_MAX = 6
    local STARS_ANIM_STOP_DIST_SQ = 175 * 175
    local COSMOS_ANIM_STOP_DIST_SQ = 225 * 225
    local BASE_ZOFFSET = {-0.002, -0.001, 0.001, 0.002}
    local REMOVE_VISUAL_CLASSES = {
        Decal = true, Texture = true, SurfaceAppearance = true,
        SurfaceGui = true, BillboardGui = true,
        ParticleEmitter = true, Trail = true, Beam = true,
        Fire = true, Smoke = true, Sparkles = true,
        PointLight = true, SpotLight = true, SurfaceLight = true,
        WrapTarget = true, WrapLayer = true,
        FaceControls = true,
    }
    local galaxyMaskTemplate
    local tracked = {}
    local playerAddedConn
    local playerRemovingConn
    local stepName = "GalaxyMask_Chams"
    local galaxyMaskGui
    local viewportsFolder
    local handsStepName = "GalaxyMask_Hands"
    local handsMaskGui
    local handsViewportsFolder
    local handsState
    local function getOrCreate(parent, className, name)
        local obj = parent:FindFirstChild(name)
        if obj and obj.ClassName == className then
            return obj
        end
        obj = Instance.new(className)
        obj.Name = name
        obj.Parent = parent
        return obj
    end
    local function relPath(root, inst)
        local parts = {}
        local cur = inst
        while cur and cur ~= root do
            insert(parts, 1, cur.Name)
            cur = cur.Parent
        end
        return table.concat(parts, "/")
    end
    local function buildBasePartMap(root)
        local map = {}
        for _, d in ipairs(root:GetDescendants()) do
            if d:IsA("BasePart") then
                local k = relPath(root, d)
                local list = map[k]
                if not list then
                    list = {}
                    map[k] = list
                end
                insert(list, d)
            end
        end
        return map
    end
    local function ensureSurfaceAppearance(meshPart, colorMap)
        local sa = meshPart:FindFirstChildOfClass("SurfaceAppearance")
        if not sa then
            sa = Instance.new("SurfaceAppearance")
            sa.Name = "SurfaceAppearance"
            sa.Parent = meshPart
        end
        sa.AlphaMode = Enum.AlphaMode.Transparency
        sa.ColorMap = colorMap
        sa.NormalMap = ""
        sa.MetalnessMap = ""
        sa.RoughnessMap = ""
    end
    local function createMeshPartFromId(meshId)
        local ok, mp = pcall(function()
            return InsertService:CreateMeshPartAsync(meshId, Enum.CollisionFidelity.Default, Enum.RenderFidelity.Precise)
        end)
        if ok and mp and mp:IsA("MeshPart") then
            return mp
        end
        return nil
    end
    local function scrubVisuals(obj)
        local stack = {obj}
        while #stack > 0 do
            local cur = stack[#stack]
            stack[#stack] = nil
            if cur:IsA("MeshPart") then
                pcall(function()
                    cur.TextureID = ""
                end)
            end
            if cur:IsA("DataModelMesh") then
                pcall(function()
                    cur.TextureId = ""
                end)
            end
            for _, ch in ipairs(cur:GetChildren()) do
                if REMOVE_VISUAL_CLASSES[ch.ClassName] then
                    ch:Destroy()
                else
                    stack[#stack + 1] = ch
                end
            end
        end
    end
    local function scrubScripts(obj)
        for _, d in ipairs(obj:GetDescendants()) do
            if d:IsA("BaseScript") then
                d:Destroy()
            end
        end
    end
    local function scrubCloneInternals(obj)
        for _, d in ipairs(obj:GetDescendants()) do
            if d:IsA("Humanoid")
                or d:IsA("Animator")
                or d:IsA("Motor6D")
                or d:IsA("Weld")
                or d:IsA("WeldConstraint")
                or d:IsA("Motor")
                or d:IsA("Snap") then
                d:Destroy()
            end
        end
    end
    local function findIn(parent, path)
        local cur = parent
        for _, name in ipairs(path) do
            if not cur then
                return nil
            end
            cur = cur:FindFirstChild(name)
        end
        return cur
    end
    local function createPlayerViewport(p)
        local vp = Instance.new("ViewportFrame")
        vp.Name = "Character2Viewport_" .. p.UserId
        vp.Size = UDim2.new(1, 0, 1, 0)
        vp.Position = UDim2.new(0, 0, 0, 0)
        vp.AnchorPoint = Vector2.new(0, 0)
        vp.ZIndex = 1
        vp.Visible = true
        vp.BackgroundTransparency = 1
        vp.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        vp.BorderSizePixel = 0
        vp.Ambient = Color3.fromRGB(255, 255, 255)
        vp.LightColor = Color3.fromRGB(0, 0, 0)
        vp.LightDirection = Vector3.new(-1, -1, -1)
        vp.ImageColor3 = Color3.fromRGB(255, 255, 255)
        vp.ImageTransparency = 0
        vp.Parent = viewportsFolder
        local cam = Instance.new("Camera")
        cam.Name = "ViewportCamera"
        cam.Parent = vp
        vp.CurrentCamera = cam
        local wm = Instance.new("WorldModel")
        wm.Name = "WorldModel"
        wm.Parent = vp
        return vp, wm, cam
    end
    local function setRoll(part, pivotCF, rollDeg)
        if not part then
            return
        end
        local pos = part.Position
        part.CFrame = CFrame.lookAt(pos, pos + pivotCF.LookVector, pivotCF.UpVector) * CFrame.Angles(0, 0, math.rad(rollDeg))
    end
    local function makeGalaxyMaskTemplate()
        local galaxyMask = Instance.new("Model")
        galaxyMask.Name = "GalaxyMaskTemplate"
        local function makePlane(planeName, meshId, colorMap, size, cframe)
            local mp = createMeshPartFromId(meshId)
            if not mp then
                local p = Instance.new("Part")
                p.Name = planeName
                p.Size = size
                p.CFrame = cframe
                p.Anchored = true
                p.CanCollide = false
                p.CanTouch = false
                p.CanQuery = false
                p.CastShadow = false
                p.Material = Enum.Material.Plastic
                p.Color = Color3.fromRGB(163, 162, 165)
                p.Transparency = 0
                p.Parent = galaxyMask
                return p
            end
            mp.Name = planeName
            mp.Anchored = true
            mp.CanCollide = false
            mp.CanTouch = false
            mp.CanQuery = false
            mp.CastShadow = false
            mp.Material = Enum.Material.Plastic
            mp.Color = Color3.fromRGB(163, 162, 165)
            mp.Transparency = 0
            mp.TextureID = ""
            mp.DoubleSided = false
            mp.RenderFidelity = Enum.RenderFidelity.Precise
            mp.CollisionFidelity = Enum.CollisionFidelity.Default
            mp.Size = size
            mp.CFrame = cframe
            ensureSurfaceAppearance(mp, colorMap)
            mp.Parent = galaxyMask
            return mp
        end
        makePlane("Stars1", "rbxassetid://17754155715", "rbxassetid://17745916264", Vector3.new(16, 34, 0.001),
            CFrame.new(-4.24, 16.847549, 14.944044, 0.55557, -0.83147, 0, 0.83147, 0.55557, 0, 0, 0, 1))
        makePlane("Stars2", "rbxassetid://17754156768", "rbxassetid://17745916264", Vector3.new(22, 48, 0.001),
            CFrame.new(-4.24, 16.847549, 14.947044, 0.55557, -0.83147, 0, 0.83147, 0.55557, 0, 0, 0, 1))
        makePlane("Galaxy2", "rbxassetid://17754154181", "rbxassetid://17746794246", Vector3.new(18, 18, 0.001),
            CFrame.new(-4.24, 16.847549, 14.948044, -0.55557, 0.83147, 0, -0.83147, -0.55557, 0, 0, 0, 1))
        makePlane("Galaxy1", "rbxassetid://17754152946", "rbxassetid://17746433819", Vector3.new(12, 12, 0.001),
            CFrame.new(-4.24, 16.847549, 14.945044, 0.92388, 0.382683, 0, -0.382683, 0.92388, 0, 0, 0, 1))
        return galaxyMask
    end
    local function buildGalaxyMaskModel(parent, name)
        if not galaxyMaskTemplate then
            galaxyMaskTemplate = makeGalaxyMaskTemplate()
        end
        local galaxyMask = galaxyMaskTemplate:Clone()
        galaxyMask.Name = name
        galaxyMask.Parent = parent
        local function findPlane(planeName)
            local inst = galaxyMask:FindFirstChild(planeName) or galaxyMask:FindFirstChild(planeName .. "_PLACEHOLDER")
            if inst and inst:IsA("BasePart") then
                return inst
            end
            local p = Instance.new("Part")
            p.Name = planeName
            p.Size = Vector3.new(1, 1, 0.001)
            p.Anchored = true
            p.CanCollide = false
            p.CanTouch = false
            p.CanQuery = false
            p.CastShadow = false
            p.Material = Enum.Material.Plastic
            p.Color = Color3.fromRGB(163, 162, 165)
            p.Transparency = 0
            p.Parent = galaxyMask
            return p
        end
        local stars1 = findPlane("Stars1")
        local galaxy1 = findPlane("Galaxy1")
        local stars2 = findPlane("Stars2")
        local galaxy2 = findPlane("Galaxy2")
        return galaxyMask, {stars1, galaxy1, stars2, galaxy2}
    end
    local function LoopPlanes(galaxyMask, planes, zOffset)
        local origin = galaxyMask.WorldPivot.Position
        for i, plane in ipairs(planes) do
            if not (plane and plane.Parent and plane:IsA("BasePart")) then
                continue
            end
            local size = plane.Size / 2
            local localOffset = plane.CFrame:VectorToObjectSpace(plane.Position - origin)
            local x = (localOffset.X + size.X / 2) % size.X - size.X / 2
            local y = (localOffset.Y + size.Y / 2) % size.Y - size.Y / 2
            local worldOffset = plane.CFrame:VectorToWorldSpace(Vector3.new(x, y, zOffset[i]))
            plane.Position = origin + worldOffset
        end
    end
    local function isInvisibleOriginalPart(p)
        if p.Transparency >= 0.95 then
            return true
        end
        local n = string.lower(p.Name)
        if string.find(n, "hitbox", 1, true) then
            return true
        end
        if string.find(n, "hurtbox", 1, true) then
            return true
        end
        if string.find(n, "collider", 1, true) then
            return true
        end
        return false
    end
    local function buildHiddenCloneParts(origParts, cloneParts)
        local hidden = {}
        for path, cpList in pairs(cloneParts) do
            local opList = origParts[path]
            if opList then
                local n = math.min(#opList, #cpList)
                for i = 1, n do
                    if isInvisibleOriginalPart(opList[i]) then
                        hidden[cpList[i]] = true
                    end
                end
            end
        end
        return hidden
    end
    local function applyGlassToClone(newChar, hiddenCloneParts, glassColor, glassTransparency)
        local gColor = (typeof(glassColor) == "Color3" and glassColor) or GLASS_COLOR
        local gTransparency = (typeof(glassTransparency) == "number" and math.clamp(glassTransparency, 0, 1)) or GLASS_TRANSPARENCY
        for _, d in ipairs(newChar:GetDescendants()) do
            if d:IsA("Clothing") or d:IsA("ShirtGraphic") then
                d:Destroy()
            end
        end
        for _, d in ipairs(newChar:GetDescendants()) do
            if d:IsA("BasePart") then
                d.Anchored = true
                d.CanCollide = false
                d.CanTouch = false
                d.CanQuery = false
                d.CastShadow = false
                if d.Name == "HumanoidRootPart" then
                    d.Transparency = 1
                elseif hiddenCloneParts[d] or d.Transparency >= 0.95 then
                    d.Transparency = 1
                else
                    d.Material = Enum.Material.Glass
                    d.Color = gColor
                    d.Transparency = gTransparency
                    d.Reflectance = 0
                end
                scrubVisuals(d)
                if d:IsA("MeshPart") then
                    d.TextureID = ""
                end
            end
        end
    end
    local function rebuildHeadOverlay(state)
        if state.headOverlay then
            state.headOverlay:Destroy()
            state.headOverlay = nil
        end
        if not USE_HEAD_OVERLAY then
            return
        end
        if not state.cloneModel then
            return
        end
        if not state.origHead then
            return
        end
        local template = findIn(ReplicatedStorage, HEAD_TEMPLATE_PATH)
        if not (template and template:IsA("MeshPart")) then
            return
        end
        local mp = template:Clone()
        mp.Name = "ChamHeadOverlay"
        mp.Anchored = true
        mp.CanCollide = false
        mp.CanTouch = false
        mp.CanQuery = false
        mp.CastShadow = false
        mp.Material = Enum.Material.Glass
        mp.Color = GLASS_COLOR
        mp.Transparency = GLASS_TRANSPARENCY
        mp.Reflectance = 0
        mp.TextureID = ""
        scrubVisuals(mp)
        mp.Parent = state.cloneModel
        state.headOverlay = mp
    end
    local function disconnectConns(list)
        for _, c in ipairs(list) do
            pcall(function()
                c:Disconnect()
            end)
        end
        table.clear(list)
    end
    local function clearChams(state)
        if state.worldModel and state.worldModel.Parent then
            for _, ch in ipairs(state.worldModel:GetChildren()) do
                ch:Destroy()
            end
        end
        state.cloneModel = nil
        state.headOverlay = nil
        state.galaxyMask = nil
        state.lastScale = 0
        table.clear(state.planes)
        table.clear(state.origParts)
        table.clear(state.cloneParts)
        table.clear(state.syncPairs)
    end
    local function countBaseParts(m)
        local n = 0
        for _, d in ipairs(m:GetDescendants()) do
            if d:IsA("BasePart") then
                n = n + 1
            end
        end
        return n
    end
    local function isCharacterReady(char)
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hum then
            return false
        end
        if not char:FindFirstChild("HumanoidRootPart", true) then
            return false
        end
        if not char:FindFirstChild("Head", true) then
            return false
        end
        local minParts = hum.RigType == Enum.HumanoidRigType.R15 and 15 or 6
        return countBaseParts(char) >= minParts
    end
    local function destroyState(p)
        local state = tracked[p]
        if not state then
            return
        end
        disconnectConns(state.connsChar)
        disconnectConns(state.connsPersistent)
        clearChams(state)
        if state.viewport then
            state.viewport:Destroy()
        end
        tracked[p] = nil
    end
    local function galaxySelfEnabled()
        local ct = tostring(CurrentChamsType or ""):lower():gsub("%s+", "")
        if ct ~= "galaxy" then
            return false
        end
        if ChamsToggleState ~= true then
            return false
        end
        return allvars and allvars.camthirdp and allvars.thirdPersonSelfChams == true
    end
    local function ensureState(p, localPlayer)
        if p.UserId == localPlayer.UserId and not galaxySelfEnabled() then
            return nil
        end
        local existing = tracked[p]
        if existing then
            return existing
        end
        local vp, wm, vcam = createPlayerViewport(p)
        local state = {
            player = p,
            viewport = vp,
            worldModel = wm,
            vpCamera = vcam,
            origChar = nil,
            cloneModel = nil,
            origParts = {},
            cloneParts = {},
            syncPairs = {},
            origHead = nil,
            cloneHead = nil,
            headOverlay = nil,
            galaxyMask = nil,
            planes = {},
            zOffset = BASE_ZOFFSET,
            needsRebuild = true,
            lastRebuild = 0,
            lastScale = 0,
            cachedScale = 0,
            cachedScaleTime = 0,
            connsPersistent = {},
            connsChar = {},
        }
        tracked[p] = state
        table.insert(state.connsPersistent, p.CharacterAdded:Connect(function()
            state.needsRebuild = true
        end))
        table.insert(state.connsPersistent, p.CharacterRemoving:Connect(function()
            clearChams(state)
            state.origChar = nil
        end))
        return state
    end
    local function rebuildForState(state)
        local now = os.clock()
        if now - state.lastRebuild < 0.25 then
            return
        end
        state.lastRebuild = now
        clearChams(state)
        disconnectConns(state.connsChar)
        local p = state.player
        local char = p.Character
        if not char then
            state.origChar = nil
            return
        end
        if not isCharacterReady(char) then
            state.origChar = char
            state.needsRebuild = true
            table.insert(state.connsChar, char.DescendantAdded:Connect(function(d)
                if d:IsA("BasePart") then
                    state.needsRebuild = true
                end
            end))
            return
        end
        state.origChar = char
        char.Archivable = true
        table.insert(state.connsChar, char.DescendantAdded:Connect(function(d)
            if d:IsA("BasePart") then
                state.needsRebuild = true
            end
        end))
        table.insert(state.connsChar, char.DescendantRemoving:Connect(function(d)
            if d:IsA("BasePart") then
                state.needsRebuild = true
            end
        end))
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            table.insert(state.connsChar, hum.Died:Connect(function()
                clearChams(state)
                state.origChar = nil
            end))
        end
        local newChar = char:Clone()
        newChar.Name = p.Name
        scrubScripts(newChar)
        scrubCloneInternals(newChar)
        newChar.Parent = state.worldModel
        state.cloneModel = newChar
        state.origHead = char:FindFirstChild("Head", true)
        state.cloneHead = newChar:FindFirstChild("Head", true)
        state.origParts = buildBasePartMap(char)
        state.cloneParts = buildBasePartMap(newChar)
        local hiddenCloneParts = buildHiddenCloneParts(state.origParts, state.cloneParts)
        applyGlassToClone(newChar, hiddenCloneParts)
        if USE_HEAD_OVERLAY and state.cloneHead and state.cloneHead:IsA("BasePart") then
            state.cloneHead.Transparency = 1
            scrubVisuals(state.cloneHead)
            if state.cloneHead:IsA("MeshPart") then
                state.cloneHead.TextureID = ""
            end
        end
        rebuildHeadOverlay(state)
        local syncPairs = {}
        for path, cpList in pairs(state.cloneParts) do
            local opList = state.origParts[path]
            if opList then
                local n = math.min(#opList, #cpList)
                for i = 1, n do
                    insert(syncPairs, {opList[i], cpList[i]})
                end
            end
        end
        state.syncPairs = syncPairs
        local mask, newPlanes = buildGalaxyMaskModel(state.worldModel, "GalaxyMask_" .. p.Name)
        state.galaxyMask = mask
        state.planes = newPlanes
        state.needsRebuild = false
        state.cachedScale = 0
        state.cachedScaleTime = 0
    end
    ESP._GalaxyChams_Start = function()
        local localPlayer = localplayer or Players.LocalPlayer
        if not localPlayer then
            return
        end
        if galaxyMaskGui and galaxyMaskGui.Parent then
            galaxyMaskGui:Destroy()
        end
        local pg = localPlayer:FindFirstChild("PlayerGui")
        if not pg then
            return
        end
        galaxyMaskGui = getOrCreate(pg, "ScreenGui", "MaskGui")
        galaxyMaskGui.ResetOnSpawn = false
        galaxyMaskGui.IgnoreGuiInset = true
        galaxyMaskGui.DisplayOrder = -100
        galaxyMaskGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        viewportsFolder = getOrCreate(galaxyMaskGui, "Folder", "Viewports")
        for _, ch in ipairs(viewportsFolder:GetChildren()) do
            ch:Destroy()
        end
        for p, state in pairs(tracked) do
            destroyState(p)
        end
        tracked = {}
        for _, p in ipairs(Players:GetPlayers()) do
            local state = ensureState(p, localPlayer)
            if state then
                state.needsRebuild = true
                rebuildForState(state)
            end
        end
        if playerAddedConn then
            playerAddedConn:Disconnect()
        end
        if playerRemovingConn then
            playerRemovingConn:Disconnect()
        end
        playerAddedConn = Players.PlayerAdded:Connect(function(p)
            if p.UserId == localPlayer.UserId then
                return
            end
            local state = ensureState(p, localPlayer)
            if not state then
                return
            end
            state.needsRebuild = true
        end)
        playerRemovingConn = Players.PlayerRemoving:Connect(function(p)
            destroyState(p)
        end)
        RunService:UnbindFromRenderStep(stepName)
        RunService:BindToRenderStep(stepName, Enum.RenderPriority.Camera.Value + 1, function(dt)
            if not galaxyMaskGui or not galaxyMaskGui.Parent then
                return
            end
            local cam = Workspace.CurrentCamera
            if not cam then
                return
            end
            local camPos = cam.CFrame.Position
            local sortable = {}
            local selfOn = galaxySelfEnabled()
            if selfOn and not tracked[localPlayer] then
                local state = ensureState(localPlayer, localPlayer)
                if state then
                    state.needsRebuild = true
                    rebuildForState(state)
                end
            end
            for p, state in pairs(tracked) do
                if p.UserId == localPlayer.UserId and not selfOn then
                    destroyState(p)
                else
                    if state.vpCamera and state.vpCamera.Parent then
                        state.vpCamera.CFrame = cam.CFrame
                        state.vpCamera.Focus = cam.Focus
                        state.vpCamera.FieldOfView = cam.FieldOfView
                    end
                    local char = p.Character
                    if not char then
                        clearChams(state)
                        state.origChar = nil
                    else
                        if state.origChar ~= char then
                            state.origChar = char
                            state.needsRebuild = true
                        end
                        if state.needsRebuild or not state.cloneModel or not state.cloneModel.Parent then
                            rebuildForState(state)
                        end
                        if state.cloneModel and state.galaxyMask then
                            state.origHead = state.origHead and state.origHead.Parent and state.origHead or (state.origChar and state.origChar:FindFirstChild("Head", true))
                            state.cloneHead = state.cloneHead and state.cloneHead.Parent and state.cloneHead or (state.cloneModel and state.cloneModel:FindFirstChild("Head", true))
                            for i = 1, #state.syncPairs do
                                local pair = state.syncPairs[i]
                                local op = pair[1]
                                local cp = pair[2]
                                if op.Parent and cp.Parent then
                                    cp.CFrame = op.CFrame
                                else
                                    state.needsRebuild = true
                                    break
                                end
                            end
                            if USE_HEAD_OVERLAY and state.headOverlay and state.origHead and state.origHead:IsA("BasePart") then
                                state.headOverlay.CFrame = state.origHead.CFrame
                                state.headOverlay.Size = state.origHead.Size * HEAD_OVERLAY_SCALE
                            end
                            local targetPos
                            if state.origHead and state.origHead:IsA("BasePart") then
                                targetPos = state.origHead.Position
                            else
                                targetPos = state.origChar:GetPivot().Position
                            end
                            local dirVec = targetPos - camPos
                            local distSq = dirVec:Dot(dirVec)
                            local dir
                            if distSq > 1e-6 then
                                dir = dirVec / math.sqrt(distSq)
                            else
                                dir = cam.CFrame.LookVector
                            end
                            local planeDistance = PLANE_DISTANCE
                            local now = os.clock()
                            local scale = state.cachedScale
                            if not scale or scale == 0 or (now - (state.cachedScaleTime or 0)) > 0.5 then
                                local ext = state.origChar:GetExtentsSize()
                                local maxDim = math.max(ext.X, ext.Y, ext.Z)
                                scale = math.clamp((maxDim / 5) * COSMOS_SCALE_MULT, COSMOS_SCALE_MIN, COSMOS_SCALE_MAX)
                                state.cachedScale = scale
                                state.cachedScaleTime = now
                            end
                            state.galaxyMask:PivotTo(CFrame.new(targetPos + dir * planeDistance, camPos))
                            if math.abs(scale - state.lastScale) > 1e-3 then
                                state.galaxyMask:ScaleTo(scale)
                                state.lastScale = scale
                            end
                            local s = scale
                            local pivotCF = state.galaxyMask:GetPivot()
                            local stars1 = state.planes[1]
                            local galaxy1 = state.planes[2]
                            local stars2 = state.planes[3]
                            local galaxy2 = state.planes[4]
                            setRoll(stars1, pivotCF, STARS_ROLL_DEG)
                            setRoll(stars2, pivotCF, STARS_ROLL_DEG)
                            setRoll(galaxy1, pivotCF, GALAXY_ROLL_DEG)
                            setRoll(galaxy2, pivotCF, GALAXY_ROLL_DEG)
                            if distSq <= STARS_ANIM_STOP_DIST_SQ then
                                if stars1 then
                                    stars1.Position += stars1.CFrame.UpVector * dt * s * 0.4
                                end
                                if stars2 then
                                    stars2.Position += stars2.CFrame.UpVector * dt * s * 0.2
                                end
                            end
                            if distSq <= COSMOS_ANIM_STOP_DIST_SQ then
                                if galaxy1 then
                                    galaxy1.Position -= galaxy1.CFrame.UpVector * dt * s * 0.08
                                end
                                if galaxy2 then
                                    galaxy2.Position -= galaxy2.CFrame.UpVector * dt * s * 0.05
                                end
                            end
                            LoopPlanes(state.galaxyMask, state.planes, state.zOffset)
                            insert(sortable, {state = state, distanceSq = distSq})
                        end
                    end
                end
            end
            table.sort(sortable, function(a, b)
                return a.distanceSq > b.distanceSq
            end)
            for i, item in ipairs(sortable) do
                local state = item.state
                if state.viewport and state.viewport.Parent then
                    state.viewport.ZIndex = i
                end
            end
        end)
    end
    ESP._GalaxyChams_Stop = function()
        RunService:UnbindFromRenderStep(stepName)
        if playerAddedConn then
            playerAddedConn:Disconnect()
            playerAddedConn = nil
        end
        if playerRemovingConn then
            playerRemovingConn:Disconnect()
            playerRemovingConn = nil
        end
        for p, state in pairs(tracked) do
            destroyState(p)
        end
        tracked = {}
        if galaxyMaskGui and galaxyMaskGui.Parent then
            galaxyMaskGui:Destroy()
        end
        galaxyMaskGui = nil
        viewportsFolder = nil
    end
    ESP._GalaxyHands_Start = function()
        local localPlayer = Players.LocalPlayer
        if not localPlayer then
            return
        end
        local pg = localPlayer:FindFirstChild("PlayerGui")
        if not pg then
            return
        end
        if handsState and handsState.running and handsMaskGui and handsMaskGui.Parent then
            return
        end
        RunService:UnbindFromRenderStep(handsStepName)
        if handsMaskGui and handsMaskGui.Parent then
            handsMaskGui:Destroy()
        end
        handsMaskGui = getOrCreate(pg, "ScreenGui", "HandsMaskGui")
        handsMaskGui.ResetOnSpawn = false
        handsMaskGui.IgnoreGuiInset = true
        handsMaskGui.DisplayOrder = -100
        handsMaskGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        handsViewportsFolder = getOrCreate(handsMaskGui, "Folder", "Viewports")
        for _, ch in ipairs(handsViewportsFolder:GetChildren()) do
            ch:Destroy()
        end
        local vp = Instance.new("ViewportFrame")
        vp.Name = "HandsViewport"
        vp.Size = UDim2.new(1, 0, 1, 0)
        vp.Position = UDim2.new(0, 0, 0, 0)
        vp.AnchorPoint = Vector2.new(0, 0)
        vp.ZIndex = 1
        vp.Visible = true
        vp.BackgroundTransparency = 1
        vp.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        vp.BorderSizePixel = 0
        vp.Ambient = Color3.fromRGB(255, 255, 255)
        vp.LightColor = Color3.fromRGB(0, 0, 0)
        vp.LightDirection = Vector3.new(-1, -1, -1)
        vp.ImageColor3 = Color3.fromRGB(255, 255, 255)
        vp.ImageTransparency = 0
        vp.Parent = handsViewportsFolder
        local vcam = Instance.new("Camera")
        vcam.Name = "ViewportCamera"
        vcam.Parent = vp
        vp.CurrentCamera = vcam
        local wm = Instance.new("WorldModel")
        wm.Name = "WorldModel"
        wm.Parent = vp
        handsState = {
            running = true,
            viewport = vp,
            worldModel = wm,
            vpCamera = vcam,
            origModel = nil,
            cloneModel = nil,
            origParts = {},
            cloneParts = {},
            syncPairs = {},
            galaxyMask = nil,
            planes = {},
            zOffset = BASE_ZOFFSET,
            needsRebuild = true,
            lastRebuild = 0,
            lastScale = 0,
            cachedScale = 0,
            cachedScaleTime = 0,
            lastVMCheck = 0,
        }
        RunService:BindToRenderStep(handsStepName, Enum.RenderPriority.Camera.Value + 2, function(dt)
            if not handsState or not handsState.running then
                return
            end
            if not handsMaskGui or not handsMaskGui.Parent then
                return
            end
            local cam = Workspace.CurrentCamera
            if not cam then
                return
            end
            local vpc = handsState.vpCamera
            if vpc and vpc.Parent then
                vpc.CFrame = cam.CFrame
                vpc.Focus = cam.Focus
                vpc.FieldOfView = cam.FieldOfView
            end
            local now = os.clock()
            local viewModel = handsState.origModel
            if not viewModel or not viewModel.Parent then
                if not handsState.lastVMCheck or (now - handsState.lastVMCheck) > 0.5 then
                    handsState.lastVMCheck = now
                    viewModel = nil
                    for _, child in ipairs(cam:GetChildren()) do
                        if child and child:IsA("Model") then
                            local n = child.Name:lower()
                            if n:find("viewmodel", 1, true)
                                or n:find("arms", 1, true)
                                or n:find("hands", 1, true)
                                or n:find("weapon", 1, true)
                                or n:find("gun", 1, true)
                                or n:find("knife", 1, true)
                                or n:find("tool", 1, true) then
                                viewModel = child
                                break
                            end
                        end
                    end
                    handsState.origModel = viewModel
                    handsState.needsRebuild = true
                else
                    viewModel = nil
                end
            end
            if not viewModel then
                clearChams(handsState)
                handsState.cloneModel = nil
                handsState.galaxyMask = nil
                handsState.needsRebuild = true
                return
            end
            if now - (handsState.lastRebuild or 0) < 0.15 then
                if handsState.needsRebuild then
                    return
                end
            end
            if handsState.needsRebuild or not handsState.cloneModel or not handsState.cloneModel.Parent then
                handsState.lastRebuild = now
                clearChams(handsState)
                viewModel.Archivable = true
                local newModel = viewModel:Clone()
                newModel.Name = "HandsViewModel"
                scrubScripts(newModel)
                scrubCloneInternals(newModel)
                newModel.Parent = handsState.worldModel
                handsState.cloneModel = newModel
                handsState.origParts = buildBasePartMap(viewModel)
                handsState.cloneParts = buildBasePartMap(newModel)
                local hiddenCloneParts = buildHiddenCloneParts(handsState.origParts, handsState.cloneParts)
                applyGlassToClone(newModel, hiddenCloneParts, GLASS_COLOR, HANDS_GLASS_TRANSPARENCY)
                local syncPairs = {}
                for path, cpList in pairs(handsState.cloneParts) do
                    local opList = handsState.origParts[path]
                    if opList then
                        local n = math.min(#opList, #cpList)
                        for i = 1, n do
                            insert(syncPairs, {opList[i], cpList[i]})
                        end
                    end
                end
                handsState.syncPairs = syncPairs
                local mask, newPlanes = buildGalaxyMaskModel(handsState.worldModel, "GalaxyMask_Hands")
                handsState.galaxyMask = mask
                handsState.planes = newPlanes
                local fog2 = handsState.planes and handsState.planes[4]
                if fog2 then
                    pcall(function()
                        fog2:Destroy()
                    end)
                    handsState.planes[4] = nil
                end
                handsState.needsRebuild = false
                handsState.cachedScale = 0
                handsState.cachedScaleTime = 0
                handsState.lastScale = 0
            end
            for i = 1, #handsState.syncPairs do
                local pair = handsState.syncPairs[i]
                local op = pair[1]
                local cp = pair[2]
                if op.Parent and cp.Parent then
                    cp.CFrame = op.CFrame
                else
                    handsState.needsRebuild = true
                    break
                end
            end
            if not (handsState.galaxyMask and handsState.galaxyMask.Parent) then
                handsState.needsRebuild = true
                return
            end
            local camPos = cam.CFrame.Position
            local focusPos = cam.Focus.Position
            handsState.galaxyMask:PivotTo(CFrame.new(
                focusPos + cam.CFrame.LookVector * (PLANE_DISTANCE or 5),
                camPos
            ))
            local distance = (focusPos - camPos).Magnitude
            local scale = math.max((distance + 6) / 2, 0.01)
            if math.abs(scale - (handsState.lastScale or 0)) > 1e-3 then
                handsState.galaxyMask:ScaleTo(scale)
                handsState.lastScale = scale
            end
            local s = scale
            local pivotCF = handsState.galaxyMask:GetPivot()
            local stars1 = handsState.planes[1]
            local galaxy1 = handsState.planes[2]
            local stars2 = handsState.planes[3]
            local galaxy2 = handsState.planes[4]
            setRoll(stars1, pivotCF, STARS_ROLL_DEG)
            setRoll(stars2, pivotCF, STARS_ROLL_DEG)
            setRoll(galaxy1, pivotCF, GALAXY_ROLL_DEG)
            setRoll(galaxy2, pivotCF, GALAXY_ROLL_DEG)
            local starsDir = (stars1 and stars1.CFrame.UpVector) or (stars2 and stars2.CFrame.UpVector) or pivotCF.UpVector
            if stars1 then stars1.Position += starsDir * dt * s * 0.4 end
            if stars2 then stars2.Position += starsDir * dt * s * 0.2 end
            if galaxy1 then
                local desired = -starsDir
                local r = galaxy1.CFrame.RightVector
                local u = galaxy1.CFrame.UpVector
                local proj = r * desired:Dot(r) + u * desired:Dot(u)
                local mag = proj.Magnitude
                if mag > 1e-6 then
                    proj = proj / mag
                else
                    proj = -u
                end
                galaxy1.Position += proj * dt * s * 0.08
            end
            LoopPlanes(handsState.galaxyMask, handsState.planes, handsState.zOffset)
        end)
    end
    ESP._GalaxyHands_Stop = function()
        RunService:UnbindFromRenderStep(handsStepName)
        if handsMaskGui and handsMaskGui.Parent then
            handsMaskGui:Destroy()
        end
        handsMaskGui = nil
        handsViewportsFolder = nil
        handsState = nil
    end
end
local function StartBeastChams(enablePlayers)
    local g = _G
    if g.BeastChams_IsRunning and g.BeastChams_IsRunning() then
        if g.BeastChams_Stop then
            pcall(g.BeastChams_Stop)
        end
    end
    if g.BeastChams_Stop then
        pcall(g.BeastChams_Stop)
    end
    if g.Chams_Stop then
        pcall(g.Chams_Stop)
    end
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    local CoreGui = game:GetService("CoreGui")
    local LocalPlayer = Players.LocalPlayer
    local table_insert = table.insert
    local table_remove = table.remove
    local table_clear = table.clear
    local os_clock = os.clock
    local Vector3_new = Vector3.new
    local Color3_fromRGB = Color3.fromRGB
    local pairs = pairs
    local ipairs = ipairs
    local NEON = Enum.Material.Neon
    local FORCEFIELD = Enum.Material.ForceField
    local CAMERA_PRIORITY = Enum.RenderPriority.Camera.Value + 1
    local visParams = RaycastParams.new()
    visParams.FilterType = Enum.RaycastFilterType.Exclude
    visParams.IgnoreWater = true
    ESP._BeastChamsHiddenParts = ESP._BeastChamsHiddenParts or {}
    local hiddenParts = ESP._BeastChamsHiddenParts
    local function setCharacterHidden(character, hidden)
        if not character then return end
        for _, d in ipairs(character:GetDescendants()) do
            if d:IsA("BasePart") then
                if hidden then
                    if hiddenParts[d] == nil then
                        hiddenParts[d] = d.LocalTransparencyModifier
                    end
                    d.LocalTransparencyModifier = 1
                else
                    local old = hiddenParts[d]
                    if old ~= nil then
                        d.LocalTransparencyModifier = old
                        hiddenParts[d] = nil
                    end
                end
            end
        end
    end
    ESP._BeastChams_SetHidden = setCharacterHidden
    local modeKey = tostring(CurrentChamsType or ""):lower():gsub("%s+", "")
    local modeId = 0
    if modeKey == "forcefield" then
        modeId = 1
    elseif modeKey == "model" then
        modeId = 2
    else
        modeId = 0
    end
    local SETTINGS = {
        RenderDistance = 2000,
        OutlineColor = Color3_fromRGB(255, 50, 255),
        CoreColor = Color3_fromRGB(0, 0, 0),
        OutlineIntensity = 0,
        LoadDelay = 0,
    }
    if ESP and ESP.Drawing and ESP.Drawing.Chams then
        if typeof(ESP.Drawing.Chams.FillRGB) == "Color3" then
            SETTINGS.CoreColor = ESP.Drawing.Chams.FillRGB
        end
        if typeof(ESP.Drawing.Chams.OutlineRGB) == "Color3" then
            SETTINGS.OutlineColor = ESP.Drawing.Chams.OutlineRGB
        end
    end
    local REMOVE_CLASSES_STRIP = {
        ["Decal"] = true, ["Texture"] = true, ["SurfaceGui"] = true, ["BillboardGui"] = true,
        ["ParticleEmitter"] = true, ["Trail"] = true, ["Beam"] = true, ["Fire"] = true,
        ["Smoke"] = true, ["Sparkles"] = true, ["PointLight"] = true, ["SpotLight"] = true,
        ["SurfaceLight"] = true, ["FaceControls"] = true, ["WrapTarget"] = true,
        ["WrapLayer"] = true, ["SurfaceAppearance"] = true, ["Script"] = true,
        ["LocalScript"] = true, ["ModuleScript"] = true, ["Weld"] = true,
        ["Motor6D"] = true, ["Motor"] = true, ["Snap"] = true, ["WeldConstraint"] = true,
        ["Animator"] = true, ["BodyGyro"] = true, ["BodyVelocity"] = true
    }
    local REMOVE_CLASSES_MODEL = {
        ["SurfaceGui"] = true, ["BillboardGui"] = true,
        ["ParticleEmitter"] = true, ["Trail"] = true, ["Beam"] = true, ["Fire"] = true,
        ["Smoke"] = true, ["Sparkles"] = true, ["PointLight"] = true, ["SpotLight"] = true,
        ["SurfaceLight"] = true, ["Script"] = true, ["LocalScript"] = true, ["ModuleScript"] = true,
        ["Weld"] = true, ["Motor6D"] = true, ["Motor"] = true, ["Snap"] = true, ["WeldConstraint"] = true,
        ["Animator"] = true, ["BodyGyro"] = true, ["BodyVelocity"] = true,
        ["BodyPosition"] = true, ["BodyAngularVelocity"] = true, ["BodyForce"] = true, ["BodyThrust"] = true,
        ["VectorForce"] = true, ["LinearVelocity"] = true, ["AngularVelocity"] = true, ["AlignPosition"] = true, ["AlignOrientation"] = true
    }
    local guiName = "BeastChams_V10_Protected"
    local renderStepName = ("BeastChams_Update_" .. tostring(guiName)):gsub("[^%w_]", "_")
    ESP._BeastChamsGuiName = guiName
    ESP._BeastChamsRenderStepName = renderStepName
    local oldGui = CoreGui:FindFirstChild(guiName)
    if not oldGui and LocalPlayer then
        local pg = LocalPlayer:FindFirstChild("PlayerGui")
        if pg then
            oldGui = pg:FindFirstChild(guiName)
        end
    end
    if oldGui then
        oldGui:Destroy()
    end
    local guiInstance = Instance.new("ScreenGui")
    guiInstance.Name = guiName
    guiInstance.IgnoreGuiInset = true
    guiInstance.ResetOnSpawn = false
    guiInstance.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    guiInstance.DisplayOrder = -10000
    guiInstance.Parent = LocalPlayer:WaitForChild("PlayerGui")
    local viewport = Instance.new("ViewportFrame")
    viewport.Name = "ESPViewport"
    viewport.Size = UDim2.new(1, 0, 1, 0)
    viewport.BackgroundTransparency = 1
    viewport.ImageTransparency = 0
    viewport.Ambient = Color3_fromRGB(0, 0, 0)
    viewport.LightColor = Color3_fromRGB(255, 255, 255)
    viewport.LightDirection = Vector3_new(0, -1, 0)
    viewport.ZIndex = 0
    viewport.Parent = guiInstance
    local vpCamera = Instance.new("Camera")
    vpCamera.Name = "ESPCamera"
    vpCamera.Parent = viewport
    viewport.CurrentCamera = vpCamera
    local worldModel = Instance.new("WorldModel")
    worldModel.Name = "ESPWorld"
    worldModel.Parent = viewport
    local espObjects = {}
    local globalConnections = {}
    local ArmsKey = { __type = "Arms" }
    local armsModel = nil
    local SLIM_SKIP_PART_NAMES = {
        ["Torso"] = true,
        ["UpperTorso"] = true,
        ["LowerTorso"] = true,
        ["LeftUpperArm"] = true,
        ["LeftLowerArm"] = true,
        ["RightUpperArm"] = true,
        ["RightLowerArm"] = true,
        ["LeftUpperLeg"] = true,
        ["LeftLowerLeg"] = true,
        ["RightUpperLeg"] = true,
        ["RightLowerLeg"] = true,
        ["Left Arm"] = true,
        ["Right Arm"] = true,
        ["Left Leg"] = true,
        ["Right Leg"] = true
    }
    local function shouldUseSlimMode(player, character)
        if type(player) == "table" and player.__type == "Arms" then
            return false
        end
        local hasUpper = character:FindFirstChildWhichIsA("Shirt") ~= nil
        local hasLower = character:FindFirstChildWhichIsA("Pants") ~= nil
        if hasUpper and hasLower then
            return true
        end
        local children = character:GetChildren()
        for i = 1, #children do
            local child = children[i]
            if child:IsA("Accessory") then
                local ln = child.Name:lower()
                if not hasUpper and (ln:find("shirt", 1, true) or ln:find("jacket", 1, true) or ln:find("hoodie", 1, true) or ln:find("coat", 1, true)) then
                    hasUpper = true
                end
                if not hasLower and (ln:find("pants", 1, true) or ln:find("pant", 1, true) or ln:find("trouser", 1, true) or ln:find("jeans", 1, true) or ln:find("jean", 1, true)) then
                    hasLower = true
                end
                if hasUpper and hasLower then
                    return true
                end
            end
        end
        return false
    end
    local function shouldRenderPart(part, slimMode)
        if not part:IsA("BasePart") then return false end
        if part.Transparency >= 0.9 then return false end
        if part.Name == "HumanoidRootPart" then return false end
        if not slimMode then return true end
        if part:FindFirstAncestorOfClass("Accessory") ~= nil then return true end
        return not SLIM_SKIP_PART_NAMES[part.Name]
    end
    local function deepCleanPart(part, removeClasses, clearTextures)
        local stack = { part }
        while #stack > 0 do
            local current = stack[#stack]
            stack[#stack] = nil
            if clearTextures and current:IsA("MeshPart") then
                pcall(function()
                    current.TextureID = ""
                end)
            end
            local children = current:GetChildren()
            for i = 1, #children do
                local child = children[i]
                if removeClasses and removeClasses[child.ClassName] then
                    child:Destroy()
                else
                    if clearTextures and child:IsA("DataModelMesh") then
                        pcall(function()
                            child.TextureId = ""
                        end)
                    end
                    stack[#stack + 1] = child
                end
            end
        end
    end
    local function createClone(original, removeClasses, clearTextures, color, material, transparency)
        local clone = original:Clone()
        if #clone:GetChildren() > 0 then
            deepCleanPart(clone, removeClasses, clearTextures)
        else
            if clearTextures and clone:IsA("MeshPart") then
                pcall(function()
                    clone.TextureID = ""
                end)
            end
        end
        if material then
            clone.Material = material
        end
        if color then
            clone.Color = color
        end
        if transparency ~= nil then
            clone.Transparency = transparency
        end
        clone.Anchored = true
        clone.CanCollide = false
        clone.CanQuery = false
        clone.CanTouch = false
        clone.CastShadow = false
        clone.Massless = true
        return clone
    end
    local function cleanESP(player)
        local data = espObjects[player]
        if not data then return end
        local root = data.Root
        if root then
            root.Parent = nil
            task.spawn(function()
                pcall(function()
                    root:Destroy()
                end)
            end)
        end
        if data.Connections then
            for _, conn in ipairs(data.Connections) do
                if conn.Connected then
                    conn:Disconnect()
                end
            end
        end
        espObjects[player] = nil
    end
    local function processPart(player, part, rootModel, partsList)
        if not part or not part.Parent then return end
        local inner = nil
        local outer = nil
        if modeId == 2 then
            inner = createClone(part, REMOVE_CLASSES_MODEL, false)
            inner.Parent = rootModel
        elseif modeId == 1 then
            outer = createClone(part, REMOVE_CLASSES_STRIP, true, SETTINGS.OutlineColor, FORCEFIELD, SETTINGS.OutlineIntensity)
            outer.Parent = rootModel
        else
            inner = createClone(part, REMOVE_CLASSES_STRIP, true, SETTINGS.CoreColor, NEON, 0)
            outer = createClone(part, REMOVE_CLASSES_STRIP, true, SETTINGS.OutlineColor, FORCEFIELD, SETTINGS.OutlineIntensity)
            inner.Parent = rootModel
            outer.Parent = rootModel
        end
        local entry = {
            [1] = part,
            [2] = inner,
            [3] = outer,
            [4] = modeId
        }
        table_insert(partsList, entry)
    end
    local function createESPForPlayer(player, character)
        cleanESP(player)
        local rootModel = Instance.new("Model")
        if typeof(player) == "Instance" and player.Name then
            rootModel.Name = player.Name
        elseif type(player) == "table" and player.__type == "Arms" then
            rootModel.Name = "Arms"
        else
            rootModel.Name = "Target"
        end
        rootModel.Parent = worldModel
        local partsList = {}
        local connections = {}
        local slimMode = shouldUseSlimMode(player, character)
        for _, desc in ipairs(character:GetDescendants()) do
            if shouldRenderPart(desc, slimMode) then
                processPart(player, desc, rootModel, partsList)
            end
        end
        local conn = character.DescendantAdded:Connect(function(desc)
            if shouldRenderPart(desc, slimMode) then
                processPart(player, desc, rootModel, partsList)
            end
        end)
        table_insert(connections, conn)
        espObjects[player] = {
            Root = rootModel,
            Parts = partsList,
            Character = character,
            Connections = connections,
            Visible = true,
            SlimMode = slimMode,
            LastUpdate = 0
        }
    end
    local playerConnection = nil
    local playerRemovingConnection = nil
    local function onPlayerAdded(player)
        if player == LocalPlayer then return end
        local function charAdded(char)
            if not char then return end
            local hum = char:WaitForChild("Humanoid", 10)
            if not hum then return end
            if SETTINGS.LoadDelay and SETTINGS.LoadDelay > 0 then
                task.wait(SETTINGS.LoadDelay)
            end
            if char.Parent then
                createESPForPlayer(player, char)
                if ESP and ESP.Drawing and ESP.Drawing.Chams and ESP.Drawing.Chams.HideOriginalModels then
                    setCharacterHidden(char, true)
                end
            end
        end
        if player.Character then
            task.spawn(charAdded, player.Character)
        end
        local charConn = player.CharacterAdded:Connect(charAdded)
        table_insert(globalConnections, charConn)
    end
    local function EnablePlayers()
        if playerConnection then
            return
        end
        for _, p in ipairs(Players:GetPlayers()) do
            onPlayerAdded(p)
        end
        playerConnection = Players.PlayerAdded:Connect(onPlayerAdded)
        playerRemovingConnection = Players.PlayerRemoving:Connect(cleanESP)
        table_insert(globalConnections, playerConnection)
        table_insert(globalConnections, playerRemovingConnection)
    end
    local function DisablePlayers()
        if playerConnection then
            playerConnection:Disconnect()
            playerConnection = nil
        end
        if playerRemovingConnection then
            playerRemovingConnection:Disconnect()
            playerRemovingConnection = nil
        end
        for _, p in ipairs(Players:GetPlayers()) do
            cleanESP(p)
        end
    end
    _G.BeastChams_IsRunning = function() return true end
    _G.BeastChams_EnablePlayers = EnablePlayers
    _G.BeastChams_DisablePlayers = DisablePlayers
    _G.BeastChams_CoreColor = _G.BeastChams_CoreColor or SETTINGS.CoreColor
    _G.BeastChams_OutlineColor = _G.BeastChams_OutlineColor or SETTINGS.OutlineColor
    _G.BeastChams_ArmsOutlineColor = _G.BeastChams_ArmsOutlineColor or SETTINGS.OutlineColor
    _G.BeastChams_ArmsCoreColor = _G.BeastChams_ArmsCoreColor or SETTINGS.CoreColor
    _G.BeastChams_SetArmsColors = function(coreColor, outlineColor)
        if typeof(coreColor) == "Color3" then
            _G.BeastChams_ArmsCoreColor = coreColor
        end
        if typeof(outlineColor) == "Color3" then
            _G.BeastChams_ArmsOutlineColor = outlineColor
        end
    end
    _G.BeastChams_SetColors = function(coreColor, outlineColor)
        if typeof(coreColor) == "Color3" then
            _G.BeastChams_CoreColor = coreColor
        end
        if typeof(outlineColor) == "Color3" then
            _G.BeastChams_OutlineColor = outlineColor
        end
    end
    _G.BeastChams_Stop = function()
        RunService:UnbindFromRenderStep(renderStepName)
        if guiInstance and guiInstance.Parent then
            guiInstance:Destroy()
        end
        for _, data in pairs(espObjects) do
            if data.Connections then
                for _, c in ipairs(data.Connections) do
                    if c.Connected then
                        c:Disconnect()
                    end
                end
            end
            if data.Root then
                pcall(function()
                    data.Root:Destroy()
                end)
            end
        end
        table_clear(espObjects)
        for _, c in ipairs(globalConnections) do
            if c.Connected then
                c:Disconnect()
            end
        end
        table_clear(globalConnections)
        armsModel = nil
        _G.BeastChams_RegisterArms = nil
        _G.BeastChams_UnregisterArms = nil
        _G.BeastChams_IsRunning = nil
        _G.BeastChams_EnablePlayers = nil
        _G.BeastChams_DisablePlayers = nil
        _G.BeastChams_Stop = nil
        _G.Chams_Stop = nil
        _G.Chams_RegisterArms = nil
        _G.Chams_UnregisterArms = nil
    end
    _G.BeastChams_RegisterArms = function(model)
        if typeof(model) ~= "Instance" or not model:IsA("Model") or not model.Parent then
            cleanESP(ArmsKey)
            armsModel = nil
            return
        end
        if armsModel == model and espObjects[ArmsKey] then
            return
        end
        armsModel = model
        createESPForPlayer(ArmsKey, model)
    end
    _G.BeastChams_UnregisterArms = function()
        cleanESP(ArmsKey)
        armsModel = nil
    end
    _G.Chams_Stop = _G.BeastChams_Stop
    _G.Chams_RegisterArms = _G.BeastChams_RegisterArms
    _G.Chams_UnregisterArms = _G.BeastChams_UnregisterArms
    RunService:BindToRenderStep(renderStepName, CAMERA_PRIORITY, function()
        local cam = Workspace.CurrentCamera
        if not cam then return end
        local camCF = cam.CFrame
        local camPos = camCF.Position
        local now = os_clock()
        vpCamera.CFrame = camCF
        vpCamera.FieldOfView = cam.FieldOfView
        local studsPerMeter = (allvars and allvars._units and allvars._units.studsPerMeter) or 3.5714285714
        local maxMeters = (ESP and ESP.Drawing and ESP.Drawing.Chams and ESP.Drawing.Chams.MaxDistance) or ESP.MaxDistance or 150
        local maxStuds = maxMeters * studsPerMeter
        local distLimit = maxStuds * maxStuds
        local xray = ESP and ESP.Drawing and ESP.Drawing.Chams and ESP.Drawing.Chams.XRay
        local ctl = tostring(CurrentChamsType or ""):lower():gsub("%s+", "")
        local isBeast = (ctl == "opaqueforcefield" or ctl == "forcefield" or ctl == "model")
        local playersChamsOn = (ChamsToggleState == true)
        local selfEnabled = isBeast
            and playersChamsOn
            and ((allvars and allvars.camthirdp and allvars.thirdPersonSelfChams) or (_G.allvars and _G.allvars.camthirdp and _G.allvars.thirdPersonSelfChams))
        if selfEnabled then
            local lpChar = LocalPlayer.Character
            if lpChar and lpChar.Parent then
                local d = espObjects[LocalPlayer]
                if (not d) or d.Character ~= lpChar then
                    createESPForPlayer(LocalPlayer, lpChar)
                end
            end
        else
            if espObjects[LocalPlayer] then
                cleanESP(LocalPlayer)
            end
        end
        for player, data in pairs(espObjects) do
            data.LastUpdate = now
            local char = data.Character
            if not char or not char.Parent then
                cleanESP(player)
                continue
            end
            local root = char.PrimaryPart or char:FindFirstChild("HumanoidRootPart") or char:FindFirstChildWhichIsA("BasePart")
            if not root then
                continue
            end
            local rootPos = root.Position
            local diff = rootPos - camPos
            local distSq = diff:Dot(diff)
            if distSq > distLimit then
                if data.Visible and data.Root and data.Root.Parent then
                    data.Root.Parent = nil
                end
                data.Visible = false
                continue
            end
            if not xray and player ~= ArmsKey then
                local nextVis = data.NextVisCheck
                if not nextVis or now >= nextVis then
                    local lpChar = LocalPlayer.Character
                    visParams.FilterDescendantsInstances = lpChar and { lpChar } or {}
                    local res = Workspace:Raycast(camPos, rootPos - camPos, visParams)
                    data.LastVisible = (not res) or (res.Instance and res.Instance:IsDescendantOf(char))
                    data.NextVisCheck = now + 0.12
                end
                if not data.LastVisible then
                    if data.Visible and data.Root and data.Root.Parent then
                        data.Root.Parent = nil
                    end
                    data.Visible = false
                    continue
                end
            end
            local parts = data.Parts
            if (not data.Visible) and data.Root and (not data.Root.Parent) then
                data.Root.Parent = worldModel
            end
            data.Visible = true
            for i = #parts, 1, -1 do
                local entry = parts[i]
                local original = entry[1]
                local inner = entry[2]
                local outer = entry[3]
                if original and original.Parent then
                    local cf = original.CFrame
                    local entryMode = entry[4]
                    if entryMode ~= 2 then
                        if inner then
                            local g = _G
                            inner.Color = (player == ArmsKey and g.BeastChams_ArmsCoreColor) or g.BeastChams_CoreColor or SETTINGS.CoreColor
                        end
                        if outer then
                            local g = _G
                            outer.Color = (player == ArmsKey and g.BeastChams_ArmsOutlineColor) or g.BeastChams_OutlineColor or SETTINGS.OutlineColor
                        end
                    end
                    if inner then
                        inner.CFrame = cf
                    end
                    if outer then
                        outer.CFrame = cf
                    end
                else
                    if inner then inner:Destroy() end
                    if outer then outer:Destroy() end
                    table_remove(parts, i)
                end
            end
        end
    end)
    if enablePlayers then
        EnablePlayers()
    end
end
local LootESP = {
    Enabled = false,
    TextTransparency = 0.3,
    ChamsTransparency = 0.75,
    MaxDistance = 1000,
    PriorityList = {},
    Containers = {
        Enabled = false,
        NameEnabled = true,
        IconEnabled = false,
        ChamsEnabled = false,
        NameColor = Color3.fromRGB(255, 255, 0),
        ChamsColor = Color3.fromRGB(255, 255, 0),
        Cache = {},
        Connection = nil
    },
    DroppedItems = {
        Enabled = false,
        NameEnabled = true,
        IconEnabled = false,
        ChamsEnabled = false,
        NameColor = Color3.fromRGB(0, 255, 255),
        ChamsColor = Color3.fromRGB(0, 255, 255),
        Cache = {},
        Connection = nil,
        PriorityList = {}
    },
    Corpses = {
        Enabled = false,
        NameEnabled = true,
        IconEnabled = false,
        ChamsEnabled = false,
        NameColor = Color3.fromRGB(255, 0, 0),
        ChamsColor = Color3.fromRGB(255, 0, 0),
        Cache = {},
        Connection = nil
    },
    Exits = {
        Enabled = false,
        IconEnabled = true,
        DistanceEnabled = true,
        MaxDistance = 10000,
        Color = Color3.fromRGB(0, 255, 0),
        Cache = {},
        Connection = nil
    }
}
local function CreateInstance(className, properties)
    local inst = Instance.new(className)
    if properties then
        for k, v in pairs(properties) do
            inst[k] = v
        end
    end
    return inst
end
local function GetOrCreateCoreGuiObject(name, className)
    local coreGui = game:GetService("CoreGui")
    local existing = coreGui:FindFirstChild(name)
    if existing and existing.ClassName == className then
        if className == "ScreenGui" then
            pcall(function()
                existing.ResetOnSpawn = false
                existing.IgnoreGuiInset = true
                existing.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            end)
        end
        return existing
    end
    if existing then
        pcall(function()
            existing:Destroy()
        end)
    end
    local obj = Instance.new(className)
    obj.Name = name
    if className == "ScreenGui" then
        pcall(function()
            obj.ResetOnSpawn = false
            obj.IgnoreGuiInset = true
            obj.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        end)
    end
    obj.Parent = coreGui
    pcall(function()
        if syn and syn.protect_gui then
            syn.protect_gui(obj)
        end
    end)
    return obj
end
local function ApplyResolutionStretchY(y, cam)
    return y
end
local function CreateEspLabel(parent, position, textColor, visible, richText)
    return CreateInstance("TextLabel", {
        Parent = parent,
        Position = position,
        Size = UDim2.new(0, 100, 0, 20),
        AnchorPoint = Vector2.new(0.5, 0.5),
        BackgroundTransparency = 1,
        TextColor3 = textColor,
        Font = 3,
        TextSize = (ESP and ESP.FontSize) or 11,
        TextStrokeTransparency = 0,
        TextStrokeColor3 = Color3.fromRGB(0, 0, 0),
        RichText = richText == true,
        Visible = visible == true
    })
end
local function EnsureDefaults(tbl, defaults)
    if type(tbl) ~= "table" then
        tbl = {}
    end
    for k, v in pairs(defaults) do
        if tbl[k] == nil then
            tbl[k] = v
        end
    end
    return tbl
end
local function HideGuiObjects(container)
    if not container then
        return
    end
    for _, child in pairs(container:GetChildren()) do
        pcall(function()
            if child:IsA("GuiObject") then
                child.Visible = false
            elseif child:IsA("Highlight") then
                child.Enabled = false
            end
        end)
    end
end
LootESP.Icons = {
    Container = "rbxthumb://type=Asset&id=79009329665038&w=420&h=420",
    Corpse = "rbxthumb://type=Asset&id=79180049864980&w=420&h=420",
    Item = "rbxthumb://type=Asset&id=18312792155&w=420&h=420"
}
function LootESP:_GetHolder()
    local holder = self._Holder
    if holder and holder.Parent then
        return holder
    end
    holder = GetOrCreateCoreGuiObject("LootESPHolder", "Folder")
    self._Holder = holder
    return holder
end
local CFrameSpeed = {
    Enabled = false,
    Speed = 0.01,
    KeysEnabled = {
        W = true,
        A = true,
        S = true,
        D = true,
        Space = true
    },
    Connection = nil,
    FastWalkEnabled = false,
    FastWalkSpeed = 0.017,
    OriginalSpeed = 0.01,
    DirectWalkSpeedEnabled = false,
    OriginalWalkSpeed = 16,
    FastWalkSpeedValue = 17.7,
    WalkSpeedConnection = nil
}
local ZoomSettings = {
    Enabled = false,
    ZoomTime = 0.07,
    ZoomedAmount = 10,
    Key = Enum.KeyCode.X,
    OldZoom = (Workspace.CurrentCamera and Workspace.CurrentCamera.FieldOfView) or 70,
    IsZooming = false,
    CurrentTween = nil,
    InputConnection = nil,
    EndConnection = nil,
    IsFOVChangerActive = false,
    IsKeyDown = false,
    LastBindUpdate = 0
}
local tabGroups = {}
if Window then
    tabGroups.MainGroup = Window:TabGroup()
end
local tabs = {}
if tabGroups.MainGroup then
    tabs = {
        Aimbot = tabGroups.MainGroup:Tab({ Name = "Combat", Image = "rbxassetid://4483345998" }),
        ESP = tabGroups.MainGroup:Tab({ Name = "ESP", Image = "rbxassetid://11833663904" }),
        Loot = tabGroups.MainGroup:Tab({ Name = "World ESP", Image = "rbxassetid://9087232887" }),
        Player = tabGroups.MainGroup:Tab({ Name = "Player", Image = "rbxassetid://117259180607823" }),
        World = tabGroups.MainGroup:Tab({ Name = "World", Image = "rbxassetid://121658694000474" }),
        Settings = tabGroups.MainGroup:Tab({ Name = "Settings", Image = "rbxassetid://7300486042" })
    }
end
local sections = {}
if tabs.Aimbot then
    sections = {
        AimMain = tabs.Aimbot:Section({ Side = "Left", Name = "Mine Settings" }),
        AimTargeting = tabs.Aimbot:Section({ Side = "Left", Name = "FOV Settings" }),
        HitmarkerVisuals = tabs.Aimbot:Section({ Side = "Left", Name = "Hit Visuals" }),
        AimVisual = tabs.Aimbot:Section({ Side = "Right", Name = "Visual settings" }),
        GunMod = tabs.Aimbot:Section({ Side = "Right", Name = "Gun Mod" }),
         RageGunMod = tabs.Aimbot:Section({ Side = "Right", Name = "RAGE GUN MOD" }),
        ESPMain = tabs.ESP:Section({ Side = "Left", Name = "Main Settings" }),
        ESPName = tabs.ESP:Section({ Side = "Left", Name = "Name" }),
        ESPDistance = tabs.ESP:Section({ Side = "Left", Name = "Distance" }),
        ESPWeapon = tabs.ESP:Section({ Side = "Left", Name = "Weapon" }),
        ESPHealth = tabs.ESP:Section({ Side = "Left", Name = "Health" }),
        ESPArrows = tabs.ESP:Section({ Side = "Left", Name = "Arrows" }),
        ESPBox = tabs.ESP:Section({ Side = "Right", Name = "Box" }),
        ESPChams = tabs.ESP:Section({ Side = "Right", Name = "Chams" }),
        ESPOther = tabs.ESP:Section({ Side = "Right", Name = "Other" }),
        ESPInventoryValue = tabs.ESP:Section({ Side = "Right", Name = "Inventory Value" }),
        ESPSkeleton = tabs.ESP:Section({ Side = "Right", Name = "Skeleton" }),
        LootMain = tabs.Loot:Section({ Side = "Left", Name = "Main Settings" }),
        PlayerMovement = tabs.Player:Section({ Side = "Left", Name = "Movement" }),
        PlayerInventory = tabs.Player:Section({ Side = "Right", Name = "Inventory Viewer" }),
        PlayerBulletTracer = tabs.Player:Section({ Side = "Right", Name = "Bullet Tracers" }),
        PlayerZoom = tabs.Player:Section({ Side = "Left", Name = "Zoom Settings" }),
        PlayerHand = tabs.Player:Section({ Side = "Left", Name = "Hand Customization" }),
        PlayerThirdPerson = tabs.Player:Section({ Side = "Right", Name = "Third Person" }),
        PlayerScreen = tabs.Player:Section({ Side = "Right", Name = "Screen Settings" }),
        PlayerOther = tabs.Player:Section({ Side = "Right", Name = "Other" }),
        WorldVisual = tabs.World:Section({ Side = "Left" })
    }
end
local function safeLength(tbl)
    if type(tbl) ~= "table" then return 0 end
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end
local function safePairs(t)
    if type(t) ~= "table" then
        return function() end, nil, nil
    else
        return pairs(t)
    end
end
local function safeClearTable(tbl)
    if type(tbl) ~= "table" then return end
    for k in pairs(tbl) do
        tbl[k] = nil
    end
end
local function safeAccess(obj, propName)
    if not obj then return nil end
    local success, result = pcall(function() return obj[propName] end)
    return success and result or nil
end
sections.AimMain:Header({
    Text = "Aim Settings"
})
local aimtargetposition = nil
runs.RenderStepped:Connect(function()
    if localplayer.Character and localplayer.Character:FindFirstChild("Humanoid") and localplayer.Character:FindFirstChild("HumanoidRootPart") then
        local humstate = localplayer.Character.Humanoid:GetState()
        if nofall and (humstate == Enum.HumanoidStateType.FallingDown or humstate == Enum.HumanoidStateType.Freefall) and localplayer.Character.HumanoidRootPart.AssemblyLinearVelocity.Y < -30 then
            localplayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Landed)
            if instafall then
                local rparams = RaycastParams.new()
                rparams.IgnoreWater = false
                rparams.FilterDescendantsInstances = {
                    localplayer.Character
                }
                local fray = workspace:Raycast(localplayer.Character.HumanoidRootPart.Position, Vector3.new(0, -400, 0), rparams)
                if fray then
                    localplayer.Character.HumanoidRootPart.CFrame = CFrame.new(fray.Position + Vector3.new(0, 3, 0))
                end
            end
        end
    end
end)
local aim_priorityParts = {
    "Head", "HeadTopHitBox", "FaceHitBox",
    "UpperTorso", "LowerTorso", "HumanoidRootPart",
    "LeftUpperArm", "RightUpperArm",
    "LeftLowerArm", "RightLowerArm",
    "LeftHand", "RightHand",
    "LeftUpperLeg", "RightUpperLeg",
    "LeftLowerLeg", "RightLowerLeg",
    "LeftFoot", "RightFoot"
}
local aim_multipoint_priority = {
    "Head", "HeadTopHitBox", "FaceHitBox",
    "UpperTorso", "LowerTorso", "HumanoidRootPart",
    "LeftUpperArm", "RightUpperArm",
    "LeftUpperLeg", "RightUpperLeg"
}
local MultipointCache2 = setmetatable({}, {__mode = "k"})
local MultipointTypeCache2 = setmetatable({}, {__mode = "k"})
local function choosetarget()
    if not wcamera or not wcamera:IsA("Camera") then
        return
    end
    local cent = getCenter()
    local cdist = math.huge
    local ctar = nil
    local cpart = nil
    local restar = nil
    local predist = math.huge
    local ammodistance = 10000
    if aimdistcheck and globalammo then
        pcall(function()
            ammodistance = 2500
        end)
    end
    local function getHumanoid(model)
        if not model then return nil end
        return model:FindFirstChildOfClass("Humanoid") or model:FindFirstChild("Humanoid")
    end
    local function getRootPart(model)
        if not model then return nil end
        return model:FindFirstChild("HumanoidRootPart") or model.PrimaryPart or model:FindFirstChild("Torso") or model:FindFirstChild("UpperTorso") or model:FindFirstChild("LowerTorso")
    end
    local function chooseTpart(charact, checkVis)
        if not charact then return nil end
        if aimpart == "Head" then
            return charact:FindFirstChild("Head")
        elseif aimpart == "HeadTop" then
            return charact:FindFirstChild("HeadTopHitBox")
        elseif aimpart == "Face" then
            return charact:FindFirstChild("FaceHitBox")
        elseif aimpart == "Torso" then
            return charact:FindFirstChild("UpperTorso") or charact:FindFirstChild("Torso") or charact:FindFirstChild("HumanoidRootPart")
        elseif aimpart == "Multipoint" then
            local ver = multipointCacheVersion or 0
            local pickEntry = MultipointTypeCache2[charact]
            local pick = nil
            if type(pickEntry) == "table" then
                if pickEntry.Version == ver then
                    pick = pickEntry.Pick
                end
            else
                pick = pickEntry
            end
            if not pick then
                local headP = tonumber(multipointHeadPercent) or 50
                if headP < 0 then headP = 0 end
                if headP > 100 then headP = 100 end
                pick = (math.random(0, 99) < headP) and "Head" or "Body"
                MultipointTypeCache2[charact] = { Version = ver, Pick = pick }
            end
            if checkVis then
                local cachedEntry = MultipointCache2[charact]
                local cached = nil
                if type(cachedEntry) == "table" then
                    if cachedEntry.Version == ver then
                        cached = cachedEntry.Part
                    end
                else
                    cached = cachedEntry
                end
                if cached and cached:IsDescendantOf(charact) and isvisible(charact, cached) then
                    return cached
                end
                local priority
                if pick == "Head" then
                    priority = {"Head", "HeadTopHitBox", "FaceHitBox", "UpperTorso", "Torso", "HumanoidRootPart"}
                else
                    priority = {"UpperTorso", "Torso", "LowerTorso", "HumanoidRootPart", "Head"}
                end
                if localplayer.Character and localplayer.Character.PrimaryPart and charact.PrimaryPart then
                    local d = (localplayer.Character.PrimaryPart.Position - charact.PrimaryPart.Position).Magnitude
                    if d > 150 then
                        if pick == "Head" then
                            priority = {"Head", "UpperTorso", "Torso", "HumanoidRootPart"}
                        else
                            priority = {"UpperTorso", "Torso", "HumanoidRootPart", "Head"}
                        end
                    end
                end
                for _, partName in ipairs(priority) do
                    local part = charact:FindFirstChild(partName)
                    if part and part ~= cached and isvisible(charact, part) then
                        MultipointCache2[charact] = { Version = ver, Part = part }
                        return part
                    end
                end
            end
            if pick == "Body" then
                return charact:FindFirstChild("UpperTorso") or charact:FindFirstChild("Torso") or charact:FindFirstChild("LowerTorso") or charact:FindFirstChild("HumanoidRootPart") or charact:FindFirstChild("Head")
            end
            return charact:FindFirstChild("Head") or charact:FindFirstChild("UpperTorso") or charact:FindFirstChild("Torso") or charact:FindFirstChild("HumanoidRootPart")
        elseif aimpart == "Scripted" then
            local head = charact:FindFirstChild("Head")
            local upperTorso = charact:FindFirstChild("UpperTorso") or charact:FindFirstChild("Torso")
            if not head then
                return upperTorso or charact:FindFirstChild("HumanoidRootPart") or getRootPart(charact)
            end
            if not isvisible(charact, head) then
                return upperTorso or charact:FindFirstChild("HumanoidRootPart") or getRootPart(charact)
            else
                return head
            end
        else
            return charact:FindFirstChild("Head")
        end
    end
    local function processTarget(target, isBot)
         if not target then return end
         local char = isBot and target or target.Character
         if not char then return end
         local hum = getHumanoid(char)
         if not hum or hum.Health <= 0 then return end
         if not isBot then
             if friendlistmode == "Blacklist" then
                if table.find(aimFRIENDLIST, target.Name) ~= nil then return end
             elseif friendlistmode == "Whitelist" then
                if table.find(aimFRIENDLIST, target.Name) == nil then return end
             end
         else
             if friendlistbots then
                if friendlistmode == "Blacklist" then
                    if table.find(aimFRIENDLIST, target.Name) ~= nil then return end
                elseif friendlistmode == "Whitelist" then
                    if table.find(aimFRIENDLIST, target.Name) == nil then return end
                end
            end
         end
         local potroot = chooseTpart(char, false) or getRootPart(char)
         if potroot and potroot.Position and localplayer.Character and localplayer.Character.PrimaryPart then
            local spoint, onScreen = wcamera:WorldToViewportPoint(potroot.Position)
            local optpoint = Vector2.new(spoint.X, spoint.Y)
            local dist = (optpoint - cent).Magnitude
            local betweendist = (localplayer.Character.PrimaryPart.Position - potroot.Position).Magnitude / allvars._units.studsPerMeter
            local betweendistSTUDS = (localplayer.Character.PrimaryPart.Position - potroot.Position).Magnitude
            if dist <= aimfov and dist < cdist and betweendist < aimdistance and betweendistSTUDS < ammodistance and spoint.Z > 0 then
                if aimpart == "Multipoint" then
                    potroot = chooseTpart(char, true) or potroot
                end
                local visiblePoint = nil
                if isvisible(char, potroot, potroot.Position) then
                    visiblePoint = potroot.Position
                else
                    local points = getMultiPoints(potroot)
                    for _, p in ipairs(points) do
                        if p ~= points[1] and isvisible(char, potroot, p) then
                            visiblePoint = p
                            break
                        end
                    end
                end
                if visiblePoint then
                    cdist = dist
                    ctar = target
                    cpart = potroot
                    aimtargetposition = visiblePoint
                end
                if dist < predist then
                    predist = dist
                    restar = target
                end
            end
         end
    end
    if aimbots then
        if _G.AIBotTracker and _G.AIBotTracker.Models then
             for botModel, _ in pairs(_G.AIBotTracker.Models) do
                  processTarget(botModel, true)
             end
        else
            local list = _G.AimbotBotCache and _G.AimbotBotCache.bots
            if type(list) == "table" then
                for _, botModel in ipairs(list) do
                    if botModel and botModel.Parent and botModel:IsA("Model") and not Players:GetPlayerFromCharacter(botModel) then
                        processTarget(botModel, true)
                    end
                end
            end
        end
    end
    for _, pottar in pairs(game.Players:GetPlayers()) do
        if pottar ~= localplayer then
             processTarget(pottar, false)
        end
    end
    if ctar == nil then
        aimtarget = nil
        aimtargetpart = nil
        aimtargetposition = nil
    else
        aimtarget = ctar
        aimtargetpart = cpart
    end
end
_G.AimChooseTargetImpl = choosetarget
local function updateAimPart(target)
    if target then
        local targetCharacter = nil
        if target:IsA("Model") then
            targetCharacter = target
        elseif target:IsA("Player") then
            targetCharacter = target.Character
        end
        if targetCharacter then
            local targetPart = targetCharacter:FindFirstChild(SilentAim.AimPart)
            if targetPart then
                local viewModel = Workspace.CurrentCamera:FindFirstChild("ViewModel")
                if viewModel then
                    local itemOffsets = viewModel:FindFirstChild("Item") and viewModel.Item:FindFirstChild("Offsets")
                    local aimPart = itemOffsets and itemOffsets:FindFirstChild("AimPart")
                    if aimPart then
                        local ammoStats = getAmmoStats()
                        local bulletSpeed = ammoStats.MuzzleVelocity
                        local bulletDrop = ammoStats.ProjectileDrop
                        local predSuccess, predictedPosition = pcall(function()
                            return predictposAdvanced(targetPart, bulletSpeed, bulletDrop)
                        end)
                        if not predSuccess or not predictedPosition then
                            predictedPosition = predictpos(targetPart, bulletSpeed, bulletDrop)
                        end
                        aimPart.CFrame = CFrame.lookAt(aimPart.Position, predictedPosition)
                    end
                end
            end
        end
    end
end
_G.allvars._rt.track(UserInputService.InputBegan:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        SilentAim.Holding = true
    end
    if Input.UserInputType == Enum.UserInputType.MouseButton1 then
        SilentAim.IsAiming = true
        SilentAim.Holding = true
        if SilentAim.Enabled and SilentAim.CurrentTarget then
            updateAimPart(SilentAim.CurrentTarget)
        end
    end
end))
_G.allvars._rt.track(UserInputService.InputEnded:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        SilentAim.Holding = false
    end
    if Input.UserInputType == Enum.UserInputType.MouseButton1 then
        SilentAim.IsAiming = false
        SilentAim.Holding = false
    end
end))
_G.__RAIL_UI = _G.__RAIL_UI or {}
_G.__RAIL_UI.combat = _G.__RAIL_UI.combat or {}
local combatUI = _G.__RAIL_UI.combat
combatUI.aimTargetingSectionEl = sections.AimTargeting
combatUI.hitmarkerVisualsSectionEl = sections.HitmarkerVisuals
combatUI.aimVisualSectionEl = sections.AimVisual
combatUI.enableAimToggleEl = sections.AimMain:Toggle({
    Name = "Enable Aim",
    Default = false,
    Callback = function(value)
        aimbool = value
        ensureBulletHook()
        if combatUI and combatUI.sync then
            combatUI.sync()
        end
    end
}, "AimToggle")
combatUI.aimPartDropdownEl = sections.AimMain:Dropdown({
    Name = "Aim Part",
    Multi = false,
    Required = true,
    Options = {"Head", "HumanoidRootPart", "Multipoint", "HeadTop", "Face", "Torso"},
    Default = "Multipoint",
    Callback = function(value)
        aimpart = value
        multipointCacheVersion = (multipointCacheVersion or 0) + 1
        pcall(function()
            for k in pairs(MultipointCache2) do
                MultipointCache2[k] = nil
            end
            for k in pairs(MultipointTypeCache2) do
                MultipointTypeCache2[k] = nil
            end
            if MultipointCache then
                for k in pairs(MultipointCache) do
                    MultipointCache[k] = nil
                end
            end
            if MultipointTypeCache then
                for k in pairs(MultipointTypeCache) do
                    MultipointTypeCache[k] = nil
                end
            end
        end)
        if combatUI and combatUI.sync then
            combatUI.sync()
        end
    end
}, "AimPart")
local function setSliderVisualAndValue(el, value)
    if not el then return end
    local v = tonumber(value)
    if not v then return end
    if type(el.UpdateValue) == "function" then
        local ok = pcall(function() el:UpdateValue(v) end)
        if ok then
            return
        end
    end
    local ok = false
    if el.set_value then
        ok = pcall(function() el:set_value(v) end)
    end
    if not ok and el.Set then
        ok = pcall(function() el:Set(v) end)
    end
    if not ok and el.SetValue then
        ok = pcall(function() el:SetValue(v) end)
    end
    if not ok then
        pcall(function()
            if el.Type == "Slider" and el.Slider and el.Fill and el.Min and el.Max then
                local percent = (v - el.Min) / (el.Max - el.Min)
                if percent ~= percent then percent = 0 end
                if percent < 0 then percent = 0 end
                if percent > 1 then percent = 1 end
                el.Fill.Size = UDim2.new(percent, 0, 1, 0)
                el.Slider.Position = UDim2.new(percent, 0, 0.5, 0)
            end
            if el.ValueLabel then
                el.ValueLabel.Text = tostring(math.floor(v + 0.5))
            end
        end)
    end
end
local function syncMultipointPercents(source, newValue)
    if multipointPercentSyncing then
        return
    end
    local n = math.floor((tonumber(newValue) or 0) + 0.5)
    if n < 0 then n = 0 end
    if n > 100 then n = 100 end
    local head, body
    if source == "body" then
        body = n
        head = 100 - body
    else
        head = n
        body = 100 - head
    end
    multipointHeadPercent = head
    multipointBodyPercent = body
    pcall(function()
        if MacLib and MacLib.Flags then
            MacLib.Flags.MultipointHeadPercent = head
            MacLib.Flags.MultipointBodyPercent = body
        end
    end)
    multipointPercentSyncing = true
    if source == "body" then
        setSliderVisualAndValue(combatUI.multipointHeadPercentSliderEl, head)
    else
        setSliderVisualAndValue(combatUI.multipointBodyPercentSliderEl, body)
    end
    multipointPercentSyncing = false
end
local function getFlagNumber(name, fallback)
    local v = MacLib and MacLib.Flags and MacLib.Flags[name]
    if type(v) == "table" then
        v = v.Value or v.Number or v.Amount or v.Slider or v.Toggle
    end
    local n = tonumber(v)
    if n == nil then
        return fallback
    end
    n = math.floor(n + 0.5)
    if n < 0 then n = 0 end
    if n > 100 then n = 100 end
    return n
end
do
    local head = getFlagNumber("MultipointHeadPercent", multipointHeadPercent or 60)
    multipointHeadPercent = head
    multipointBodyPercent = 100 - head
end
combatUI.multipointHeadPercentSliderEl = sections.AimMain:Slider({
    Name = "Multipoint Head %",
    Default = multipointHeadPercent,
    Minimum = 0,
    Maximum = 100,
    Precision = 0,
    Callback = function(value)
        if multipointPercentSyncing then
            return
        end
        syncMultipointPercents("head", value)
        multipointCacheVersion = (multipointCacheVersion or 0) + 1
        pcall(function()
            for k in pairs(MultipointTypeCache2) do
                MultipointTypeCache2[k] = nil
            end
            for k in pairs(MultipointCache2) do
                MultipointCache2[k] = nil
            end
            if MultipointTypeCache then
                for k in pairs(MultipointTypeCache) do
                    MultipointTypeCache[k] = nil
                end
            end
            if MultipointCache then
                for k in pairs(MultipointCache) do
                    MultipointCache[k] = nil
                end
            end
        end)
        if combatUI and combatUI.sync then
            combatUI.sync()
        end
    end
}, "MultipointHeadPercent")
combatUI.multipointBodyPercentSliderEl = sections.AimMain:Slider({
    Name = "Multipoint Body %",
    Default = multipointBodyPercent,
    Minimum = 0,
    Maximum = 100,
    Precision = 0,
    Callback = function(value)
        if multipointPercentSyncing then
            return
        end
        syncMultipointPercents("body", value)
        multipointCacheVersion = (multipointCacheVersion or 0) + 1
        pcall(function()
            for k in pairs(MultipointTypeCache2) do
                MultipointTypeCache2[k] = nil
            end
            for k in pairs(MultipointCache2) do
                MultipointCache2[k] = nil
            end
            if MultipointTypeCache then
                for k in pairs(MultipointTypeCache) do
                    MultipointTypeCache[k] = nil
                end
            end
            if MultipointCache then
                for k in pairs(MultipointCache) do
                    MultipointCache[k] = nil
                end
            end
        end)
        if combatUI and combatUI.sync then
            combatUI.sync()
        end
    end
}, "MultipointBodyPercent")
combatUI.instaHitToggleEl = sections.AimMain:Toggle({
    Name = "Insta Hit",
    Default = false,
    Callback = function(value)
        rageInstaHitEnabled = value
    end
}, "InstaHitToggle")
combatUI.hitChanceSliderEl = sections.AimMain:Slider({
    Name = "Hit Chance",
    Default = 100,
    Minimum = 0,
    Maximum = 100,
    Precision = 0,
    Callback = function(value)
        aimchance = value
    end
}, "AimHitChance")
sections.RageGunMod:Header({
    Text = "Rage Gun Mod Settings"
})
combatUI.multiShotToggleEl = sections.RageGunMod:Toggle({
    Name = "Multi Shot",
    Default = false,
    Callback = function(value)
        multiShotEnabled = value
        ensureBulletHook()
        if combatUI and combatUI.sync then
            combatUI.sync()
        end
    end
}, "MultiShotToggle")
combatUI.multiShotAmountSliderEl = sections.RageGunMod:Slider({
    Name = "Multi Shot Amount",
    Default = 2,
    Minimum = 1,
    Maximum = 5,
    Precision = 0,
    Callback = function(value)
        multiShotCount = math.floor(value)
    end
}, "MultiShotCount")
combatUI.rapidFireToggleEl = sections.RageGunMod:Toggle({
    Name = "Rapid Fire",
    Default = false,
    Callback = function(value)
        rapidFireEnabled = value
        ensureBulletHook()
        if allvars._rapidFire then
            allvars._rapidFire:scheduleRefresh()
        end
        if combatUI and combatUI.sync then
            combatUI.sync()
        end
    end
}, "RapidFireToggle")
combatUI.rapidFireDelaySliderEl = sections.RageGunMod:Slider({
    Name = "Rapid Fire Delay",
    Default = 0.1,
    Minimum = 0,
    Maximum = 0.5,
    Precision = 2,
    Callback = function(value)
        rapidFireValue = tonumber(string.format("%.3f", value)) or value
        if rapidFireEnabled then
            if allvars._rapidFire then
                allvars._rapidFire:scheduleRefresh()
            end
        end
    end
}, "RapidFireSpeed")
sections.AimTargeting:Header({
    Text = "Target Settings"
})
combatUI.aimVisCheckToggleEl = sections.AimTargeting:Toggle({
    Name = "Visibility check",
    Default = aimvischeck,
    Callback = function(value)
        aimvischeck = value
    end
}, "AimVisCheck")
combatUI.aimPingCheckToggleEl = sections.AimTargeting:Toggle({
    Name = "Ping check",
    Default = aimselftrack,
    Callback = function(value)
        aimselftrack = value
    end
}, "AimPingCheck")
combatUI.aimDistCheckToggleEl = sections.AimTargeting:Toggle({
    Name = "Ammo distance check",
    Default = aimdistcheck,
    Callback = function(value)
        aimdistcheck = value
    end
}, "AimDistCheck")
combatUI.aimTargetBotsToggleEl = sections.AimTargeting:Toggle({
    Name = "Target AI",
    Default = aimbots,
    Callback = function(value)
        aimbots = value
    end
}, "AimTargetBots")
combatUI.aimDistanceSliderEl = sections.AimTargeting:Slider({
    Name = "Aim Distance (Meters)",
    Default = aimdistance,
    Minimum = 1,
    Maximum = 10000,
    Precision = 0,
    Callback = function(value)
        aimdistance = value
    end
}, "AimDistance")
sections.HitmarkerVisuals:Header({
    Text = "Hitsound Settings"
})
combatUI.hitsoundsToggleEl = sections.HitmarkerVisuals:Toggle({
    Name = "Hitsounds",
    Default = false,
    Callback = function(value)
        hitsoundbool = value
        if combatUI and combatUI.sync then
            combatUI.sync()
        end
    end
}, "HitsoundToggle")
local hitsoundNames = {}
for name, _ in pairs(hitsoundlib) do
    table.insert(hitsoundNames, name)
end
combatUI.headSoundDropdownEl = sections.HitmarkerVisuals:Dropdown({
    Name = "Head Sound",
    Multi = false,
    Required = true,
    Options = hitsoundNames,
    Default = "Ding",
    Callback = function(value)
        hitsoundhead = value
        if not scriptloading then
            pcall(function()
                local preview = Instance.new("Sound", workspace)
                preview.SoundId = hitsoundlib[value]
                preview:Play()
                task.delay(2, function()
                    if preview then
                        preview:Destroy()
                    end
                end)
            end)
        end
    end
}, "HitsoundHead")
combatUI.bodySoundDropdownEl = sections.HitmarkerVisuals:Dropdown({
    Name = "Body Sound",
    Multi = false,
    Required = true,
    Options = hitsoundNames,
    Default = "Blackout",
    Callback = function(value)
        hitsoundbody = value
        if not scriptloading then
            pcall(function()
                local preview = Instance.new("Sound", workspace)
                preview.SoundId = hitsoundlib[value]
                preview:Play()
                task.delay(2, function()
                    if preview then
                        preview:Destroy()
                    end
                end)
            end)
        end
    end
}, "HitsoundBody")
sections.AimVisual:Header({
    Text = "Display Settings"
})
combatUI.showTargetNameToggleEl = sections.AimVisual:Toggle({
    Name = "Show Target Name",
    Default = false,
    Callback = function(value)
        aimtargetname.Visible = value
        if value then
            if targetNameVisibilityConnection then
                targetNameVisibilityConnection:Disconnect()
                targetNameVisibilityConnection = nil
            end
            targetNameVisibilityConnection = RunService.RenderStepped:Connect(function()
                if aimbool then
                    choosetarget()
                end
                if aimtarget ~= nil and aimtargetpart ~= nil then
                    local isVisible = true
                    if aimvischeck then
                        isVisible = false
                        if localplayer.Character and localplayer.Character:FindFirstChild("HumanoidRootPart") then
                            local origin = localplayer.Character.HumanoidRootPart.Position + Vector3.new(0, 1.5, 0)
                            local pos = aimtargetpart.Position
                            local dir = pos - origin
                            local dist = dir.Magnitude + 5
                            dir = dir.Unit
                            local params = RaycastParams.new()
                            params.IgnoreWater = true
                            params.CollisionGroup = "WeaponRay"
                            params.FilterDescendantsInstances = {
                                localplayer.Character:GetChildren(),
                                Workspace.CurrentCamera:GetChildren(),
                                aimignoreparts
                            }
                            local targetChar = aimtarget
                            if not aimtarget:IsA("Model") then
                                targetChar = aimtarget.Character
                            end
                            local ray = workspace:Raycast(origin, dir * dist, params)
                            if ray and ray.Instance:IsDescendantOf(targetChar) then
                                isVisible = true
                            elseif ray and ray.Instance.Name ~= "Terrain" and not ray.Instance:GetAttribute("NoPen") then
                                local ammoStats = getAmmoStats()
                                local armorpen4 = ammoStats.ArmorPen
                                local FunctionLibraryExtension = require(game.ReplicatedStorage.Modules.FunctionLibraryExtension)
                                local armorpen1, newpos2 = FunctionLibraryExtension.Penetration(FunctionLibraryExtension, ray.Instance, ray.Position, dir, armorpen4)
                                if armorpen1 and newpos2 then
                                    local neworigin = ray.Position + dir * 0.01
                                    local newray = workspace:Raycast(neworigin, dir * (dist - (neworigin - origin).Magnitude), params)
                                    if newray and newray.Instance:IsDescendantOf(targetChar) then
                                        isVisible = true
                                    end
                                end
                            end
                        end
                    end
                    aimtargetname.Visible = (aimvischeck == false or isVisible)
                    if aimtargetname.Visible then
                        aimtargetname.Text = aimtarget.Name
                        aimtargetname.Position = getCenter() + Vector2.new(0, aimfov + 20)
                    end
                else
                    aimtargetname.Visible = false
                end
            end)
        else
            if targetNameVisibilityConnection then
                targetNameVisibilityConnection:Disconnect()
                targetNameVisibilityConnection = nil
            end
            aimtargetname.Visible = false
        end
    end
}, "ShowTargetName")
combatUI.targetTrackerToggleEl = sections.AimVisual:Toggle({
    Name = "Show Target Tracker",
    Default = false,
    Callback = function(value)
        snaplinebool = value
        if value then
            if tracerVisibilityConnection then
                tracerVisibilityConnection:Disconnect()
                tracerVisibilityConnection = nil
            end
            tracerVisibilityConnection = runs.RenderStepped:Connect(function()
                if not (snaplinebool and aimtarget and aimtargetpart) then
                    aimsnapline.Visible = false
                    return
                end
                local cam = Workspace.CurrentCamera
                if not cam then
                    aimsnapline.Visible = false
                    return
                end
                local aimPos = getTrackerWorldPos(aimtarget, aimtargetpart)
                if not aimPos then
                    aimsnapline.Visible = false
                    return
                end
                local screenPos = worldToScreenPoint2D(aimPos, cam)
                if not screenPos then
                    aimsnapline.Visible = false
                    return
                end
                local visible = (aimvischeck == false) or isvisible(aimtarget, aimtargetpart)
                if not visible then
                    aimsnapline.Visible = false
                    return
                end
                aimsnapline.From = getCenter()
                aimsnapline.To = screenPos
                aimsnapline.Visible = true
            end)
    else
        if tracerVisibilityConnection then
            tracerVisibilityConnection:Disconnect()
            tracerVisibilityConnection = nil
        end
        aimsnapline.Visible = false
    end
    end
}, "TargetTracker")
sections.AimVisual:Header({
    Text = "FOV Settings"
})
allvars.aimFovShow = allvars.aimFovShow and true or false
if allvars.aimFovGradient == nil then
    allvars.aimFovGradient = false
end
if allvars.aimFovGradientAnimate == nil then
    allvars.aimFovGradientAnimate = false
end
if allvars.aimFovGradientRGB1 == nil then
    allvars.aimFovGradientRGB1 = (ESP and ESP.Drawing and ESP.Drawing.Boxes and ESP.Drawing.Boxes.GradientRGB1) or Color3.fromRGB(19, 0, 255)
end
if allvars.aimFovGradientRGB2 == nil then
    allvars.aimFovGradientRGB2 = (ESP and ESP.Drawing and ESP.Drawing.Boxes and ESP.Drawing.Boxes.GradientRGB2) or Color3.fromRGB(255, 0, 0)
end
if allvars.aimFovThickness == nil then
    allvars.aimFovThickness = tonumber(aimfovcircle.Thickness) or 0.5
end

local aimFovGui = GetOrCreateCoreGuiObject("AimFOVGui", "ScreenGui")
local aimFovCircleUI = aimFovGui:FindFirstChild("AimFOVCircle")
if aimFovCircleUI then
    pcall(function() aimFovCircleUI:Destroy() end)
end
aimFovCircleUI = CreateInstance("Frame", {
    Name = "AimFOVCircle",
    Parent = aimFovGui,
    AnchorPoint = Vector2.new(0.5, 0.5),
    BackgroundColor3 = Color3.fromRGB(255, 255, 255),
    BackgroundTransparency = 1,
    BorderSizePixel = 0,
    ClipsDescendants = true,
    Position = UDim2.fromOffset(0, 0),
    Size = UDim2.fromOffset(0, 0),
    Visible = false,
    ZIndex = 100
})
CreateInstance("UICorner", {
    Parent = aimFovCircleUI,
    CornerRadius = UDim.new(1, 0)
})
local aimFovStroke = CreateInstance("UIStroke", {
    Parent = aimFovCircleUI,
    ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
    Color = Color3.fromRGB(255, 255, 255),
    LineJoinMode = Enum.LineJoinMode.Round,
    Thickness = tonumber(allvars.aimFovThickness) or 1,
    Transparency = 1
})
local aimFovFillGradient = CreateInstance("UIGradient", {
    Parent = aimFovCircleUI,
    Enabled = false,
    Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, allvars.aimFovGradientRGB1),
        ColorSequenceKeypoint.new(1, allvars.aimFovGradientRGB2)
    }
})
local aimFovStrokeGradient = CreateInstance("UIGradient", {
    Parent = aimFovStroke,
    Enabled = false,
    Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, allvars.aimFovGradientRGB1),
        ColorSequenceKeypoint.new(1, allvars.aimFovGradientRGB2)
    }
})

aimfovcircle.Thickness = tonumber(allvars.aimFovThickness) or aimfovcircle.Thickness

local function syncAimFovCircleUI()
    if not aimFovCircleUI or not aimFovStroke then
        return
    end
    local center = getCenter()
    aimFovCircleUI.Position = UDim2.fromOffset(center.X, center.Y)
    local r = tonumber(aimfov) or 0
    local d = math.max(0, r * 2)
    aimFovCircleUI.Size = UDim2.fromOffset(d, d)
    local alpha = math.clamp(tonumber(aimfovcircle.Transparency) or 0, 0, 1)
    local uiTrans = 1 - alpha
    aimFovStroke.Transparency = uiTrans
    aimFovStroke.Thickness = tonumber(allvars.aimFovThickness) or 1
    aimfovcircle.Thickness = tonumber(allvars.aimFovThickness) or aimfovcircle.Thickness
    if aimfovcircle.Filled then
        aimFovCircleUI.BackgroundTransparency = uiTrans
    else
        aimFovCircleUI.BackgroundTransparency = 1
    end
    local useGrad = allvars.aimFovGradient and true or false
    aimFovStrokeGradient.Enabled = useGrad
    aimFovFillGradient.Enabled = useGrad and (aimfovcircle.Filled and true or false)
    if not useGrad then
        local c = aimfovcircle.Color or Color3.fromRGB(255, 255, 255)
        aimFovCircleUI.BackgroundColor3 = c
        aimFovStroke.Color = c
    end
end

local aimFovGradientAnimConn = nil
local aimFovGradientAnimLast = 0
local function setAimFovGradientAnimation(on)
    if aimFovGradientAnimConn then
        aimFovGradientAnimConn:Disconnect()
        aimFovGradientAnimConn = nil
    end
    if not on then
        return
    end
    aimFovGradientAnimLast = tick()
    aimFovGradientAnimConn = RunService.RenderStepped:Connect(function()
        local useGrad = allvars.aimFovGradient and true or false
        if not useGrad then
            return
        end
        if not (aimFovCircleUI and aimFovCircleUI.Visible) then
            return
        end
        local now = tick()
        local dt = now - (aimFovGradientAnimLast or now)
        aimFovGradientAnimLast = now
        local speed = 90
        local rot = (tonumber(aimFovStrokeGradient.Rotation) or 0) + dt * speed
        rot = rot % 360
        aimFovStrokeGradient.Rotation = rot
        aimFovFillGradient.Rotation = rot
    end)
end

local function syncAimFovVisibility()
    local show = allvars.aimFovShow and true or false
    local useGrad = allvars.aimFovGradient and true or false
    if useGrad then
        aimfovcircle.Visible = false
        aimFovCircleUI.Visible = show
    else
        aimFovCircleUI.Visible = false
        aimfovcircle.Visible = show
    end
    setAimFovGradientAnimation(show and useGrad and (allvars.aimFovGradientAnimate and true or false))
    syncAimFovCircleUI()
end

syncAimFovVisibility()
combatUI.showFovToggleEl = sections.AimVisual:Toggle({
    Name = "Show FOV",
    Default = allvars.aimFovShow,
    Callback = function(value)
        allvars.aimFovShow = value and true or false
        syncAimFovVisibility()
        if combatUI and combatUI.sync then
            combatUI.sync()
        end
    end
}, "ShowFOV")
combatUI.aimFovSliderEl = sections.AimVisual:Slider({
    Name = "Aim FOV",
    Default = 150,
    Minimum = 0,
    Maximum = 1000,
    Precision = 0,
    Callback = function(value)
        aimfov = value
        aimfovcircle.Radius = value
        syncAimFovCircleUI()
    end
}, "OblivionAimFOV")
combatUI.fillFovToggleEl = sections.AimVisual:Toggle({
    Name = "Fill FOV",
    Default = false,
    Callback = function(value)
        aimfovcircle.Filled = value
        syncAimFovCircleUI()
    end
}, "FillFOVCircle")
combatUI.fovThicknessSliderEl = sections.AimVisual:Slider({
    Name = "FOV Thickness",
    Default = tonumber(allvars.aimFovThickness) or 1,
    Minimum = 0.5,
    Maximum = 10,
    Precision = 2,
    Callback = function(value)
        allvars.aimFovThickness = tonumber(value) or allvars.aimFovThickness
        syncAimFovCircleUI()
    end
}, "AimFovThickness")
combatUI.fovGradientToggleEl = sections.AimVisual:Toggle({
    Name = "FOV Gradient",
    Default = allvars.aimFovGradient,
    Callback = function(value)
        allvars.aimFovGradient = value and true or false
        syncAimFovVisibility()
        if combatUI and combatUI.sync then
            combatUI.sync()
        end
    end
}, "AimFovGradient")
combatUI.fovGradientAnimateToggleEl = sections.AimVisual:Toggle({
    Name = "Animate Gradient",
    Default = allvars.aimFovGradientAnimate,
    Callback = function(value)
        allvars.aimFovGradientAnimate = value and true or false
        syncAimFovVisibility()
        if combatUI and combatUI.sync then
            combatUI.sync()
        end
    end
}, "AimFovGradientAnimate")
combatUI.fovGradient1PickerEl = sections.AimVisual:Colorpicker({
    Name = "FOV Gradient 1 Color",
    Default = allvars.aimFovGradientRGB1,
    Alpha = 0,
    Callback = function(color)
        allvars.aimFovGradientRGB1 = color
        aimFovFillGradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, allvars.aimFovGradientRGB1),
            ColorSequenceKeypoint.new(1, allvars.aimFovGradientRGB2)
        }
        aimFovStrokeGradient.Color = aimFovFillGradient.Color
        syncAimFovCircleUI()
    end
}, "AimFovGradient1Color")
combatUI.fovGradient2PickerEl = sections.AimVisual:Colorpicker({
    Name = "FOV Gradient 2 Color",
    Default = allvars.aimFovGradientRGB2,
    Alpha = 0,
    Callback = function(color)
        allvars.aimFovGradientRGB2 = color
        aimFovFillGradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, allvars.aimFovGradientRGB1),
            ColorSequenceKeypoint.new(1, allvars.aimFovGradientRGB2)
        }
        aimFovStrokeGradient.Color = aimFovFillGradient.Color
        syncAimFovCircleUI()
    end
}, "AimFovGradient2Color")
combatUI.fovTransparencySliderEl = sections.AimVisual:Slider({
    Name = "FOV Circle Transparency",
    Default = 0.2,
    Minimum = 0,
    Maximum = 1,
    Precision = 2,
    Callback = function(value)
        aimfovcircle.Transparency = value
        syncAimFovCircleUI()
    end
}, "FOVTransparency")
combatUI.fovColorPickerEl = sections.AimVisual:Colorpicker({
    Name = "FOV Circle Color",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 0,
    Callback = function(color)
        aimfovcircle.Color = color
        aimsnapline.Color = color
        syncAimFovCircleUI()
    end
}, "FOVColor")
local previousRenderSteppedConnection = RunService:FindFirstChild("RenderSteppedConnection")
if previousRenderSteppedConnection then
    previousRenderSteppedConnection:Disconnect()
end
_G.allvars._rt.track(RunService.RenderStepped:Connect(function()
    if aimbool then
        choosetarget()
    end
    aimfovcircle.Position = getCenter()
    pcall(syncAimFovCircleUI)
    if snaplinebool and aimtarget ~= nil and aimtargetpart ~= nil and not tracerVisibilityConnection then
        local cam = Workspace.CurrentCamera
        local aimPos = getTrackerWorldPos(aimtarget, aimtargetpart)
        if not aimPos then
            aimsnapline.Visible = false
            return
        end
        local screenPos = worldToScreenPoint2D(aimPos, cam)
        if screenPos then
            local isVisible = true
            if aimvischeck then
                isVisible = false
                if localplayer.Character and localplayer.Character:FindFirstChild("HumanoidRootPart") then
                    local origin = localplayer.Character.HumanoidRootPart.Position + Vector3.new(0, 1.5, 0)
                    local pos = aimtargetpart.Position
                    local dir = pos - origin
                    local dist = dir.Magnitude + 5
                    dir = dir.Unit
                    local params = RaycastParams.new()
                    params.IgnoreWater = true
                    params.CollisionGroup = "WeaponRay"
                    params.FilterDescendantsInstances = {
                        localplayer.Character:GetChildren(),
                        Workspace.CurrentCamera:GetChildren(),
                        aimignoreparts
                    }
                    local targetChar = aimtarget
                    if not aimtarget:IsA("Model") then
                        targetChar = aimtarget.Character
                    end
                    local ray = workspace:Raycast(origin, dir * dist, params)
                    if ray and ray.Instance:IsDescendantOf(targetChar) then
                        isVisible = true
                    elseif ray and ray.Instance.Name ~= "Terrain" and not ray.Instance:GetAttribute("NoPen") then
                        local ammoStats = getAmmoStats()
                        local armorpen4 = ammoStats.ArmorPen
                        local FunctionLibraryExtension = require(game.ReplicatedStorage.Modules.FunctionLibraryExtension)
                        local armorpen1, newpos2 = FunctionLibraryExtension.Penetration(FunctionLibraryExtension, ray.Instance, ray.Position, dir, armorpen4)
                        if armorpen1 and newpos2 then
                            local neworigin = ray.Position + dir * 0.01
                            local newray = workspace:Raycast(neworigin, dir * (dist - (neworigin - origin).Magnitude), params)
                            if newray and newray.Instance:IsDescendantOf(targetChar) then
                                isVisible = true
                            end
                        end
                    end
                end
            end
            if isVisible then
                aimsnapline.From = getCenter()
                aimsnapline.To = screenPos
                aimsnapline.Visible = true
            else
                aimsnapline.Visible = false
            end
        else
            aimsnapline.Visible = false
        end
    elseif not tracerVisibilityConnection then
        aimsnapline.Visible = false
    end
    if aimtarget ~= nil and aimbool and SilentAim.ShowTargetName and not targetNameVisibilityConnection then
        aimtargetname.Text = aimtarget.Name
        aimtargetname.Visible = true
        aimtargetname.Position = getCenter() + Vector2.new(0, aimfov + 20)
    elseif not targetNameVisibilityConnection then
        aimtargetname.Text = " "
        aimtargetname.Visible = false
    end
end))
local InitializePlayerSkeleton = function(player)
    if ESP.Skeletons[player] then
        for name, line in pairs(ESP.Skeletons[player]) do
            pcall(function()
                if line and typeof(line) ~= "table" then
                    line:Remove()
                end
            end)
        end
        ESP.Skeletons[player] = nil
    end
    local thickness = ESP.Drawing.Skeleton.Thickness or 1
    local color = ESP.Drawing.Skeleton.Color or Color3.new(1, 1, 1)
    local function CreateSkeletonDrawing(type, properties)
        local drawing
        local success = pcall(function()
            drawing = Drawing.new(type)
            if properties then
                for prop, value in pairs(properties) do
                    pcall(function()
                        drawing[prop] = value
                    end)
                end
            end
            drawing.Visible = false
        end)
        if success and drawing then
            return drawing
        else
            pcall(function()
                drawing = Drawing.new(type)
                drawing.Visible = false
                if type == "Line" then
                    drawing.Thickness = thickness
                    drawing.Color = color
                elseif type == "Circle" then
                    drawing.Thickness = 1
                    drawing.Color = color
                    drawing.NumSides = 20
                    drawing.Radius = 4
                    drawing.Filled = true
                end
            end)
            return drawing
        end
    end
    local skeleton = {
        lastPlayerPos = nil,
        lastUpdate = tick(),
        lastFoV = nil,
        lastCamPos = nil,
    }
    local lineProps = { Thickness = thickness, Color = color }
    local lineKeys = {
        "NeckLine",
        "UpperSpine",
        "LowerSpine",
        "LeftUpperArm",
        "LeftLowerArm",
        "RightUpperArm",
        "RightLowerArm",
        "LeftUpperLeg",
        "LeftLowerLeg",
        "RightUpperLeg",
        "RightLowerLeg",
        "LeftFoot",
        "RightFoot",
        "LeftElbow",
        "RightElbow",
        "LeftClavicle",
        "RightClavicle"
    }
    for _, key in ipairs(lineKeys) do
        skeleton[key] = CreateSkeletonDrawing("Line", lineProps)
    end
    ESP.Skeletons[player] = skeleton
    return skeleton
end
sections.ESPMain:Header({
    Text = "ESP Settings"
})
ESP._ui = ESP._ui or {}
ESP._ui._syncESPVisibility = ESP._ui._syncESPVisibility or function() end
ESP._ui.enableESPToggleEl = sections.ESPMain:Toggle({
    Name = "Enable ESP",
    Default = ESP.Enabled,
    Callback = function(value)
        ESP.Enabled = value
        if not value then
            local espHolder = CoreGui:FindFirstChild("ESPHolder")
            if espHolder then
                for _, playerESP in pairs(espHolder:GetChildren()) do
                    HideGuiObjects(playerESP)
                end
            end
            for _, skeleton in pairs(ESP.Skeletons or {}) do
                for name, line in pairs(skeleton) do
                    if type(name) == "string" and name ~= "lastPlayerPos" and name ~= "lastUpdate" and name ~= "lastFoV" and name ~= "lastCamPos" then
                        pcall(function()
                            if line and typeof(line) ~= "table" and type(line) ~= "number" and line.Visible ~= nil then
                                line.Visible = false
                            end
                        end)
                    end
                end
            end
            if ESP.GazeLines then
                for _, line in pairs(ESP.GazeLines) do
                    line.Visible = false
                end
            end
        else
            ESP.Initialized = false
        end
    end
}, "EnableESP")
local InventoryViewer
if not _G.AIBotTracker then
    _G.AIBotTracker = {
        TrackedBots = {},
        Connection = nil
    }
end
local function getAIBotHumanoid(model)
    if not model then return nil end
    return model:FindFirstChildOfClass("Humanoid") or model:FindFirstChild("Humanoid")
end
local function getAIBotRootPart(model)
    if not model then return nil end
    return model:FindFirstChild("HumanoidRootPart") or model.PrimaryPart or model:FindFirstChild("Torso") or model:FindFirstChild("UpperTorso") or model:FindFirstChild("LowerTorso")
end
_G.AIBotTracker.Models = _G.AIBotTracker.Models or setmetatable({}, {__mode = "k"})
local function trackAIBotModel(model)
    if not model or not model:IsA("Model") then return end
    local lp = Players.LocalPlayer
    if lp then
        if model == lp.Character or model.Name == lp.Name then
            return
        end
        if lp.Character and (model:IsDescendantOf(lp.Character) or lp.Character:IsDescendantOf(model)) then
            return
        end
    end
    if Players:GetPlayerFromCharacter(model) then return end
    if getAIBotHumanoid(model) and getAIBotRootPart(model) then
        _G.AIBotTracker.Models[model] = true
    end
end
local function untrackAIBotModel(model)
    if _G.AIBotTracker.Models then
        _G.AIBotTracker.Models[model] = nil
    end
end
local function StartAIBotTracking()
    if _G.AIBotTracker.ModelConnection then
        return
    end
    pcall(function()
        for _, inst in ipairs(workspace:GetDescendants()) do
            if inst:IsA("Model") then
                trackAIBotModel(inst)
            end
        end
    end)
    _G.AIBotTracker.ModelConnection = workspace.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("Model") then
            task.defer(function()
                trackAIBotModel(descendant)
            end)
            return
        end
        if descendant:IsA("Humanoid") or descendant.Name == "HumanoidRootPart" or descendant.Name == "Torso" or descendant.Name == "UpperTorso" or descendant.Name == "LowerTorso" then
            local parent = descendant.Parent
            if parent and parent:IsA("Model") then
                task.defer(function()
                    trackAIBotModel(parent)
                end)
            end
        end
    end)
    _G.AIBotTracker.ModelRemoveConnection = workspace.DescendantRemoving:Connect(function(descendant)
        if descendant:IsA("Model") then
            untrackAIBotModel(descendant)
            return
        end
        local parent = descendant.Parent
        if parent and parent:IsA("Model") then
            untrackAIBotModel(parent)
        end
    end)
end
StartAIBotTracking()
local function createAIBotESP(model)
        if not ESP.ShowAIBots then return end
        local lp = Players.LocalPlayer
        if lp then
            if model == lp.Character then
                return
            end
            if model.Name == lp.Name then
                return
            end
            if lp.Character and (model:IsDescendantOf(lp.Character) or lp.Character:IsDescendantOf(model)) then
                return
            end
        end
        if Players:GetPlayerFromCharacter(model) then return end
        local root = getAIBotRootPart(model)
        if not root then
            pcall(function()
                model:WaitForChild("HumanoidRootPart", 3)
            end)
            root = getAIBotRootPart(model)
        end
        local humanoid = getAIBotHumanoid(model)
        if not humanoid then
            pcall(function()
                model:WaitForChild("Humanoid", 3)
            end)
            humanoid = getAIBotHumanoid(model)
        end
        if not root or not humanoid then return end
        if _G.AIBotTracker.TrackedBots[model] then return end
        local espHolder = GetOrCreateCoreGuiObject("ESPHolder", "ScreenGui")
    local botESP = CreateInstance("Folder", {
        Name = "AIBot_" .. model.Name .. "_" .. tostring(model:GetDebugId()),
        Parent = espHolder
    })
    local Name = CreateEspLabel(botESP, UDim2.new(0.5, 0, 0, -11), ESP.Drawing.Names.RGB, ESP.Drawing.Names.Enabled, true)
    Name.Text = string.format('(<font color="rgb(%d, %d, %d)">AI</font>) %s', 0, 137, 182, model.Name)
    local Distance = CreateEspLabel(botESP, UDim2.new(0.5, 0, 0, 11), ESP.Drawing.Distances.RGB, ESP.Drawing.Distances.Enabled, true)
    local Weapon = CreateEspLabel(botESP, UDim2.new(0.5, 0, 0, 21), ESP.Drawing.Weapons.WeaponTextRGB, ESP.Drawing.Weapons.Enabled, false)
    local Box = CreateInstance("Frame", {
        Parent = botESP,
        BackgroundTransparency = 1,
        ClipsDescendants = true,
        Visible = ESP.Drawing.Boxes.Full.Enabled
    })
    local BoxImage = CreateInstance("ImageLabel", {
        Parent = botESP,
        Name = "BoxImage",
        BackgroundTransparency = 1,
        BorderSizePixel = 0,
        Position = UDim2.new(0, 0, 0, 0),
        Size = UDim2.new(0, 0, 0, 0),
        ZIndex = 20,
        Visible = false,
        Image = "",
        ImageTransparency = 1,
        ImageColor3 = Color3.fromRGB(255, 255, 255),
        ScaleType = Enum.ScaleType.Fit
    })
    local _boxImageLastVisible = false
    local _boxImageLastRaw = nil
    local _boxImageLastSource = nil
    local _boxImageLastTransp = nil
    local _boxImageLastColor = nil
    local _boxImageLastScale = nil
    local _boxImageLastX, _boxImageLastY, _boxImageLastW, _boxImageLastH = nil, nil, nil, nil
    local Gradient1 = CreateInstance("UIGradient", {
        Parent = Box,
        Enabled = ESP.Drawing.Boxes.GradientFill,
        Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientFillRGB1),
            ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientFillRGB2)
        }
    })
    local Outline = CreateInstance("UIStroke", {
        Parent = Box,
        Enabled = ESP.Drawing.Boxes.Gradient,
        Transparency = 0,
        Color = Color3.fromRGB(255, 255, 255),
        LineJoinMode = Enum.LineJoinMode.Miter
    })
    local Gradient2 = CreateInstance("UIGradient", {
        Parent = Outline,
        Enabled = ESP.Drawing.Boxes.Gradient,
        Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientRGB1),
            ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientRGB2)
        }
    })
    local cornerLines = {}
    local cornerGradients = {}
    local function createCornerLine(name)
        local line = CreateInstance("Frame", {
            Parent = Box,
            Name = name,
            BackgroundColor3 = ESP.Drawing.Boxes.Full.RGB or Color3.fromRGB(255, 255, 255),
            BackgroundTransparency = 0,
            BorderSizePixel = 0,
            Visible = false,
            ZIndex = 2
        })
        local grad = CreateInstance("UIGradient", {
            Parent = line,
            Enabled = false,
            Rotation = -45,
            Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientRGB1),
                ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientRGB2)
            }
        })
        cornerLines[name] = line
        cornerGradients[name] = grad
    end
    createCornerLine("CornerTopLeftH")
    createCornerLine("CornerTopLeftV")
    createCornerLine("CornerTopRightH")
    createCornerLine("CornerTopRightV")
    createCornerLine("CornerBottomLeftH")
    createCornerLine("CornerBottomLeftV")
    createCornerLine("CornerBottomRightH")
    createCornerLine("CornerBottomRightV")
    local Healthbar = CreateInstance("Frame", {
        Parent = botESP,
        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
        BackgroundTransparency = 0,
        Name = "Healthbar",
        Visible = ESP.Drawing.Healthbar.Enabled
    })
    local BehindHealthbar = CreateInstance("Frame", {
        Parent = botESP,
        ZIndex = -1,
        BackgroundColor3 = Color3.fromRGB(0, 0, 0),
        BackgroundTransparency = 0,
        Name = "BehindHealthbar",
        Visible = ESP.Drawing.Healthbar.Enabled
    })
    CreateInstance("UIGradient", {
        Parent = Healthbar,
        Enabled = ESP.Drawing.Healthbar.Gradient,
        Rotation = -90,
        Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, ESP.Drawing.Healthbar.GradientRGB1),
            ColorSequenceKeypoint.new(1, ESP.Drawing.Healthbar.GradientRGB2)
        }
    })
    local HealthText = CreateEspLabel(botESP, UDim2.new(0.5, 0, 0, 31), Color3.fromRGB(255, 255, 255), ESP.Drawing.Healthbar.HealthText, false)
    local Chams = CreateInstance("Highlight", { Parent = botESP })
    Chams.FillTransparency = ESP.Drawing.Chams.Fill_Transparency / 100
    Chams.OutlineTransparency = ESP.Drawing.Chams.Outline_Transparency / 100
    Chams.FillColor = ESP.Drawing.Chams.FillRGB
    Chams.OutlineColor = ESP.Drawing.Chams.OutlineRGB
    Chams.DepthMode = ESP.Drawing.Chams.XRay and "AlwaysOnTop" or (ESP.Drawing.Chams.VisibleCheck and "Occluded" or "AlwaysOnTop")
    Chams.Enabled = ESP.Drawing.Chams.Enabled
    Chams.Adornee = model
    local function HideESP()
        HideGuiObjects(botESP)
        _boxImageLastVisible = false
        _boxImageLastRaw = nil
        _boxImageLastSource = nil
        _boxImageLastTransp = nil
        _boxImageLastColor = nil
        _boxImageLastScale = nil
        _boxImageLastX, _boxImageLastY, _boxImageLastW, _boxImageLastH = nil, nil, nil, nil
        if not model or not model.Parent then
            botESP:Destroy()
        end
    end
    local RotationAngle, Tick = -45, tick()
    local connection
    connection = RunService.RenderStepped:Connect(function()
        local lp2 = Players.LocalPlayer
        if lp2 then
            if model == lp2.Character or model.Name == lp2.Name or (lp2.Character and (model:IsDescendantOf(lp2.Character) or lp2.Character:IsDescendantOf(model))) then
                HideESP()
                if connection then
                    connection:Disconnect()
                end
                _G.AIBotTracker.TrackedBots[model] = nil
                return
            end
        end
        local HRP = getAIBotRootPart(model)
        local Humanoid = getAIBotHumanoid(model)
        if not ESP.ShowAIBots or not model or not model.Parent or not HRP or not Humanoid then
            HideESP()
            if connection then
                connection:Disconnect()
            end
            _G.AIBotTracker.TrackedBots[model] = nil
            return
        end
        if not ESP.Enabled then
            HideESP()
            return
        end
        if Humanoid.Health <= 0 then
            HideESP()
            return
        end
        local Cam = Workspace.CurrentCamera
        local Pos, OnScreen = Cam:WorldToViewportPoint(HRP.Position)
        local Dist = (Cam.CFrame.Position - HRP.Position).Magnitude / allvars._units.studsPerMeter
        if OnScreen and Dist <= ESP.MaxDistance then
            local boxType = tostring(ESP.Drawing.Boxes.BoxType or "Default")
            local boxTypeKey = boxType:lower():gsub("%s+", "")
            local useCorner = (boxTypeKey == "corner")
            local useDynamic = ESP.Drawing.Boxes.Dynamic and true or false
            local w, hAdj
            local centerX, centerY = Pos.X, Pos.Y
            local yTopRaw, yBottomRaw
            if useDynamic then
                local parts = GetCachedBodyParts(model)
                local minX, maxX, minYRaw, maxYRaw = ComputeViewportBoundsFromParts(parts, Cam)
                if minX and maxX and minYRaw and maxYRaw and minX < maxX and minYRaw < maxYRaw then
                    w = maxX - minX
                    centerX = (minX + maxX) * 0.5
                    centerY = (minYRaw + maxYRaw) * 0.5
                    yTopRaw, yBottomRaw = minYRaw, maxYRaw
                end
            end
            if not w or not yTopRaw or not yBottomRaw then
                local Size = HRP.Size.Y
                local realDist = (Cam.CFrame.Position - HRP.Position).Magnitude
                local baseFOV = 70
                local fovCompensation = math.tan(math.rad(baseFOV) / 2) / math.tan(math.rad(Cam.FieldOfView) / 2)
                local fixedScaleFactor = (Size * Cam.ViewportSize.Y) / (realDist * 2) * fovCompensation
                local h = 4.5 * fixedScaleFactor
                w = 3 * fixedScaleFactor
                yTopRaw = centerY - h / 2
                yBottomRaw = centerY + h / 2
            end
            local yTop = ApplyResolutionStretchY(yTopRaw, Cam)
            local yBottom = ApplyResolutionStretchY(yBottomRaw, Cam)
            hAdj = yBottom - yTop
            Box.Position = UDim2.new(0, centerX - w / 2, 0, yTop)
            Box.Size = UDim2.new(0, w, 0, hAdj)
            local boxOn = ESP.Drawing.Boxes.Full.Enabled and true or false
            Box.Visible = boxOn
            local imgCfg = ESP.Drawing.Boxes.Image
            if BoxImage then
                local x = centerX - w / 2
                local y = yTop
                if _boxImageLastX ~= x or _boxImageLastY ~= y or _boxImageLastW ~= w or _boxImageLastH ~= hAdj then
                    _boxImageLastX, _boxImageLastY, _boxImageLastW, _boxImageLastH = x, y, w, hAdj
                    BoxImage.Position = UDim2.new(0, x, 0, y)
                    BoxImage.Size = UDim2.new(0, w, 0, hAdj)
                end
                local show = (boxOn and imgCfg and imgCfg.Enabled and imgCfg.Image and imgCfg.Image ~= "") and true or false
                if show then
                    if not _boxImageLastVisible then
                        _boxImageLastVisible = true
                        BoxImage.Visible = true
                    end
                    local raw = tostring(imgCfg.Image)
                    if raw ~= _boxImageLastRaw then
                        _boxImageLastRaw = raw
                        local src = (ESP._ui and ESP._ui._getBoxImageLabelSource and ESP._ui._getBoxImageLabelSource(raw)) or raw
                        _boxImageLastSource = src
                        BoxImage.Image = src
                    end
                    local tr = math.clamp(imgCfg.Transparency or 0.35, 0, 1)
                    if tr ~= _boxImageLastTransp then
                        _boxImageLastTransp = tr
                        BoxImage.ImageTransparency = tr
                    end
                    local col = imgCfg.Color or Color3.fromRGB(255, 255, 255)
                    if col ~= _boxImageLastColor then
                        _boxImageLastColor = col
                        BoxImage.ImageColor3 = col
                    end
                    local st = imgCfg.ScaleType or Enum.ScaleType.Stretch
                    if st ~= _boxImageLastScale then
                        _boxImageLastScale = st
                        BoxImage.ScaleType = st
                    end
                else
                    if _boxImageLastVisible then
                        _boxImageLastVisible = false
                        BoxImage.Visible = false
                    end
                end
            end
            Outline.Enabled = (not useCorner) and true or false
            Gradient2.Enabled = (not useCorner) and (ESP.Drawing.Boxes.Gradient and true or false)
            if not useCorner then
                if ESP.Drawing.Boxes.Gradient then
                    Outline.Color = Color3.fromRGB(255, 255, 255)
                else
                    Outline.Color = ESP.Drawing.Boxes.Full.RGB or Color3.fromRGB(255, 255, 255)
                end
            end
            for _, line in pairs(cornerLines) do
                line.Visible = boxOn and useCorner
            end
            if useCorner and boxOn then
                local thickness = 2
                local cornerLen = math.floor(math.clamp(math.min(w, hAdj) * 0.25, 6, 18))
                cornerLines.CornerTopLeftH.Position = UDim2.new(0, 0, 0, 0)
                cornerLines.CornerTopLeftH.Size = UDim2.new(0, cornerLen, 0, thickness)
                cornerLines.CornerTopLeftV.Position = UDim2.new(0, 0, 0, 0)
                cornerLines.CornerTopLeftV.Size = UDim2.new(0, thickness, 0, cornerLen)
                cornerLines.CornerTopRightH.Position = UDim2.new(1, -cornerLen, 0, 0)
                cornerLines.CornerTopRightH.Size = UDim2.new(0, cornerLen, 0, thickness)
                cornerLines.CornerTopRightV.Position = UDim2.new(1, -thickness, 0, 0)
                cornerLines.CornerTopRightV.Size = UDim2.new(0, thickness, 0, cornerLen)
                cornerLines.CornerBottomLeftH.Position = UDim2.new(0, 0, 1, -thickness)
                cornerLines.CornerBottomLeftH.Size = UDim2.new(0, cornerLen, 0, thickness)
                cornerLines.CornerBottomLeftV.Position = UDim2.new(0, 0, 1, -cornerLen)
                cornerLines.CornerBottomLeftV.Size = UDim2.new(0, thickness, 0, cornerLen)
                cornerLines.CornerBottomRightH.Position = UDim2.new(1, -cornerLen, 1, -thickness)
                cornerLines.CornerBottomRightH.Size = UDim2.new(0, cornerLen, 0, thickness)
                cornerLines.CornerBottomRightV.Position = UDim2.new(1, -thickness, 1, -cornerLen)
                cornerLines.CornerBottomRightV.Size = UDim2.new(0, thickness, 0, cornerLen)
                local useGrad = ESP.Drawing.Boxes.Gradient and true or false
                local rot = ESP.Drawing.Boxes.Animate and RotationAngle or -45
                local c1 = ESP.Drawing.Boxes.GradientRGB1
                local c2 = ESP.Drawing.Boxes.GradientRGB2
                local solid = ESP.Drawing.Boxes.Full.RGB or Color3.fromRGB(255, 255, 255)
                ApplyUnifiedCornerGradient(cornerLines, cornerGradients, w, hAdj, thickness, cornerLen, rot, useGrad, c1, c2, solid)
            end
            Gradient1.Enabled = (ESP.Drawing.Boxes.Filled.Enabled and ESP.Drawing.Boxes.GradientFill) and true or false
            Gradient1.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientFillRGB1),
                ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientFillRGB2)
            }
            Gradient2.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientRGB1),
                ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientRGB2)
            }
            if ESP.Drawing.Boxes.Filled.Enabled then
                if ESP.Drawing.Boxes.GradientFill then
                    Box.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    Box.BackgroundTransparency = ESP.Drawing.Boxes.Filled.Transparency
                else
                    Box.BackgroundColor3 = ESP.Drawing.Boxes.Filled.RGB or Color3.fromRGB(0, 0, 0)
                    Box.BackgroundTransparency = ESP.Drawing.Boxes.Filled.Transparency
                end
            else
                Box.BackgroundTransparency = 1
            end
            RotationAngle = RotationAngle + (tick() - Tick) * ESP.Drawing.Boxes.RotationSpeed * math.cos(math.pi / 4 * tick() - math.pi / 2)
            if ESP.Drawing.Boxes.Animate then
                Gradient1.Rotation = RotationAngle
                Gradient2.Rotation = RotationAngle
            else
                Gradient1.Rotation = -45
                Gradient2.Rotation = -45
            end
            Tick = tick()
            Name.Position = UDim2.new(0, centerX, 0, ApplyResolutionStretchY(yTopRaw - 9, Cam))
            Name.Visible = ESP.Drawing.Names.Enabled
            if ESP.Drawing.Distances.Enabled then
                Distance.TextColor3 = ESP.Drawing.Distances.RGB
                if ESP.Drawing.Distances.Position == "Bottom" then
                    Distance.Position = UDim2.new(0, centerX, 0, ApplyResolutionStretchY(yBottomRaw + 7, Cam))
                    Distance.Text = string.format("%dm", math.floor(Dist))
                    Distance.Visible = true
                elseif ESP.Drawing.Distances.Position == "Text" then
                    Distance.Visible = false
                    Name.Text = string.format('(<font color="rgb(%d, %d, %d)">AI</font>) %s [%dm]', 0, 137, 182, model.Name, math.floor(Dist))
                end
            end
            if ESP.Drawing.Weapons.Enabled then
                local currentGun = "None"
                local gunIcon = nil
                local gun, gunModel = nil, nil
                if model:FindFirstChild("Inventory") then
                     for _, item in pairs(model.Inventory:GetChildren()) do
                         if item:FindFirstChild("ItemProperties") and item.ItemProperties:GetAttribute("Equipped") then
                             currentGun = item.Name
                             break
                         end
                     end
                end
                if currentGun == "None" then
                     for _, child in pairs(model:GetChildren()) do
                         if child:IsA("Model") and (child.Name:find("Gun") or child.Name:find("Rifle") or child.Name:find("Pistol")) then
                             currentGun = child.Name
                             break
                         end
                     end
                end
                Weapon.TextColor3 = ESP.Drawing.Weapons.WeaponTextRGB
                Weapon.Text = currentGun
                Weapon.Position = UDim2.new(0, centerX, 0, ApplyResolutionStretchY(yBottomRaw + 20, Cam))
                Weapon.Visible = true
            else
                Weapon.Visible = false
            end
            if ESP.Drawing.Healthbar.Enabled then
                local Health = Humanoid.Health / Humanoid.MaxHealth
                BehindHealthbar.Position = UDim2.new(0, centerX - w / 2 - 6, 0, yTop)
                BehindHealthbar.Size = UDim2.new(0, ESP.Drawing.Healthbar.Width, 0, hAdj)
                BehindHealthbar.Visible = true
                Healthbar.Position = UDim2.new(0, centerX - w / 2 - 6, 0, yTop + hAdj * (1 - Health))
                Healthbar.Size = UDim2.new(0, ESP.Drawing.Healthbar.Width, 0, hAdj * Health)
                Healthbar.Visible = true
                if ESP.Drawing.Healthbar.HealthText then
                    local healthPercentage = math.floor(Humanoid.Health / Humanoid.MaxHealth * 100)
                    HealthText.Position = UDim2.new(0, centerX - w / 2 - 6, 0, yTop + hAdj * (1 - healthPercentage / 100) + 3)
                    HealthText.Text = tostring(healthPercentage)
                    HealthText.Visible = Humanoid.Health < Humanoid.MaxHealth
                end
            end
            local chamsMaxDist = ESP.Drawing.Chams.MaxDistance or ESP.MaxDistance
            if ESP.Drawing.Chams.Enabled and Dist <= chamsMaxDist then
                Chams.Adornee = model
                Chams.FillColor = ESP.Drawing.Chams.FillRGB
                Chams.OutlineColor = ESP.Drawing.Chams.OutlineRGB
                Chams.Enabled = true
                Chams.FillTransparency = ESP.Drawing.Chams.Fill_Transparency / 100
                Chams.OutlineTransparency = ESP.Drawing.Chams.Outline_Transparency / 100
                if ESP.Drawing.Chams.XRay then
                    Chams.DepthMode = "AlwaysOnTop"
                else
                    Chams.DepthMode = ESP.Drawing.Chams.VisibleCheck and "Occluded" or "AlwaysOnTop"
                end
            else
                Chams.Enabled = false
            end
        else
            HideESP()
        end
    end)
    _G.AIBotTracker.TrackedBots[model] = {ESP = botESP, Connection = connection}
end
local function StartAIBotESP()
    pcall(function()
        for _, model in pairs(workspace:GetDescendants()) do
            if model:IsA("Model") and getAIBotHumanoid(model) and getAIBotRootPart(model) then
                if not Players:GetPlayerFromCharacter(model) then
                    createAIBotESP(model)
                end
            end
        end
    end)
    if _G.AIBotTracker.Connection then
        _G.AIBotTracker.Connection:Disconnect()
    end
    _G.AIBotTracker.Connection = workspace.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("Model") then
             task.spawn(function()
                createAIBotESP(descendant)
             end)
        elseif descendant:IsA("Humanoid") or descendant.Name == "HumanoidRootPart" then
            if descendant.Parent and descendant.Parent:IsA("Model") then
                task.spawn(function()
                     createAIBotESP(descendant.Parent)
                end)
            end
        end
    end)
end
local function StopAIBotESP()
    if _G.AIBotTracker.Connection then
        _G.AIBotTracker.Connection:Disconnect()
        _G.AIBotTracker.Connection = nil
    end
    pcall(function()
        for model, data in pairs(_G.AIBotTracker.TrackedBots) do
            if data.Connection then
                data.Connection:Disconnect()
            end
            if data.ESP and data.ESP.Parent then
                data.ESP:Destroy()
            end
        end
        _G.AIBotTracker.TrackedBots = {}
    end)
end
if ESP.ShowAIBots then
    StartAIBotESP()
end
ESP._unloadedPlayers = ESP._unloadedPlayers or {
    Enabled = false,
    Cache = setmetatable({}, { __mode = "k" }),
    Holder = nil,
    Connection = nil,
    NextUpdate = 0,
    UpdateRate = 0.05
}
do
    local mod = ESP._unloadedPlayers
    function mod:_coerceVector3(v)
        if typeof(v) == "Vector3" then
            return v
        end
        if type(v) == "string" then
            local x, y, z = v:match("([%-%d%.]+)%s*,%s*([%-%d%.]+)%s*,%s*([%-%d%.]+)")
            x, y, z = tonumber(x), tonumber(y), tonumber(z)
            if x and y and z then
                return Vector3.new(x, y, z)
            end
        end
        if type(v) == "table" then
            local x = tonumber(v.X or v.x)
            local y = tonumber(v.Y or v.y)
            local z = tonumber(v.Z or v.z)
            if x and y and z then
                return Vector3.new(x, y, z)
            end
        end
        return nil
    end
    function mod:_getLastVerifiedPosForPlayer(plr)
        local rp = game:GetService("ReplicatedStorage")
        local playersFolder = rp:FindFirstChild("Players")
        local pinfo = playersFolder and playersFolder:FindFirstChild(plr.Name)
        local status = pinfo and pinfo:FindFirstChild("Status")
        local uac = status and status:FindFirstChild("UAC")
        if not uac then
            return nil
        end
        return self:_coerceVector3(uac:GetAttribute("LastVerifiedPos"))
    end
    function mod:_getOrCreateLabel(plr)
        if not self.Holder or not self.Holder.Parent then
            self.Holder = GetOrCreateCoreGuiObject("ESPUnloadedHolder", "ScreenGui")
        end
        local cached = self.Cache[plr]
        if cached and cached.Label and cached.Label.Parent then
            return cached
        end
        local label = CreateInstance("TextLabel", {
            Parent = self.Holder,
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            Font = Enum.Font.SourceSansBold,
            TextSize = 13,
            TextStrokeTransparency = 0,
            TextStrokeColor3 = Color3.fromRGB(0, 0, 0),
            RichText = false,
            AnchorPoint = Vector2.new(0.5, 0.5),
            Size = UDim2.fromOffset(260, 18),
            Visible = false,
            ZIndex = 500
        })
        local data = { Label = label, LastSeen = tick() }
        self.Cache[plr] = data
        return data
    end
    function mod:_destroyLabel(plr)
        local data = self.Cache[plr]
        if data then
            if data.Label then
                pcall(function() data.Label:Destroy() end)
            end
            self.Cache[plr] = nil
        end
    end
    function mod:_isPlayerLoaded(plr)
        local char = plr and plr.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        return hrp and hrp:IsDescendantOf(workspace)
    end
    function mod:Start()
        self.Enabled = true
        if self.Connection then
            self.Connection:Disconnect()
            self.Connection = nil
        end
        self.Holder = GetOrCreateCoreGuiObject("ESPUnloadedHolder", "ScreenGui")
        self.NextUpdate = 0
        self.Connection = _G.allvars._rt.track(RunService.RenderStepped:Connect(function()
            if not self.Enabled then
                return
            end
            if not ESP or not ESP.ShowUnloadedPlayers then
                return
            end
            local cam = workspace.CurrentCamera
            if not cam then
                return
            end
            local now = tick()
            if now < (self.NextUpdate or 0) then
                return
            end
            self.NextUpdate = now + (self.UpdateRate or 0.15)
            local vp = cam.ViewportSize
            local margin = 18
            local lp = Players.LocalPlayer
            local lpChar = lp and lp.Character
            local lpHrp = lpChar and lpChar:FindFirstChild("HumanoidRootPart")
            local lpPos = lpHrp and lpHrp.Position or cam.CFrame.Position
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= lp then
                    if self:_isPlayerLoaded(plr) then
                        self:_destroyLabel(plr)
                    else
                        local lastPos = self:_getLastVerifiedPosForPlayer(plr)
                        if lastPos then
                            local data = self:_getOrCreateLabel(plr)
                            local label = data.Label
                            local pos, onScreen = cam:WorldToViewportPoint(lastPos)
                            local distStuds = (lpPos - lastPos).Magnitude
                            local distM = distStuds / ((allvars and allvars._units and allvars._units.studsPerMeter) or 3.5714285714)
                            if onScreen and pos.Z > 0 then
                                label.Position = UDim2.fromOffset(pos.X, pos.Y)
                                label.Text = plr.Name .. " [" .. tostring(math.floor(distM + 0.5)) .. "m]"
                                local c = (ESP.Drawing and ESP.Drawing.Names and ESP.Drawing.Names.RGB) or Color3.fromRGB(255, 255, 255)
                                label.TextColor3 = c
                                label.Visible = true
                            else
                                label.Visible = false
                            end
                            data.LastSeen = now
                        else
                            self:_destroyLabel(plr)
                        end
                    end
                end
            end
            for plr, data in pairs(self.Cache) do
                if typeof(plr) ~= "Instance" or not plr.Parent then
                    self:_destroyLabel(plr)
                else
                    local label = data and data.Label
                    if label and label.Parent then
                        local stale = (now - (data.LastSeen or 0)) > 2
                        if stale then
                            label.Visible = false
                        end
                    end
                end
            end
        end))
    end
    function mod:Stop()
        self.Enabled = false
        if self.Connection then
            self.Connection:Disconnect()
            self.Connection = nil
        end
        for plr, _ in pairs(self.Cache) do
            self:_destroyLabel(plr)
        end
        self.Cache = setmetatable({}, { __mode = "k" })
        if self.Holder then
            pcall(function() self.Holder:Destroy() end)
            self.Holder = nil
        end
    end
end
sections.ESPMain:Toggle({
    Name = "Show AI",
    Default = false,
    Callback = function(value)
        ESP.ShowAIBots = value
        if value then
            StartAIBotESP()
        else
            StopAIBotESP()
        end
    end
}, "ESPShowAIBots")
sections.ESPMain:Toggle({
    Name = "Show Unloaded",
    Default = false,
    Callback = function(value)
        ESP.ShowUnloadedPlayers = value
        if value then
            if ESP._unloadedPlayers and ESP._unloadedPlayers.Start then
                ESP._unloadedPlayers:Start()
            end
        else
            if ESP._unloadedPlayers and ESP._unloadedPlayers.Stop then
                ESP._unloadedPlayers:Stop()
            end
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "ESPShowUnloadedPlayers")
sections.ESPMain:Toggle({
    Name = "Visibility prefix",
    Default = (ESP.Options and ESP.Options.VisibleCheck ~= false) or true,
    Callback = function(value)
        ESP.Options = ESP.Options or {}
        ESP.Options.VisibleCheck = value
    end
}, "ESPVisibilityPrefix")
sections.ESPMain:Slider({
    Name = "Max Distance",
    Default = ESP.MaxDistance,
    Minimum = 100,
    Maximum = 10000,
    Precision = 0,
    Callback = function(value)
        ESP.MaxDistance = value
    end
}, "ESPMaxDistance")
ForceESPRefresh = function()
    ESP.Initialized = false
    pcall(function()
        local oldGui = CoreGui:FindFirstChild("ESPHolder")
        if oldGui then
            oldGui:Destroy()
        end
    end)
    if ESP.Skeletons then
        for player, skeleton in pairs(ESP.Skeletons) do
            for name, element in pairs(skeleton) do
                if type(name) == "string" and name ~= "lastPlayerPos" and name ~= "lastUpdate" and name ~= "lastFoV" and name ~= "lastCamPos" then
                    pcall(function()
                        if element and typeof(element) ~= "table" and type(element) ~= "number" and element.Visible ~= nil then
                            element.Visible = false
                        end
                    end)
                end
            end
        end
    end
    if ESP.GazeLines then
        for _, line in pairs(ESP.GazeLines) do
            line.Visible = false
        end
    end
    wait(0.1)
end
if not _G.ExtractESP then _G.ExtractESP = {} end
if not _G.ExtractUpdateConnection then _G.ExtractUpdateConnection = nil end
local function updateExtractESP()
    if not ESP.Enabled or not allvars.espextract then return end
    for extract, info in pairs(_G.ExtractESP) do
        if not extract or not extract.Parent then
            if info.nameLabel then
                info.nameLabel.Visible = false
                info.nameLabel:Remove()
            end
            if info.distanceLabel then
                info.distanceLabel.Visible = false
                info.distanceLabel:Remove()
            end
            _G.ExtractESP[extract] = nil
        else
            local character = localplayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local distance = (character.HumanoidRootPart.Position - extract.Position).Magnitude
                local distanceM = distance / allvars._units.studsPerMeter
                if distanceM <= ESP.MaxDistance then
                    local onScreen, screenPos = pcall(function()
                        return wcamera:WorldToViewportPoint(extract.Position)
                    end)
                    if onScreen and screenPos and screenPos.Z > 0 then
                        if info.nameLabel then
                            local y = screenPos.Y - 20
                            info.nameLabel.Position = Vector2.new(screenPos.X, ApplyResolutionStretchY(y, wcamera))
                            info.nameLabel.Visible = true
                        end
                        if info.distanceLabel then
                            local dist = math.floor(distance / allvars._units.studsPerMeter)
                            info.distanceLabel.Text = dist .. "M"
                            local y = screenPos.Y
                            info.distanceLabel.Position = Vector2.new(screenPos.X, ApplyResolutionStretchY(y, wcamera))
                            info.distanceLabel.Visible = true
                        end
                    else
                        if info.nameLabel then info.nameLabel.Visible = false end
                        if info.distanceLabel then info.distanceLabel.Visible = false end
                    end
                else
                    if info.nameLabel then info.nameLabel.Visible = false end
                    if info.distanceLabel then info.distanceLabel.Visible = false end
                end
            end
        end
    end
end
local function scanForExtracts()
    if not ESP.Enabled or not allvars.espextract then return end
    if not localplayer.Character then return end
    local exitLocations = workspace:FindFirstChild("NoCollision")
    if not exitLocations then return end
    exitLocations = exitLocations:FindFirstChild("ExitLocations")
    if not exitLocations then return end
    for _, extract in pairs(exitLocations:GetChildren()) do
        if not _G.ExtractESP[extract] then
            local nameLabel = Drawing.new("Text")
            nameLabel.Text = extract.Name .. ""
            nameLabel.Size = 18
            nameLabel.Center = true
            nameLabel.Outline = true
            nameLabel.Font = 3
            nameLabel.Color = Color3.fromRGB(0, 255, 0)
            nameLabel.OutlineColor = Color3.new(0, 0, 0)
            nameLabel.Visible = false
            local distanceLabel = Drawing.new("Text")
            distanceLabel.Size = 16
            distanceLabel.Center = true
            distanceLabel.Outline = true
            distanceLabel.Font = 3
            distanceLabel.Color = Color3.fromRGB(0, 255, 0)
            distanceLabel.OutlineColor = Color3.new(0, 0, 0)
            distanceLabel.Visible = false
            _G.ExtractESP[extract] = {
                nameLabel = nameLabel,
                distanceLabel = distanceLabel,
            }
        end
    end
end
if _G.ExtractUpdateConnection then
    _G.ExtractUpdateConnection:Disconnect()
    _G.ExtractUpdateConnection = nil
end
_G.ExtractUpdateConnection = RunService.RenderStepped:Connect(function()
    if ESP.Enabled and allvars.espextract then
        updateExtractESP()
    end
end)
spawn(function()
    while wait(10) do
        if ESP.Enabled and allvars.espextract then
            scanForExtracts()
        end
    end
end)
if ESP.Enabled and allvars.espextract then
    scanForExtracts()
end
sections.ESPName:Header({ Text = "Name" })
sections.ESPName:Toggle({
    Name = "Names",
    Default = ESP.Drawing.Names.Enabled,
    Callback = function(value)
        ESP.Drawing.Names.Enabled = value
        ESP._ui._syncESPVisibility()
    end
}, "ESPNames")
sections.ESPDistance:Header({ Text = "Distance" })
sections.ESPDistance:Toggle({
    Name = "Distance",
    Default = ESP.Drawing.Distances.Enabled,
    Callback = function(value)
        ESP.Drawing.Distances.Enabled = value
        ESP._ui._syncESPVisibility()
    end
}, "ESPDistance")
sections.ESPWeapon:Header({ Text = "Weapon" })
sections.ESPWeapon:Toggle({
    Name = "Weapon",
    Default = ESP.Drawing.Weapons.Enabled,
    Callback = function(value)
        ESP.Drawing.Weapons.Enabled = value
        ESP._ui._syncESPVisibility()
    end
}, "ESPWeapon")
ESP._ui.weaponAmmoToggleEl = sections.ESPWeapon:Toggle({
    Name = "Show Ammo",
    Default = ESP.Drawing.Weapons.Ammo,
    Callback = function(value)
        ESP.Drawing.Weapons.Ammo = value
    end
}, "ESPWeaponAmmo")
sections.ESPHealth:Header({ Text = "Health" })
sections.ESPHealth:Toggle({
    Name = "Healthbar",
    Default = ESP.Drawing.Healthbar.Enabled,
    Callback = function(value)
        ESP.Drawing.Healthbar.Enabled = value
        ESP._ui._syncESPVisibility()
    end
}, "ESPHealthbar")
sections.ESPChams:Header({ Text = "Chams" })
sections.ESPChams:Toggle({
    Name = "Chams",
    Default = ESP.Drawing.Chams.Enabled,
    Callback = function(value)
        ChamsToggleState = value
        local ct = tostring(CurrentChamsType)
        local ctl = ct:lower()
        if ctl == "opaque force field" or ctl == "force field" or ctl == "model" then
            if ESP._GalaxyChams_Stop then
                ESP._GalaxyChams_Stop()
            end
            if value then
                StopBeastChams()
                StartBeastChams(true)
            else
                StopBeastChams()
            end
        elseif ctl == "galaxy" then
            StopBeastChams()
            ESP.Drawing.Chams.Enabled = false
            if value then
                if ESP._GalaxyChams_Start then
                    ESP._GalaxyChams_Start()
                end
            else
                if ESP._GalaxyChams_Stop then
                    ESP._GalaxyChams_Stop()
                end
            end
        else
            StopBeastChams()
            if ESP._GalaxyChams_Stop then
                ESP._GalaxyChams_Stop()
            end
            ESP.Drawing.Chams.Enabled = value
        end
        ESP._ui._syncESPVisibility()
    end
}, "ESPChamsXRay")
ESP._ui.chamsTypeDropdownEl = sections.ESPChams:Dropdown({
    Name = "Chams Type",
    Multi = false,
    Required = true,
    Options = {"Default", "Opaque Force Field", "Force Field", "Model", "Galaxy"},
    Default = CurrentChamsType,
    Callback = function(value)
        local v = tostring(value)
        local vl = v:lower():gsub("%s+", "")
        if vl == "opaqueforcefield" then
            v = "Opaque Force Field"
        elseif vl == "forcefield" then
            v = "Force Field"
        elseif vl == "model" then
            v = "Model"
        end
        CurrentChamsType = v
        if type(_G) == "table" then
            _G.CurrentChamsType = v
        end
        if v == "Opaque Force Field" or v == "Force Field" or v == "Model" then
            ESP.Drawing.Chams.Enabled = false
            if ESP._GalaxyChams_Stop then
                ESP._GalaxyChams_Stop()
            end
            if ChamsToggleState then
                StopBeastChams()
                StartBeastChams(true)
            else
                StopBeastChams()
            end
        elseif v == "Galaxy" then
            StopBeastChams()
            ESP.Drawing.Chams.Enabled = false
            if ChamsToggleState then
                if ESP._GalaxyChams_Start then
                    ESP._GalaxyChams_Start()
                end
            else
                if ESP._GalaxyChams_Stop then
                    ESP._GalaxyChams_Stop()
                end
            end
        else
            StopBeastChams()
            if ESP._GalaxyChams_Stop then
                ESP._GalaxyChams_Stop()
            end
            ESP.Drawing.Chams.Enabled = ChamsToggleState
        end
        ESP._ui._syncESPVisibility()
    end
}, "ESPChamsType")
ESP._ui.chamsOriginalModelInvisibilityToggleEl = sections.ESPChams:Toggle({
    Name = "Original Model Invisibility",
    Default = ESP.Drawing.Chams.HideOriginalModels,
    Callback = function(value)
        ESP.Drawing.Chams.HideOriginalModels = value
        local ct = tostring(CurrentChamsType):lower():gsub("%s+", "")
        local isBeast = (ct == "opaqueforcefield" or ct == "forcefield" or ct == "model")
        local shouldHide = value and isBeast and ChamsToggleState
        local setHidden = ESP and ESP._BeastChams_SetHidden
        if setHidden then
            local Players = game:GetService("Players")
            local lp = Players.LocalPlayer
            for _, p in ipairs(Players:GetPlayers()) do
                if p ~= lp then
                    setHidden(p.Character, shouldHide)
                end
            end
        end
    end
}, "ESPChamsOriginalModelInvisibility")
ESP._ui.chamsXRayToggleEl = sections.ESPChams:Toggle({
    Name = "Chams X-Ray",
    Default = ESP.Drawing.Chams.XRay,
    Callback = function(value)
        ESP.Drawing.Chams.XRay = value
        if ESP.TrackedItems and type(ESP.TrackedItems) == "table" then
            for _, data in pairs(ESP.TrackedItems) do
                if data and data.Drawing and data.Drawing.Chams then
                    data.Drawing.Chams.DepthMode = value and "AlwaysOnTop" or (ESP.Drawing.Chams.VisibleCheck and "Occluded" or "AlwaysOnTop")
                end
            end
        end
    end
}, "ESPChamsXRayToggle")
ESP._ui.chamsTransparencySliderEl = sections.ESPChams:Slider({
    Name = "Chams Transparency",
    Default = 0.5,
    Minimum = 0,
    Maximum = 1,
    Precision = 2,
    Callback = function(value)
        allvars.espchamstransparency = value
        local pct = math.floor((value * 100) + 0.5)
        ESP.Drawing.Chams.Fill_Transparency = pct
        ESP.Drawing.Chams.Outline_Transparency = pct
        for _, highlight in pairs(ESP.Highlights or {}) do
            if highlight and highlight.FillTransparency ~= nil then
                highlight.FillTransparency = value
                highlight.OutlineTransparency = value
            end
        end
    end
}, "ESPChamsTransparency")
ESP._ui.chamsMaxDistanceSliderEl = sections.ESPChams:Slider({
    Name = "Chams Max Distance",
    Default = ESP.Drawing.Chams.MaxDistance,
    Minimum = 0,
    Maximum = 20000,
    Precision = 0,
    Callback = function(value)
        ESP.Drawing.Chams.MaxDistance = value
    end
}, "ESPChamsMaxDistance")
sections.ESPOther:Header({ Text = "Other" })
sections.ESPOther:Toggle({
    Name = "Mod Detector",
    Default = allvars.detectmods,
    Callback = function(value)
        allvars.detectmods = value
        if value then
             mdetect = false
             detectedmods = {}
             Window:Notify({
                Title = "Mod Detector",
                Description = "Enabled",
                Lifetime = 3
            })
        end
    end
}, "ESPModDetector")
sections.ESPArrows:Header({ Text = "Offscreen Arrows" })
sections.ESPArrows:Toggle({
    Name = "Enabled",
    Default = ESP.Drawing.Arrows.Enabled,
    Callback = function(value)
        ESP.Drawing.Arrows.Enabled = value
        ESP._ui._syncESPVisibility()
    end
}, "ESPOffscreenArrows")
ESP._ui.arrowColorPickerEl = sections.ESPArrows:Colorpicker({
    Name = "Arrow Color",
    Default = ESP.Drawing.Arrows.Color,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.Arrows.Color = color
    end
}, "ESPArrowColor")
ESP._ui.arrowRadiusSliderEl = sections.ESPArrows:Slider({
    Name = "Arrow Radius",
    Default = ESP.Drawing.Arrows.Radius,
    Minimum = 50,
    Maximum = 1000,
    Precision = 0,
    Callback = function(value)
        ESP.Drawing.Arrows.Radius = value
    end
}, "ESPArrowRadius")
ESP._ui.arrowSizeSliderEl = sections.ESPArrows:Slider({
    Name = "Arrow Size",
    Default = ESP.Drawing.Arrows.Size,
    Minimum = 10,
    Maximum = 100,
    Precision = 0,
    Callback = function(value)
        ESP.Drawing.Arrows.Size = value
    end
}, "ESPArrowSize")
sections.ESPInventoryValue:Header({
    Text = "Inventory Value"
})
sections.ESPInventoryValue:Toggle({
    Name = "Inventory Value",
    Default = false,
    Callback = function(value)
        ESP.ShowInventoryValue = value
        ESP._ui._syncESPVisibility()
    end
}, "ESPInventoryValue")
ESP._ui.inventoryValueColorPickerEl = sections.ESPInventoryValue:Colorpicker({
    Name = "Value Color",
    Default = ESP.Drawing.InventoryValue.RGB,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.InventoryValue.RGB = color
    end
}, "ESPInventoryValueColor")
sections.ESPOther:Toggle({
    Name = "look line",
    Default = false,
    Callback = function(value)
        ESP.Drawing.GazeLine.Enabled = value
        if not value and ESP.GazeLines then
            for _, line in pairs(ESP.GazeLines) do
                line.Visible = false
            end
        end
        ESP._ui._syncESPVisibility()
    end
}, "ESPGazeLine")
sections.ESPBox:Header({
    Text = "Box"
})
ESP._ui = ESP._ui or {}
ESP._ui._setVisible = ESP._ui._setVisible or function(el, state)
    if not el then return end
    local ok = pcall(function()
        if el.set_visible then
            el:set_visible(state)
            return
        end
        if el.SetVisibility then
            el:SetVisibility(state)
            return
        end
        if el.SetVisible then
            el:SetVisible(state)
            return
        end
        if el.Frame and el.Frame.Visible ~= nil then
            el.Frame.Visible = state
            return
        end
        if el.Container and el.Container.Visible ~= nil then
            el.Container.Visible = state
            return
        end
        if el.Instance and el.Instance.Visible ~= nil then
            el.Instance.Visible = state
            return
        end
        if typeof(el) == "Instance" and el.Visible ~= nil then
            el.Visible = state
            return
        end
    end)
    if not ok then
        pcall(function()
            if typeof(el) == "Instance" and el.Visible ~= nil then
                el.Visible = state
            end
        end)
    end
end
do
    local combatUI = _G.__RAIL_UI and _G.__RAIL_UI.combat
    if combatUI then
        combatUI.sync = combatUI.sync or function()
            if _G.__OBLIVION_CONFIG_LOADING == true then
                return
            end
            local setVisible = ESP and ESP._ui and ESP._ui._setVisible
            if not setVisible then return end
            local function resolveSectionFrame(sectionObj, preferredTexts)
                if not sectionObj then return nil end
                if typeof(sectionObj) == "Instance" then
                    return sectionObj
                end
                if type(sectionObj) ~= "table" then
                    return nil
                end
                if sectionObj.Frame and typeof(sectionObj.Frame) == "Instance" then
                    return sectionObj.Frame
                end
                if sectionObj.Container and typeof(sectionObj.Container) == "Instance" then
                    return sectionObj.Container
                end
                if sectionObj.Instance and typeof(sectionObj.Instance) == "Instance" then
                    return sectionObj.Instance
                end
                combatUI._resolvedSections = combatUI._resolvedSections or {}
                if combatUI._resolvedSections[sectionObj] then
                    return combatUI._resolvedSections[sectionObj]
                end
                local okDebug = (debug and debug.getupvalue) and true or false
                if okDebug then
                    local methods = { "Toggle", "Slider", "Header", "Dropdown", "Colorpicker", "ColorPicker", "Button", "Label", "Paragraph", "Keybind", "Input" }
                    for _, m in ipairs(methods) do
                        local fn = sectionObj[m]
                        if type(fn) == "function" then
                            for i = 1, 60 do
                                local ok, _, v = pcall(debug.getupvalue, fn, i)
                                if not ok then break end
                                if typeof(v) == "Instance" and v:IsA("Frame") then
                                    if v.Name == "Section" or v:FindFirstChild("SectionUIListLayout") then
                                        combatUI._resolvedSections[sectionObj] = v
                                        return v
                                    end
                                end
                            end
                        end
                    end
                end
                local targetTexts = {}
                if type(preferredTexts) == "table" then
                    for _, t in ipairs(preferredTexts) do
                        targetTexts[t] = true
                    end
                else
                    targetTexts["Target Settings"] = true
                    targetTexts["Hitsound Settings"] = true
                    targetTexts["Display Settings"] = true
                    targetTexts["FOV Settings"] = true
                end
                local roots = {}
                pcall(function()
                    table.insert(roots, game:GetService("CoreGui"))
                end)
                pcall(function()
                    local lp = game:GetService("Players").LocalPlayer
                    if lp then
                        table.insert(roots, lp:WaitForChild("PlayerGui", 1))
                    end
                end)
                for _, root in ipairs(roots) do
                    if root and root.GetDescendants then
                        for _, inst in ipairs(root:GetDescendants()) do
                            if inst:IsA("TextLabel") and targetTexts[inst.Text] then
                                local a = inst
                                for _ = 1, 16 do
                                    a = a.Parent
                                    if not a then break end
                                    if a:IsA("Frame") and a.Name == "Section" then
                                        combatUI._resolvedSections[sectionObj] = a
                                        return a
                                    end
                                end
                            end
                        end
                    end
                end
                return nil
            end
            local aimOn = aimbool and true or false
            if combatUI.aimTargetingSectionFrame and not combatUI.aimTargetingSectionFrame.Parent then
                combatUI.aimTargetingSectionFrame = nil
            end
            if combatUI.hitmarkerVisualsSectionFrame and not combatUI.hitmarkerVisualsSectionFrame.Parent then
                combatUI.hitmarkerVisualsSectionFrame = nil
            end
            if combatUI.aimVisualSectionFrame and not combatUI.aimVisualSectionFrame.Parent then
                combatUI.aimVisualSectionFrame = nil
            end
            combatUI.aimTargetingSectionFrame = combatUI.aimTargetingSectionFrame or resolveSectionFrame(combatUI.aimTargetingSectionEl, { "Target Settings" })
            combatUI.hitmarkerVisualsSectionFrame = combatUI.hitmarkerVisualsSectionFrame or resolveSectionFrame(combatUI.hitmarkerVisualsSectionEl, { "Hitsound Settings" })
            combatUI.aimVisualSectionFrame = combatUI.aimVisualSectionFrame or resolveSectionFrame(combatUI.aimVisualSectionEl, { "Display Settings", "FOV Settings" })
            setVisible(combatUI.aimTargetingSectionFrame, aimOn)
            setVisible(combatUI.hitmarkerVisualsSectionFrame, true)
            setVisible(combatUI.aimVisualSectionFrame, aimOn)
            setVisible(combatUI.aimPartDropdownEl, aimOn)
            local isMultipoint = (aimpart == "Multipoint") and true or false
            setVisible(combatUI.multipointHeadPercentSliderEl, aimOn and isMultipoint)
            setVisible(combatUI.multipointBodyPercentSliderEl, aimOn and isMultipoint)
            setVisible(combatUI.instaHitToggleEl, aimOn)
            setVisible(combatUI.hitChanceSliderEl, aimOn)
            setVisible(combatUI.aimVisCheckToggleEl, aimOn)
            setVisible(combatUI.aimPingCheckToggleEl, aimOn)
            setVisible(combatUI.aimDistCheckToggleEl, aimOn)
            setVisible(combatUI.aimTargetBotsToggleEl, aimOn)
            setVisible(combatUI.aimDistanceSliderEl, aimOn)
            setVisible(combatUI.showTargetNameToggleEl, aimOn)
            setVisible(combatUI.targetTrackerToggleEl, aimOn)
            setVisible(combatUI.showFovToggleEl, aimOn)
            local multiShotOn = multiShotEnabled and true or false
            setVisible(combatUI.multiShotAmountSliderEl, multiShotOn)
            local rapidFireOn = rapidFireEnabled and true or false
            setVisible(combatUI.rapidFireDelaySliderEl, rapidFireOn)
            local showFovOn = aimOn and (allvars and allvars.aimFovShow) and true or false
            setVisible(combatUI.aimFovSliderEl, showFovOn)
            setVisible(combatUI.fillFovToggleEl, showFovOn)
            setVisible(combatUI.fovThicknessSliderEl, showFovOn)
            setVisible(combatUI.fovGradientToggleEl, showFovOn)
            local fovGradOn = (allvars and allvars.aimFovGradient) and true or false
            setVisible(combatUI.fovGradientAnimateToggleEl, showFovOn and fovGradOn)
            setVisible(combatUI.fovGradient1PickerEl, showFovOn and fovGradOn)
            setVisible(combatUI.fovGradient2PickerEl, showFovOn and fovGradOn)
            setVisible(combatUI.fovTransparencySliderEl, showFovOn)
            setVisible(combatUI.fovColorPickerEl, showFovOn and (not fovGradOn))
            local hitsoundsOn = hitsoundbool and true or false
            setVisible(combatUI.headSoundDropdownEl, hitsoundsOn)
            setVisible(combatUI.bodySoundDropdownEl, hitsoundsOn)
        end
        pcall(function()
            combatUI.sync()
        end)
    end
end
ESP._ui._espBoxSetVisible = ESP._ui._espBoxSetVisible or ESP._ui._setVisible
ESP._ui._espBoxSyncPickerVisibility = function()
    local isGradient = ESP.Drawing.Boxes.Gradient and true or false
    local filledEnabled = ESP.Drawing.Boxes.Filled.Enabled and true or false
    local setVisible = ESP._ui._setVisible
    setVisible(ESP._ui.boxGradient1PickerEl, isGradient)
    setVisible(ESP._ui.boxGradient2PickerEl, isGradient)
    setVisible(ESP._ui.boxSolidPickerEl, not isGradient)
    setVisible(ESP._ui.filledBoxColorPickerEl, filledEnabled and (not isGradient))
    setVisible(ESP._ui.rotationSpeedSliderEl, ESP.Drawing.Boxes.Animate and true or false)
end
ESP._ui._espBoxSyncVisibility = function()
    local boxOn = ESP.Drawing.Boxes.Full.Enabled and true or false
    local setVisible = ESP._ui._setVisible
    setVisible(ESP._ui.filledBoxToggleEl, boxOn)
    if ESP._ui.boxTypeDropdownEl then
        setVisible(ESP._ui.boxTypeDropdownEl, boxOn)
    end
    if ESP._ui.dynamicBoxesToggleEl then
        setVisible(ESP._ui.dynamicBoxesToggleEl, boxOn)
    end
    if ESP._ui.boxImageToggleEl then
        setVisible(ESP._ui.boxImageToggleEl, boxOn)
    end
    local boxImageOn = boxOn and (ESP.Drawing.Boxes.Image and ESP.Drawing.Boxes.Image.Enabled) and true or false
    if ESP._ui.boxImagePresetDropdownEl then
        setVisible(ESP._ui.boxImagePresetDropdownEl, boxImageOn)
    end
    local customOn = boxImageOn and (ESP.Drawing.Boxes.Image and tostring(ESP.Drawing.Boxes.Image.Preset) == "Custom") and true or false
    if ESP._ui.boxImageCustomInputEl then
        setVisible(ESP._ui.boxImageCustomInputEl, customOn)
    end
    setVisible(ESP._ui.animatedBoxesToggleEl, boxOn)
    setVisible(ESP._ui.boxGradientToggleEl, boxOn)
    if not boxOn then
        setVisible(ESP._ui.filledBoxColorPickerEl, false)
        setVisible(ESP._ui.rotationSpeedSliderEl, false)
        setVisible(ESP._ui.boxSolidPickerEl, false)
        setVisible(ESP._ui.boxGradient1PickerEl, false)
        setVisible(ESP._ui.boxGradient2PickerEl, false)
        return
    end
    ESP._ui._espBoxSyncPickerVisibility()
end
ESP._ui.boxToggleEl = sections.ESPBox:Toggle({
    Name = "ESP Box",
    Default = ESP.Drawing.Boxes.Full.Enabled,
    Callback = function(value)
        ESP.Drawing.Boxes.Full.Enabled = value
        ESP._ui._espBoxSyncVisibility()
    end
}, "ESPBox")
ESP._ui.boxTypeDropdownEl = sections.ESPBox:Dropdown({
    Name = "Box Type",
    Multi = false,
    Required = true,
    Options = {"Default", "Corner"},
    Default = ESP.Drawing.Boxes.BoxType or "Default",
    Callback = function(value)
        local v = tostring(value)
        local vl = v:lower():gsub("%s+", "")
        if vl == "corner" then
            v = "Corner"
        else
            v = "Default"
        end
        ESP.Drawing.Boxes.BoxType = v
        ESP.Drawing.Boxes.Corner.Enabled = (v == "Corner")
        if ESP.Enabled and ESP.Initialized then
            ESP.Initialized = false
        end
        ESP._ui._espBoxSyncVisibility()
    end
}, "ESPBoxType")
ESP._ui.dynamicBoxesToggleEl = sections.ESPBox:Toggle({
    Name = "Dynamic Boxes",
    Default = ESP.Drawing.Boxes.Dynamic and true or false,
    Callback = function(value)
        ESP.Drawing.Boxes.Dynamic = value and true or false
        if ESP.Enabled and ESP.Initialized then
            ESP.Initialized = false
        end
    end
}, "ESPDynamicBoxes")
ESP._ui.boxImageToggleEl = sections.ESPBox:Toggle({
    Name = "Box Image",
    Default = (ESP.Drawing.Boxes.Image and ESP.Drawing.Boxes.Image.Enabled) and true or false,
    Callback = function(value)
        if ESP.Drawing.Boxes.Image then
            ESP.Drawing.Boxes.Image.Enabled = value and true or false
            if ESP.Drawing.Boxes.Image.Enabled then
                local img = tostring(ESP.Drawing.Boxes.Image.Image or "")
                if img == "" then
                    local preset = tostring(ESP.Drawing.Boxes.Image.Preset or "Cat")
                    local normalized = (ESP._ui._boxImagePresets and ESP._ui._boxImagePresets[preset]) or (ESP._ui._boxImagePresets and ESP._ui._boxImagePresets.Cat) or ""
                    if preset == "Custom" then
                        normalized = ESP._ui._normalizeDecalAsset and ESP._ui._normalizeDecalAsset(ESP.Drawing.Boxes.Image.Custom or "") or ""
                    end
                    ESP.Drawing.Boxes.Image.Image = normalized
                end
                local id = ESP._ui._extractAssetId and ESP._ui._extractAssetId(ESP.Drawing.Boxes.Image.Image or "")
                if id and ESP._ui._resolveDecalToTextureAsync then
                    ESP._ui._resolveDecalToTextureAsync(id)
                end
            end
        end
        ESP._ui._espBoxSyncVisibility()
    end
}, "ESPBoxImage")

ESP._ui._boxImagePresets = {
    Cat = "rbxassetid://7488932287",
    ["Peter Griffin"] = "rbxassetid://1171174601",
    Skeleton = "rbxassetid://11199270611",
    Herbert = "rbxassetid://12620669720",
}

ESP._ui._normalizeDecalAsset = function(text)
    if type(text) ~= "string" then
        return ""
    end
    local s = tostring(text)
    s = s:gsub("^%s+", ""):gsub("%s+$", "")
    if s == "" then
        return ""
    end
    local id = string.match(s, "rbxassetid://(%d+)")
    if not id then
        id = string.match(s, "/asset/(%d+)")
    end
    if not id then
        id = string.match(s, "(%d+)")
    end
    if not id then
        return ""
    end
    return "rbxassetid://" .. id
end

ESP._ui._boxImageTextureCache = ESP._ui._boxImageTextureCache or {}
ESP._ui._boxImageResolveInFlight = ESP._ui._boxImageResolveInFlight or {}
ESP._ui._extractAssetId = function(text)
    if type(text) ~= "string" then
        return nil
    end
    local s = tostring(text):gsub("^%s+", ""):gsub("%s+$", "")
    if s == "" then
        return nil
    end
    local id = string.match(s, "rbxassetid://(%d+)")
    if not id then
        id = string.match(s, "/asset/(%d+)")
    end
    if not id then
        id = string.match(s, "^(%d+)$")
    end
    if not id then
        return nil
    end
    return id
end

ESP._ui._getBoxImageLabelSource = function(raw)
    if type(raw) ~= "string" then
        return ""
    end
    local s = tostring(raw)
    if s == "" then
        return ""
    end
    if string.find(s, "rbxthumb://", 1, true) then
        return s
    end
    local id = ESP._ui._extractAssetId(s)
    if id then
        local cached = ESP._ui._boxImageTextureCache[id]
        if type(cached) == "string" and cached ~= "" then
            return cached
        end
        return "http://www.roblox.com/asset/?id=" .. id
    end
    return s
end

ESP._ui._resolveDecalToTextureAsync = function(id)
    if type(id) ~= "string" or id == "" then
        return
    end
    if ESP._ui._boxImageTextureCache[id] then
        return
    end
    if ESP._ui._boxImageResolveInFlight[id] then
        return
    end
    ESP._ui._boxImageResolveInFlight[id] = true
    task.spawn(function()
        local resolved = nil
        local ok, insertService = pcall(game.GetService, game, "InsertService")
        if ok and insertService then
            local assetOk, asset = pcall(insertService.LoadAsset, insertService, tonumber(id))
            if assetOk and asset then
                local decal = asset:FindFirstChildWhichIsA("Decal", true)
                local texture = decal and decal.Texture
                if type(texture) == "string" and texture ~= "" then
                    resolved = texture
                end
                pcall(function()
                    asset:Destroy()
                end)
            end
        end
        if not resolved then
            local okM, mps = pcall(game.GetService, game, "MarketplaceService")
            if okM and mps then
                local infoOk, info = pcall(mps.GetProductInfo, mps, tonumber(id))
                if infoOk and type(info) == "table" then
                    local iconId = info.IconImageAssetId
                    if type(iconId) == "number" and iconId > 0 then
                        resolved = "rbxassetid://" .. tostring(iconId)
                    elseif type(iconId) == "string" and iconId ~= "" then
                        local iconNum = tonumber(iconId)
                        if iconNum and iconNum > 0 then
                            resolved = "rbxassetid://" .. tostring(iconNum)
                        end
                    end
                end
            end
        end
        if not resolved then
            resolved = "rbxthumb://type=Asset&id=" .. id .. "&w=420&h=420"
        end
        ESP._ui._boxImageTextureCache[id] = resolved
        ESP._ui._boxImageResolveInFlight[id] = nil
        local cfg = ESP.Drawing and ESP.Drawing.Boxes and ESP.Drawing.Boxes.Image
        if cfg and cfg.Enabled then
            local currentId = ESP._ui._extractAssetId(cfg.Image or "")
            if currentId == id then
                cfg.Image = resolved
            end
        end
    end)
end

ESP._ui.boxImagePresetDropdownEl = sections.ESPBox:Dropdown({
    Name = "Box Image Preset",
    Multi = false,
    Required = true,
    Options = { "Cat", "Peter Griffin", "Skeleton", "Herbert", "Custom" },
    Default = (ESP.Drawing.Boxes.Image and ESP.Drawing.Boxes.Image.Preset) or "Cat",
    Callback = function(value)
        if not ESP.Drawing.Boxes.Image then
            return
        end
        local pick = tostring(value)
        if pick ~= "Cat" and pick ~= "Peter Griffin" and pick ~= "Skeleton" and pick ~= "Herbert" and pick ~= "Custom" then
            pick = "Cat"
        end
        ESP.Drawing.Boxes.Image.Preset = pick
        if pick == "Custom" then
            local normalized = ESP._ui._normalizeDecalAsset(ESP.Drawing.Boxes.Image.Custom or "")
            ESP.Drawing.Boxes.Image.Image = normalized
            local id = ESP._ui._extractAssetId(normalized)
            if id then
                ESP._ui._resolveDecalToTextureAsync(id)
            end
        else
            local normalized = ESP._ui._boxImagePresets[pick] or ESP._ui._boxImagePresets.Cat
            local id = ESP._ui._extractAssetId(normalized)
            if id and ESP._ui._boxImageTextureCache[id] then
                normalized = ESP._ui._boxImageTextureCache[id]
            end
            ESP.Drawing.Boxes.Image.Image = normalized
            if id then
                ESP._ui._resolveDecalToTextureAsync(id)
            end
        end
        ESP._ui._espBoxSyncVisibility()
    end
}, "ESPBoxImagePreset")

ESP._ui.boxImageCustomInputEl = sections.ESPBox:Input({
    Name = "Custom Image Link/Id",
    Default = (ESP.Drawing.Boxes.Image and ESP.Drawing.Boxes.Image.Custom) or "",
    Placeholder = "paste create link / rbxassetid://id / id",
    RemoveTextAfterFocusLost = false,
    Callback = function(text)
        if not ESP.Drawing.Boxes.Image then
            return
        end
        ESP.Drawing.Boxes.Image.Custom = tostring(text or "")
        if tostring(ESP.Drawing.Boxes.Image.Preset) == "Custom" then
            local normalized = ESP._ui._normalizeDecalAsset(ESP.Drawing.Boxes.Image.Custom)
            ESP.Drawing.Boxes.Image.Image = normalized
            local id = ESP._ui._extractAssetId(normalized)
            if id then
                if ESP._ui._boxImageTextureCache[id] then
                    ESP.Drawing.Boxes.Image.Image = ESP._ui._boxImageTextureCache[id]
                else
                    ESP._ui._resolveDecalToTextureAsync(id)
                end
            end
        end
    end
}, "ESPBoxImageCustom")

if ESP.Drawing and ESP.Drawing.Boxes and ESP.Drawing.Boxes.Image then
    local cfg = ESP.Drawing.Boxes.Image
    local preset = tostring(cfg.Preset or "Cat")
    if preset ~= "Cat" and preset ~= "Peter Griffin" and preset ~= "Skeleton" and preset ~= "Herbert" and preset ~= "Custom" then
        preset = "Cat"
        cfg.Preset = "Cat"
    end
    if preset == "Custom" then
        local normalized = ESP._ui._normalizeDecalAsset(cfg.Custom or "")
        cfg.Image = normalized
        local id = ESP._ui._extractAssetId(normalized)
        if id then
            if ESP._ui._boxImageTextureCache[id] then
                cfg.Image = ESP._ui._boxImageTextureCache[id]
            else
                ESP._ui._resolveDecalToTextureAsync(id)
            end
        end
    else
        local normalized = ESP._ui._boxImagePresets[preset] or ESP._ui._boxImagePresets.Cat
        cfg.Image = normalized
        local id = ESP._ui._extractAssetId(normalized)
        if id then
            if ESP._ui._boxImageTextureCache[id] then
                cfg.Image = ESP._ui._boxImageTextureCache[id]
            else
                ESP._ui._resolveDecalToTextureAsync(id)
            end
        end
    end
end
ESP._ui.filledBoxToggleEl = sections.ESPBox:Toggle({
    Name = "Filled Box",
    Default = ESP.Drawing.Boxes.Filled.Enabled,
    Callback = function(value)
        ESP.Drawing.Boxes.Filled.Enabled = value and true or false
        ESP._ui._espBoxSyncVisibility()
    end
}, "ESPFilledBox")
ESP._ui.filledBoxColorPickerEl = sections.ESPBox:Colorpicker({
    Name = "Filled Box Color",
    Default = ESP.Drawing.Boxes.Filled.RGB,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.Boxes.Filled.RGB = color
    end
}, "ESPFilledBoxColor")
ESP._ui.animatedBoxesToggleEl = sections.ESPBox:Toggle({
    Name = "Animated Boxes",
    Default = ESP.Drawing.Boxes.Animate,
    Callback = function(value)
        ESP.Drawing.Boxes.Animate = value and true or false
        ESP._ui._espBoxSyncVisibility()
    end
}, "AnimatedBoxes")
ESP._ui.rotationSpeedSliderEl = sections.ESPBox:Slider({
    Name = "Rotation Speed",
    Default = ESP.Drawing.Boxes.RotationSpeed,
    Minimum = 1,
    Maximum = 500,
    Precision = 2,
    Callback = function(value)
        ESP.Drawing.Boxes.RotationSpeed = value
    end
}, "RotationSpeed")
ESP._ui.boxGradientToggleEl = sections.ESPBox:Toggle({
    Name = "Gradient",
    Default = ESP.Drawing.Boxes.Gradient,
    Callback = function(value)
        ESP.Drawing.Boxes.Gradient = value and true or false
        ESP.Drawing.Boxes.GradientFill = ESP.Drawing.Boxes.Gradient
        if ESP.Drawing.Boxes.Gradient then
            ESP.Drawing.Boxes.GradientFillRGB1 = ESP.Drawing.Boxes.GradientRGB1
            ESP.Drawing.Boxes.GradientFillRGB2 = ESP.Drawing.Boxes.GradientRGB2
        end
        ESP._ui._espBoxSyncVisibility()
        if ESP.Enabled and ESP.Initialized then
            ESP.Initialized = false
        end
    end
}, "BoxGradientToggle")
ESP._ui.boxSolidPickerEl = sections.ESPBox:Colorpicker({
    Name = "Box Solid Color",
    Default = ESP.Drawing.Boxes.Full.RGB,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.Boxes.Full.RGB = color
        ESP.Drawing.Boxes.Corner.RGB = color
        if ESP.Enabled and ESP.Initialized then
            ESP.Initialized = false
        end
    end
}, "BoxSolidColor")
ESP._ui.boxGradient1PickerEl = sections.ESPBox:Colorpicker({
    Name = "Box Gradient 1 Color",
    Default = ESP.Drawing.Boxes.GradientFillRGB1,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.Boxes.GradientFillRGB1 = color
        ESP.Drawing.Boxes.GradientRGB1 = color
        if ESP.Enabled and ESP.Initialized then
            ESP.Initialized = false
        end
    end
}, "BoxGradient1Color")
ESP._ui.boxGradient2PickerEl = sections.ESPBox:Colorpicker({
    Name = "Box Gradient 2 Color",
    Default = ESP.Drawing.Boxes.GradientFillRGB2,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.Boxes.GradientFillRGB2 = color
        ESP.Drawing.Boxes.GradientRGB2 = color
    end
}, "BoxGradient2Color")
ESP._ui._espBoxSyncVisibility()
task.defer(function()
    for _ = 1, 15 do
        pcall(function()
            if ESP and ESP._ui and ESP._ui._espBoxSyncVisibility then
                ESP._ui._espBoxSyncVisibility()
            end
        end)
        task.wait(0.05)
    end
end)
ESP._ui.healthbarGradient2PickerEl = sections.ESPHealth:Colorpicker({
    Name = "Healthbar Bottom Color",
    Default = ESP.Drawing.Healthbar.GradientRGB1,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.Healthbar.GradientRGB1 = color
    end
}, "HealthbarGradient2Color")
ESP._ui.healthbarGradient3PickerEl = sections.ESPHealth:Colorpicker({
    Name = "Healthbar Top Color",
    Default = ESP.Drawing.Healthbar.GradientRGB2,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.Healthbar.GradientRGB2 = color
    end
}, "HealthbarGradient3Color")
ESP._ui.gazeLineColorPickerEl = sections.ESPOther:Colorpicker({
    Name = "look line Color",
    Default = ESP.Drawing.GazeLine.RGB,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.GazeLine.RGB = color
        if ESP.GazeLines then
            for _, line in pairs(ESP.GazeLines) do
                line.Color = color
            end
        end
    end
}, "ESPGazeLineColor")
ESP._ui.weaponTextColorPickerEl = sections.ESPWeapon:Colorpicker({
    Name = "Weapon Text Color",
    Default = ESP.Drawing.Weapons.WeaponTextRGB,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.Weapons.WeaponTextRGB = color
    end
}, "WeaponTextColor")
ESP._ui.chamsFillColorPickerEl = sections.ESPChams:Colorpicker({
    Name = "Chams Fill Color",
    Default = ESP.Drawing.Chams.FillRGB,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.Chams.FillRGB = color
        for _, highlight in pairs(ESP.Highlights or {}) do
            if highlight and highlight.FillColor ~= nil then
                highlight.FillColor = color
            end
        end
        if tostring(CurrentChamsType) == "Opaque Force Field" then
            local g = _G
            if g.BeastChams_SetColors then
                g.BeastChams_SetColors(color, g.BeastChams_OutlineColor or ESP.Drawing.Chams.OutlineRGB)
            else
                g.BeastChams_CoreColor = color
            end
        end
    end
}, "ChamsFillColor")
ESP._ui.chamsOutlineColorPickerEl = sections.ESPChams:Colorpicker({
    Name = "Chams Outline Color",
    Default = ESP.Drawing.Chams.OutlineRGB,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.Chams.OutlineRGB = color
        for _, highlight in pairs(ESP.Highlights or {}) do
            if highlight and highlight.OutlineColor ~= nil then
                highlight.OutlineColor = color
            end
        end
        local ct = tostring(CurrentChamsType):lower():gsub("%s+", "")
        if ct == "opaqueforcefield" or ct == "forcefield" then
            local g = _G
            if g.BeastChams_SetColors then
                g.BeastChams_SetColors(g.BeastChams_CoreColor or ESP.Drawing.Chams.FillRGB, color)
            else
                g.BeastChams_OutlineColor = color
            end
        end
    end
}, "ChamsOutlineColor")
ESP._ui.namesColorPickerEl = sections.ESPName:Colorpicker({
    Name = "Names Color",
    Default = ESP.Drawing.Names.RGB,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.Names.RGB = color
    end
}, "ESPNamesColor")
ESP._ui.distanceColorPickerEl = sections.ESPDistance:Colorpicker({
    Name = "Distance Color",
    Default = ESP.Drawing.Distances.RGB,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.Distances.RGB = color
    end
}, "ESPDistanceColor")
sections.ESPSkeleton:Header({ Text = "Skeleton" })
ESP._ui.skeletonToggleEl = sections.ESPSkeleton:Toggle({
    Name = "Skeleton",
    Default = ESP.Drawing.Skeleton.Enabled,
    Callback = function(value)
        ESP.Drawing.Skeleton.Enabled = value
        if value then
            local drawingWorks = pcall(function()
                local testLine = Drawing.new("Line")
                testLine:Remove()
            end)
            if not drawingWorks then
                ESP.Drawing.Skeleton.Enabled = false
                Window:Notify({
                    Title = "Error",
                    Description = "Drawing API not available. Skeleton ESP disabled.",
                    Lifetime = 5
                })
                pcall(function()
                    if ESP and ESP._ui and ESP._ui.skeletonToggleEl and ESP._ui.skeletonToggleEl.set_value then
                        ESP._ui.skeletonToggleEl:set_value(false)
                    end
                end)
                return
            end
            pcall(function()
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= Players.LocalPlayer then
                        if not ESP.Skeletons[player] then
                            InitializePlayerSkeleton(player)
                        end
                        if ESP.Skeletons[player] then
                            UpdatePlayerSkeleton(player, ESP.Skeletons[player])
                        end
                    end
                end
            end)
        else
            if ESP.Skeletons then
                for _, skeleton in pairs(ESP.Skeletons) do
                    for _, line in pairs(skeleton) do
                        if type(line) == "table" and line.Visible ~= nil then
                            line.Visible = false
                        end
                    end
                end
            end
        end
        ESP._ui._syncESPVisibility()
    end
}, "ESPSkeleton")
ESP._ui.skeletonColorPickerEl = sections.ESPSkeleton:Colorpicker({
    Name = "Skeleton Color",
    Default = ESP.Drawing.Skeleton.Color,
    Alpha = 0,
    Callback = function(color)
        ESP.Drawing.Skeleton.Color = color
    end
}, "ESPSkeletonColor")
ESP._ui.skeletonThicknessSliderEl = sections.ESPSkeleton:Slider({
    Name = "Skeleton Thickness",
    Default = ESP.Drawing.Skeleton.Thickness,
    Minimum = 1,
    Maximum = 5,
    Precision = 1,
    Callback = function(value)
        ESP.Drawing.Skeleton.Thickness = value
    end
}, "ESPSkeletonThickness")
local DesyncModule
local FakeLagModule
local FOVChangerSettings
local ArmsVisual
local WorldCloudsEnabled = false
local WorldCustomTimeEnabled = false
local function coerceBool(v)
    if type(v) == "boolean" then
        return v
    end
    if type(v) == "table" then
        local b = v.Toggle or v.Value or v.Enabled or v.State or v.Toggled or v.On or v.Active
        if type(b) == "boolean" then
            return b
        end
    end
    return nil
end
ESP._ui._syncESPVisibility = function()
    if _G.__OBLIVION_CONFIG_LOADING == true then
        return
    end
    local setVisible = ESP._ui._setVisible
    if not setVisible then return end
    if ESP._ui._espBoxSyncPickerVisibility then
        ESP._ui._espBoxSyncPickerVisibility()
    end
    setVisible(ESP._ui.namesColorPickerEl, ESP.Drawing.Names.Enabled and true or false)
    setVisible(ESP._ui.distanceColorPickerEl, ESP.Drawing.Distances.Enabled and true or false)
    local weaponOn = ESP.Drawing.Weapons.Enabled and true or false
    setVisible(ESP._ui.weaponAmmoToggleEl, weaponOn)
    setVisible(ESP._ui.weaponTextColorPickerEl, weaponOn)
    local healthOn = ESP.Drawing.Healthbar.Enabled and true or false
    local healthGradientOn = healthOn and (ESP.Drawing.Healthbar.Gradient and true or false)
    setVisible(ESP._ui.healthbarGradient2PickerEl, healthGradientOn)
    setVisible(ESP._ui.healthbarGradient3PickerEl, healthGradientOn)
    local arrowsOn = ESP.Drawing.Arrows.Enabled and true or false
    setVisible(ESP._ui.arrowColorPickerEl, arrowsOn)
    setVisible(ESP._ui.arrowRadiusSliderEl, arrowsOn)
    setVisible(ESP._ui.arrowSizeSliderEl, arrowsOn)
    setVisible(ESP._ui.inventoryValueColorPickerEl, ESP.ShowInventoryValue and true or false)
    setVisible(ESP._ui.gazeLineColorPickerEl, ESP.Drawing.GazeLine.Enabled and true or false)
    local skeletonOn = ESP.Drawing.Skeleton.Enabled and true or false
    setVisible(ESP._ui.skeletonColorPickerEl, skeletonOn)
    setVisible(ESP._ui.skeletonThicknessSliderEl, skeletonOn)
    local chamsOn = ChamsToggleState and true or false
    local ct = tostring(CurrentChamsType):lower():gsub("%s+", "")
    local showChamsFill = true
    local showChamsOutline = true
    if ct == "forcefield" then
        showChamsFill = false
    elseif ct == "model" or ct == "galaxy" then
        showChamsFill = false
        showChamsOutline = false
    end
    setVisible(ESP._ui.chamsFillColorPickerEl, chamsOn and showChamsFill)
    setVisible(ESP._ui.chamsOutlineColorPickerEl, chamsOn and showChamsOutline)
    setVisible(ESP._ui.chamsXRayToggleEl, chamsOn)
    setVisible(ESP._ui.chamsTransparencySliderEl, chamsOn)
    setVisible(ESP._ui.chamsMaxDistanceSliderEl, chamsOn)
    local isBeast = (ct == "opaqueforcefield" or ct == "forcefield" or ct == "model")
    setVisible(ESP._ui.chamsOriginalModelInvisibilityToggleEl, chamsOn and isBeast)
    local speedOn = (CFrameSpeed and CFrameSpeed.Enabled) and true or false
    setVisible(ESP._ui.playerFastWalkToggleEl, speedOn)
    local noFallOn = nofall and true or false
    setVisible(ESP._ui.playerInstaFallToggleEl, noFallOn)
    local tracerOn = (_G.ScriptData and _G.ScriptData.bulletTracerEnabled) and true or false
    setVisible(ESP._ui.playerTracerLifetimeSliderEl, tracerOn)
    setVisible(ESP._ui.playerTracerColorPickerEl, tracerOn)
    local zoomOn = (ZoomSettings and ZoomSettings.Enabled) and true or false
    setVisible(ESP._ui.playerZoomAmountSliderEl, zoomOn)
    setVisible(ESP._ui.playerZoomKeybindEl, zoomOn)
    local fovOn = (FOVChangerSettings and FOVChangerSettings.Enabled) and true or false
    setVisible(ESP._ui.playerCustomFovSliderEl, fovOn)
    local handOn = (ArmsVisual and ArmsVisual.Enabled) and true or false
    local handMode = tostring(CurrentHandChamsType or "material"):lower():gsub("%s+", "")
    local handIsGalaxy = (handMode == "galaxy")
    local handIsOpaqueForceField = (handMode == "opaqueforcefield")
    setVisible(ESP._ui.playerHandColorPickerEl, handOn and not handIsGalaxy and not handIsOpaqueForceField)
    setVisible(ESP._ui.playerHandOpaqueOuterColorPickerEl, handOn and handIsOpaqueForceField)
    setVisible(ESP._ui.playerHandOpaqueInnerColorPickerEl, handOn and handIsOpaqueForceField)
    setVisible(ESP._ui.playerHandTransparencySliderEl, handOn)
    setVisible(ESP._ui.playerHandMaterialDropdownEl, handOn)
    local desyncOn = (DesyncModule and DesyncModule.Enabled) and true or false
    setVisible(ESP._ui.desyncSilhouetteToggleEl, desyncOn)
    setVisible(ESP._ui.desyncModeDropdownEl, desyncOn)
    setVisible(ESP._ui.desyncOffsetXSliderEl, desyncOn)
    setVisible(ESP._ui.desyncOffsetYSliderEl, desyncOn)
    setVisible(ESP._ui.desyncOffsetZSliderEl, desyncOn)
    setVisible(ESP._ui.desyncRotXSliderEl, desyncOn)
    setVisible(ESP._ui.desyncRotYSliderEl, desyncOn)
    setVisible(ESP._ui.desyncRotZSliderEl, desyncOn)
    local desyncMode = (DesyncModule and DesyncModule.Mode) or "Custom"
    local isSpin = desyncOn and desyncMode == "Spinbot"
    local isSpaz = desyncOn and desyncMode == "SpazBot"
    setVisible(ESP._ui.desyncSpinSpeedSliderEl, isSpin)
    setVisible(ESP._ui.desyncSpazRadiusSliderEl, isSpaz)
    setVisible(ESP._ui.desyncSpazSharpnessSliderEl, isSpaz)
    local desyncSilhouetteOn = desyncOn and (DesyncModule and DesyncModule.Silhouette) and true or false
    setVisible(ESP._ui.desyncIgnoreHRPToggleEl, desyncSilhouetteOn)
    setVisible(ESP._ui.desyncSilhouetteColorPickerEl, desyncSilhouetteOn)
    local fakeLagOn = (FakeLagModule and FakeLagModule.Enabled) and true or false
    setVisible(ESP._ui.fakeLagDelaySliderEl, fakeLagOn)
    setVisible(ESP._ui.fakeLagMaxDelaySliderEl, fakeLagOn)
    setVisible(ESP._ui.fakeLagFreezeToggleEl, fakeLagOn)
    local freezeBindOn = fakeLagOn and (FakeLagModule and FakeLagModule.FreezeBindEnabled) and true or false
    if MacLib and MacLib.Flags and MacLib.Flags["FakeLagFreeze"] ~= nil then
        local b = coerceBool(MacLib.Flags["FakeLagFreeze"])
        if type(b) == "boolean" then
            freezeBindOn = fakeLagOn and b or false
        end
    end
    local el = ESP and ESP._ui and ESP._ui.fakeLagFreezeToggleEl
    if el then
        local v = rawget(el, "Value") or rawget(el, "Enabled") or rawget(el, "Toggled") or rawget(el, "State") or rawget(el, "Toggle")
        local b = coerceBool(v)
        if type(b) == "boolean" then
            freezeBindOn = fakeLagOn and b or false
        end
    end
    setVisible(ESP._ui.fakeLagFreezeKeybindEl, freezeBindOn)
    setVisible(ESP._ui.fakeLagSilhouetteToggleEl, fakeLagOn)
    local fakeLagSilhouetteOn = fakeLagOn and (FakeLagModule and FakeLagModule.Silhouette) and true or false
    setVisible(ESP._ui.fakeLagIgnoreHRPToggleEl, fakeLagSilhouetteOn)
    setVisible(ESP._ui.fakeLagSilhouetteColorPickerEl, fakeLagSilhouetteOn)
    setVisible(ESP._ui.fakeLagThicknessSliderEl, fakeLagSilhouetteOn)
    setVisible(ESP._ui.fakeLagTransparencySliderEl, fakeLagSilhouetteOn)
    local cloudsOn = WorldCloudsEnabled and true or false
    setVisible(ESP._ui.worldCloudColorPickerEl, cloudsOn)
    setVisible(ESP._ui.worldCloudCoverSliderEl, cloudsOn)
    setVisible(ESP._ui.worldCloudDensitySliderEl, cloudsOn)
    setVisible(ESP._ui.worldCloudResetButtonEl, cloudsOn)
    local customTimeOn = WorldCustomTimeEnabled and true or false
    setVisible(ESP._ui.worldTimeOfDaySliderEl, customTimeOn)
    local customWorldColorOn = false
    if _G and _G.WorldColorSettings and _G.WorldColorSettings.enabled ~= nil then
        customWorldColorOn = _G.WorldColorSettings.enabled and true or false
    end
    if MacLib and MacLib.Flags and MacLib.Flags["CustomWorldColor"] ~= nil then
        customWorldColorOn = MacLib.Flags["CustomWorldColor"] and true or false
    end
    setVisible(ESP._ui.worldIndoorAmbientColorPickerEl, customWorldColorOn)
    setVisible(ESP._ui.worldOutdoorAmbientColorPickerEl, customWorldColorOn)
    setVisible(ESP._ui.worldResetWorldColorButtonEl, customWorldColorOn)
    local tpOn = ((allvars and allvars.camthirdp) or (_G.allvars and _G.allvars.camthirdp)) and true or false
    setVisible(ESP._ui.playerThirdPersonSelfChamsToggleEl, tpOn)
    setVisible(ESP._ui.playerThirdPersonDistanceSliderEl, tpOn)
    setVisible(ESP._ui.playerThirdPersonKeybindEl, tpOn)
end
ESP._ui._syncESPVisibility()
sections.LootMain:Header({
    Text = "Main Settings"
})
LootESP._ui = LootESP._ui or {}
LootESP._ui._setVisible = LootESP._ui._setVisible or (ESP and ESP._ui and ESP._ui._setVisible) or function() end
LootESP._ui.enableToggleEl = sections.LootMain:Toggle({
    Name = "Enable ESP",
    Default = false,
    Callback = function(value)
        LootESP.Enabled = value
        if value then
            LootESP._NextUpdate = 0
        else
            for _, data in pairs(LootESP.Containers.Cache) do
                if data.Highlight then data.Highlight.Enabled = false end
                if data.Billboard then data.Billboard.Enabled = false end
            end
            for _, data in pairs(LootESP.DroppedItems.Cache) do
                if data.Highlight then data.Highlight.Enabled = false end
                if data.Billboard then data.Billboard.Enabled = false end
            end
            for _, data in pairs(LootESP.Corpses.Cache) do
                if data.Highlight then data.Highlight.Enabled = false end
                if data.Billboard then data.Billboard.Enabled = false end
            end
        end
        if LootESP._ui and LootESP._ui._syncLootVisibility then
            LootESP._ui._syncLootVisibility()
        end
    end
}, "LootEnable")
LootESP._ui.textTransparencySliderEl = sections.LootMain:Slider({
    Name = "Transparency Text",
    Default = 0,
    Minimum = 0,
    Maximum = 1,
    Precision = 2,
    Decimals = 2,
    Callback = function(value)
        LootESP.TextTransparency = value
    end
}, "LootTextTrans")
LootESP._ui.chamsTransparencySliderEl = sections.LootMain:Slider({
    Name = "Chams Transparency",
    Default = 0.5,
    Minimum = 0,
    Maximum = 1,
    Precision = 2,
    Callback = function(value)
        LootESP.ChamsTransparency = value
    end
}, "LootChamsTrans")
LootESP._ui.maxDistanceSliderEl = sections.LootMain:Slider({
    Name = "Max Distance",
    Default = 250,
    Minimum = 10,
    Maximum = 1000,
    Precision = 0,
    Callback = function(value)
        LootESP.MaxDistance = value
    end
}, "LootMaxDist")
sections.Exits = tabs.Loot:Section({ Side = "Left", Name = "Exits" })
sections.Exits:Header({ Text = "Exits" })
LootESP._ui.exitsEnableToggleEl = sections.Exits:Toggle({
    Name = "Enable",
    Default = false,
    Callback = function(value)
        LootESP.Exits.Enabled = value
        if value then
            if LootESP.StartExitTracking then
                LootESP.StartExitTracking()
            end
        else
            if LootESP.StopExitTracking then
                LootESP.StopExitTracking()
            end
        end
        if LootESP._ui and LootESP._ui._syncLootVisibility then
            LootESP._ui._syncLootVisibility()
        end
    end
}, "ExitsEnable")
LootESP._ui.exitsIconToggleEl = sections.Exits:Toggle({
    Name = "Exit Icon",
    Default = true,
    Callback = function(value)
        LootESP.Exits.IconEnabled = value
        for _, data in pairs(LootESP.Exits.Cache) do
            if data.Icon then
                data.Icon.Visible = value
            end
        end
    end
}, "ExitsIcon")
LootESP._ui.exitsDistanceToggleEl = sections.Exits:Toggle({
    Name = "Exit Distance",
    Default = true,
    Callback = function(value)
        LootESP.Exits.DistanceEnabled = value
        for _, data in pairs(LootESP.Exits.Cache) do
            if data.TextLabel then
                data.TextLabel.Visible = value
            end
        end
    end
}, "ExitsDistance")
LootESP._ui.exitsColorPickerEl = sections.Exits:Colorpicker({
    Name = "Color",
    Default = LootESP.Exits.Color,
    Alpha = 0,
    Callback = function(color)
        LootESP.Exits.Color = color
        for _, data in pairs(LootESP.Exits.Cache) do
            if data.Icon then
                data.Icon.ImageColor3 = color
            end
            if data.TextLabel then
                data.TextLabel.TextColor3 = color
            end
        end
    end
}, "ExitsColor")
local containerSection = tabs.Loot:Section({ Side = "Right", Name = "Containers Settings" })
containerSection:Header({
    Text = "Containers"
})
LootESP._ui.containersEnableToggleEl = containerSection:Toggle({
    Name = "Enable",
    Default = false,
    Callback = function(value)
        LootESP.Containers.Enabled = value
        if value then
            if LootESP.StartContainerTracking then
                LootESP.StartContainerTracking()
            end
        else
            if LootESP.StopContainerTracking then
                LootESP.StopContainerTracking()
            end
        end
        if LootESP._ui and LootESP._ui._syncLootVisibility then
            LootESP._ui._syncLootVisibility()
        end
    end
}, "LootShowContainers")
LootESP._ui.containersNameToggleEl = containerSection:Toggle({
    Name = "Containers Name",
    Default = true,
    Callback = function(value)
        LootESP.Containers.NameEnabled = value
        if LootESP._ui and LootESP._ui._syncLootVisibility then
            LootESP._ui._syncLootVisibility()
        end
    end
}, "LootContainersName")
LootESP._ui.containersIconToggleEl = containerSection:Toggle({
    Name = "Containers Icon",
    Default = false,
    Callback = function(value)
        LootESP.Containers.IconEnabled = value
        for _, data in pairs(LootESP.Containers.Cache) do
            if data.Icon then
                data.Icon.Visible = value
            end
        end
    end
}, "LootContainersIcon")
LootESP._ui.containersChamsToggleEl = containerSection:Toggle({
    Name = "Containers Chams",
    Default = false,
    Callback = function(value)
        LootESP.Containers.ChamsEnabled = value
        if LootESP._ui and LootESP._ui._syncLootVisibility then
            LootESP._ui._syncLootVisibility()
        end
    end
}, "LootContainersChams")
LootESP._ui.containersNameColorPickerEl = containerSection:Colorpicker({
    Name = "Name Color",
    Default = Color3.fromRGB(255, 255, 0),
    Alpha = 0,
    Callback = function(color)
        LootESP.Containers.NameColor = color
    end
}, "LootNameColor")
LootESP._ui.containersChamsColorPickerEl = containerSection:Colorpicker({
    Name = "Chams Color",
    Default = Color3.fromRGB(255, 255, 0),
    Alpha = 0,
    Callback = function(color)
        LootESP.Containers.ChamsColor = color
    end
}, "LootChamsColor")
local containerNames = {}
pcall(function()
    local rsContainers = game:GetService("ReplicatedStorage"):FindFirstChild("LootContainers")
    if rsContainers then
        for _, v in pairs(rsContainers:GetChildren()) do
            table.insert(containerNames, v.Name)
        end
        table.sort(containerNames)
    end
end)
LootESP._ui.containersPriorityDropdownEl = containerSection:Dropdown({
    Name = "Priority Containers",
    Multi = true,
    Required = false,
    Options = containerNames,
    Default = {},
    Callback = function(value)
        LootESP.PriorityList = value
        if LootESP.Containers.Enabled then
            LootESP.StopContainerTracking()
            LootESP.StartContainerTracking()
        end
    end
}, "LootPriorityContainers")
local droppedItemSection = tabs.Loot:Section({ Side = "Right", Name = "Dropped Items Settings" })
droppedItemSection:Header({
    Text = "Dropped Items"
})
LootESP._ui.droppedEnableToggleEl = droppedItemSection:Toggle({
    Name = "Enable",
    Default = false,
    Callback = function(value)
        LootESP.DroppedItems.Enabled = value
        if value then
            LootESP.StartDroppedItemTracking()
        else
            if not LootESP.Corpses.Enabled then
                if LootESP.StopDroppedItemTracking then
                    LootESP.StopDroppedItemTracking()
                end
            end
        end
        if LootESP._ui and LootESP._ui._syncLootVisibility then
            LootESP._ui._syncLootVisibility()
        end
    end
}, "LootShowDroppedItems")
LootESP._ui.droppedNameToggleEl = droppedItemSection:Toggle({
    Name = "Item Name",
    Default = true,
    Callback = function(value)
        LootESP.DroppedItems.NameEnabled = value
        if LootESP._ui and LootESP._ui._syncLootVisibility then
            LootESP._ui._syncLootVisibility()
        end
    end
}, "LootDroppedItemName")
LootESP._ui.droppedIconToggleEl = droppedItemSection:Toggle({
    Name = "Item Icon",
    Default = false,
    Callback = function(value)
        LootESP.DroppedItems.IconEnabled = value
        for _, data in pairs(LootESP.DroppedItems.Cache) do
            if data.Icon then
                data.Icon.Visible = value
            end
        end
    end
}, "LootDroppedItemIcon")
LootESP._ui.droppedChamsToggleEl = droppedItemSection:Toggle({
    Name = "Item Chams",
    Default = false,
    Callback = function(value)
        LootESP.DroppedItems.ChamsEnabled = value
        if LootESP._ui and LootESP._ui._syncLootVisibility then
            LootESP._ui._syncLootVisibility()
        end
    end
}, "LootDroppedItemChams")
LootESP._ui.droppedNameColorPickerEl = droppedItemSection:Colorpicker({
    Name = "Name Color",
    Default = Color3.fromRGB(0, 255, 255),
    Callback = function(color)
        LootESP.DroppedItems.NameColor = color
    end
}, "LootDroppedItemNameColor")
LootESP._ui.droppedChamsColorPickerEl = droppedItemSection:Colorpicker({
    Name = "Chams Color",
    Default = Color3.fromRGB(0, 255, 255),
    Alpha = 0,
    Callback = function(color)
        LootESP.DroppedItems.ChamsColor = color
    end
}, "LootDroppedItemChamsColor")
local droppedItemNames = {}
pcall(function()
    local rsItems = game:GetService("ReplicatedStorage"):FindFirstChild("ItemsListModels")
    if rsItems then
        for _, v in pairs(rsItems:GetChildren()) do
            table.insert(droppedItemNames, v.Name)
        end
        table.sort(droppedItemNames)
    end
end)
LootESP._ui.droppedPriorityDropdownEl = droppedItemSection:Dropdown({
    Name = "Priority Items",
    Multi = true,
    Required = false,
    Options = droppedItemNames,
    Default = {},
    Callback = function(value)
        LootESP.DroppedItems.PriorityList = value
        if LootESP.DroppedItems.Enabled then
            LootESP.StopDroppedItemTracking()
            LootESP.StartDroppedItemTracking()
        end
    end
}, "LootPriorityDroppedItems")
local corpseSection = tabs.Loot:Section({ Side = "Right", Name = "Corpse Settings" })
corpseSection:Header({
    Text = "Corpses"
})
LootESP._ui.corpsesEnableToggleEl = corpseSection:Toggle({
    Name = "Enable",
    Default = false,
    Callback = function(value)
        LootESP.Corpses.Enabled = value
        if value then
             LootESP.StartDroppedItemTracking()
        else
             if not LootESP.DroppedItems.Enabled then
                  if LootESP.StopDroppedItemTracking then
                       LootESP.StopDroppedItemTracking()
                  end
             end
        end
        if LootESP._ui and LootESP._ui._syncLootVisibility then
            LootESP._ui._syncLootVisibility()
        end
    end
}, "LootShowCorpses")
LootESP._ui.corpsesNameToggleEl = corpseSection:Toggle({
    Name = "Corpse Name",
    Default = true,
    Callback = function(value)
        LootESP.Corpses.NameEnabled = value
        if LootESP._ui and LootESP._ui._syncLootVisibility then
            LootESP._ui._syncLootVisibility()
        end
    end
}, "LootCorpseName")
LootESP._ui.corpsesIconToggleEl = corpseSection:Toggle({
    Name = "Corpse Icon",
    Default = false,
    Callback = function(value)
        LootESP.Corpses.IconEnabled = value
        for _, data in pairs(LootESP.Corpses.Cache) do
            if data.Icon then
                data.Icon.Visible = value
            end
        end
    end
}, "LootCorpseIcon")
LootESP._ui.corpsesChamsToggleEl = corpseSection:Toggle({
    Name = "Corpse Chams",
    Default = false,
    Callback = function(value)
        LootESP.Corpses.ChamsEnabled = value
        if LootESP._ui and LootESP._ui._syncLootVisibility then
            LootESP._ui._syncLootVisibility()
        end
    end
}, "LootCorpseChams")
LootESP._ui.corpsesNameColorPickerEl = corpseSection:Colorpicker({
    Name = "Name Color",
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(color)
        LootESP.Corpses.NameColor = color
    end
}, "LootCorpseNameColor")
LootESP._ui.corpsesChamsColorPickerEl = corpseSection:Colorpicker({
    Name = "Chams Color",
    Default = Color3.fromRGB(255, 0, 0),
    Alpha = 0,
    Callback = function(color)
        LootESP.Corpses.ChamsColor = color
    end
}, "LootCorpseChamsColor")
LootESP._ui._syncLootVisibility = LootESP._ui._syncLootVisibility or function()
    if _G.__OBLIVION_CONFIG_LOADING == true then
        return
    end
    local setVisible = LootESP._ui._setVisible
    local worldOn = LootESP.Enabled and true or false
    setVisible(LootESP._ui.textTransparencySliderEl, worldOn)
    setVisible(LootESP._ui.chamsTransparencySliderEl, worldOn)
    setVisible(LootESP._ui.maxDistanceSliderEl, worldOn)
    local exitsOn = worldOn and (LootESP.Exits and LootESP.Exits.Enabled) and true or false
    setVisible(LootESP._ui.exitsIconToggleEl, exitsOn)
    setVisible(LootESP._ui.exitsDistanceToggleEl, exitsOn)
    setVisible(LootESP._ui.exitsColorPickerEl, exitsOn)
    local containersOn = worldOn and (LootESP.Containers and LootESP.Containers.Enabled) and true or false
    setVisible(LootESP._ui.containersNameToggleEl, containersOn)
    setVisible(LootESP._ui.containersIconToggleEl, containersOn)
    setVisible(LootESP._ui.containersChamsToggleEl, containersOn)
    setVisible(LootESP._ui.containersNameColorPickerEl, containersOn and (LootESP.Containers and LootESP.Containers.NameEnabled) and true or false)
    setVisible(LootESP._ui.containersChamsColorPickerEl, containersOn and (LootESP.Containers and LootESP.Containers.ChamsEnabled) and true or false)
    setVisible(LootESP._ui.containersPriorityDropdownEl, containersOn)
    local droppedOn = worldOn and (LootESP.DroppedItems and LootESP.DroppedItems.Enabled) and true or false
    setVisible(LootESP._ui.droppedNameToggleEl, droppedOn)
    setVisible(LootESP._ui.droppedIconToggleEl, droppedOn)
    setVisible(LootESP._ui.droppedChamsToggleEl, droppedOn)
    setVisible(LootESP._ui.droppedNameColorPickerEl, droppedOn and (LootESP.DroppedItems and LootESP.DroppedItems.NameEnabled) and true or false)
    setVisible(LootESP._ui.droppedChamsColorPickerEl, droppedOn and (LootESP.DroppedItems and LootESP.DroppedItems.ChamsEnabled) and true or false)
    setVisible(LootESP._ui.droppedPriorityDropdownEl, droppedOn)
    local corpsesOn = worldOn and (LootESP.Corpses and LootESP.Corpses.Enabled) and true or false
    setVisible(LootESP._ui.corpsesNameToggleEl, corpsesOn)
    setVisible(LootESP._ui.corpsesIconToggleEl, corpsesOn)
    setVisible(LootESP._ui.corpsesChamsToggleEl, corpsesOn)
    setVisible(LootESP._ui.corpsesNameColorPickerEl, corpsesOn and (LootESP.Corpses and LootESP.Corpses.NameEnabled) and true or false)
    setVisible(LootESP._ui.corpsesChamsColorPickerEl, corpsesOn and (LootESP.Corpses and LootESP.Corpses.ChamsEnabled) and true or false)
end
LootESP._ui._syncLootVisibility()
pcall(function()
    if type(_G.MainDesync_Stop) == "function" then
        _G.MainDesync_Stop()
    end
end)
DesyncModule = {
    Enabled = false,
    Silhouette = false,
    SilhouetteColor = Color3.fromRGB(255, 255, 255),
    SilhouetteThickness = 0.001,
    SilhouetteTransparency = 0,
    SilhouetteIgnoreHRP = true,
    Position = {X = 0, Y = 0, Z = 0},
    Rotation = {X = 0, Y = 0, Z = 0},
    Mode = "Custom",
    SpinSpeed = 720,
    SpazRadius = 1.5,
    SpazSharpness = 8,
    SafeMaxRadius = 16,
    SafeMinY = -1.5,
    SafeStartDelay = 14,
    _savedRealCFrame = nil,
    _savedRealVelocity = nil,
    _lastSpoofedCFrame = nil,
    _ghostModel = nil,
    _ghostMap = {},
    _ghostConnections = {},
    _heartbeatConnection = nil,
    _characterAddedConnection = nil,
    _renderBound = false,
    _currentPos = Vector3.new(0, 0, 0),
    _currentRot = Vector3.new(0, 0, 0),
    _spinYaw = 0,
    _stopping = false,
    _suspendUntil = 0,
    _wasDead = false
}
local desyncOverlapParams
local function desyncGetSafeCFrame(root, baseCFrame, posOffset, rotOffset, character)
    local targetCFrame = (baseCFrame + posOffset) * rotOffset
    local basePos = baseCFrame.Position
    local targetPos = targetCFrame.Position
    local maxRadius = DesyncModule.SafeMaxRadius or 8
    local minY = DesyncModule.SafeMinY or -2
    local offset = targetPos - basePos
    local mag = offset.Magnitude
    if mag > maxRadius and mag > 0 then
        local clampedOffset = offset.Unit * maxRadius
        local rx, ry, rz = targetCFrame:ToOrientation()
        targetPos = basePos + clampedOffset
        targetCFrame = CFrame.new(targetPos) * CFrame.Angles(rx, ry, rz)
    end
    if targetPos.Y < minY then
        local rx, ry, rz = targetCFrame:ToOrientation()
        targetPos = Vector3.new(targetPos.X, minY, targetPos.Z)
        targetCFrame = CFrame.new(targetPos) * CFrame.Angles(rx, ry, rz)
    end
    if not workspace.GetPartBoundsInBox then
        return targetCFrame
    end
    local okParams, params = pcall(function()
        if not desyncOverlapParams then
            desyncOverlapParams = OverlapParams.new()
            desyncOverlapParams.FilterType = Enum.OverlapFilterType.Exclude
        end
        if character then
            desyncOverlapParams.FilterDescendantsInstances = { character }
        else
            desyncOverlapParams.FilterDescendantsInstances = {}
        end
        return desyncOverlapParams
    end)
    if not okParams or not params then
        return targetCFrame
    end
    local function hasBlockingParts(partList, baseY, baselineSet)
        if not partList or #partList == 0 then
            return false
        end
        for i = 1, #partList do
            local p = partList[i]
            if p and p:IsA("BasePart") then
                if baselineSet and baselineSet[p] then
                    continue
                end
                local ok = true
                if ok and character and p:IsDescendantOf(character) then
                    ok = false
                end
                if ok and p.CanCollide ~= true then
                    ok = false
                end
                if ok and p.Transparency and p.Transparency >= 0.95 then
                    ok = false
                end
                if ok and baseY ~= nil and p.Size then
                    local topY = p.Position.Y + (p.Size.Y * 0.5)
                    if topY <= (baseY - 0.35) then
                        ok = false
                    end
                end
                if ok then
                    return true
                end
            end
        end
        return false
    end
    local safeCFrame = targetCFrame
    local function getBoundsAt(cf)
        local rx, ry, rz = cf:ToOrientation()
        local checkPos = cf.Position + Vector3.new(0, 1.35, 0)
        local checkCF = CFrame.new(checkPos) * CFrame.Angles(rx, ry, rz)
        return workspace:GetPartBoundsInBox(checkCF, Vector3.new(1.8, 2.2, 1.8), params)
    end
    local baselineSet = nil
    local okBase, baseParts = pcall(function()
        return getBoundsAt(baseCFrame)
    end)
    if okBase and baseParts and #baseParts > 0 then
        baselineSet = {}
        for i = 1, #baseParts do
            local p = baseParts[i]
            if p and p:IsA("BasePart") then
                baselineSet[p] = true
            end
        end
    end
    local okBounds, parts = pcall(function()
        return getBoundsAt(safeCFrame)
    end)
    local tries = 0
    while okBounds and hasBlockingParts(parts, basePos.Y, baselineSet) and tries < 10 do
        tries = tries + 1
        local rx, ry, rz = safeCFrame:ToOrientation()
        local pos = safeCFrame.Position + Vector3.new(0, 0.35, 0)
        safeCFrame = CFrame.new(pos) * CFrame.Angles(rx, ry, rz)
        okBounds, parts = pcall(function()
            return getBoundsAt(safeCFrame)
        end)
    end
    if okBounds and not hasBlockingParts(parts, basePos.Y, baselineSet) then
        return safeCFrame
    end
    local horiz = Vector3.new(posOffset.X, 0, posOffset.Z)
    if horiz.Magnitude > 1e-3 then
        safeCFrame = (baseCFrame + horiz) * rotOffset
        okBounds, parts = pcall(function()
            return getBoundsAt(safeCFrame)
        end)
        tries = 0
        while okBounds and hasBlockingParts(parts, basePos.Y, baselineSet) and tries < 10 do
            tries = tries + 1
            local rx, ry, rz = safeCFrame:ToOrientation()
            local pos = safeCFrame.Position + Vector3.new(0, 0.35, 0)
            safeCFrame = CFrame.new(pos) * CFrame.Angles(rx, ry, rz)
            okBounds, parts = pcall(function()
                return getBoundsAt(safeCFrame)
            end)
        end
        if okBounds and not hasBlockingParts(parts, basePos.Y, baselineSet) then
            return safeCFrame
        end
    end
    return baseCFrame * rotOffset
end
local function desyncIsDirectionClear(baseCFrame, offset, character)
    local basePos = baseCFrame.Position
    local horiz = Vector3.new(offset.X, 0, offset.Z)
    local mag = horiz.Magnitude
    if mag < 1e-3 then
        return true
    end
    local origin = basePos + Vector3.new(0, 1.5, 0)
    local dir = horiz.Unit * (mag + 0.75)
    local result = nil
    local ok, res = pcall(function()
        local params = RaycastParams.new()
        params.FilterType = Enum.RaycastFilterType.Exclude
        if character then
            params.FilterDescendantsInstances = { character }
        else
            params.FilterDescendantsInstances = {}
        end
        return workspace:Raycast(origin, dir, params)
    end)
    if ok then
        result = res
    end
    if result and result.Instance and result.Instance.CanCollide == true then
        return false
    end
    return true
end
local function desyncDestroyGhostModel()
    for _, conn in ipairs(DesyncModule._ghostConnections) do
        pcall(function()
            conn:Disconnect()
        end)
    end
    DesyncModule._ghostConnections = {}
    DesyncModule._ghostMap = {}
    if DesyncModule._ghostModel then
        DesyncModule._ghostModel:Destroy()
        DesyncModule._ghostModel = nil
    end
end
local function desyncCreateGhostPartFor(part)
    if not part or not part:IsA("BasePart") then return end
    if DesyncModule.SilhouetteIgnoreHRP and part.Name == "HumanoidRootPart" then return end
    if DesyncModule._ghostMap[part] then return end
    if not DesyncModule._ghostModel then return end
    local ghostPart = part:Clone()
    for _, child in ipairs(ghostPart:GetDescendants()) do
        child:Destroy()
    end
    ghostPart.Anchored = true
    ghostPart.CanCollide = false
    ghostPart.CanTouch = false
    ghostPart.CanQuery = false
    ghostPart.Massless = true
    ghostPart.Transparency = 1
    ghostPart.Name = part.Name .. "_Ghost"
    ghostPart.Parent = DesyncModule._ghostModel
    local box = Instance.new("SelectionBox")
    box.Name = "BoxWireframe"
    box.Adornee = ghostPart
    box.Parent = ghostPart
    box.Color3 = DesyncModule.SilhouetteColor
    box.LineThickness = DesyncModule.SilhouetteThickness
    box.Transparency = DesyncModule.SilhouetteTransparency
    box.SurfaceTransparency = 1
    DesyncModule._ghostMap[part] = ghostPart
end
local function desyncRebuildGhostModel(character)
    desyncDestroyGhostModel()
    if not character then return end
    DesyncModule._ghostModel = Instance.new("Model")
    DesyncModule._ghostModel.Name = "DesyncSilhouette"
    DesyncModule._ghostModel.Parent = workspace
    for _, desc in ipairs(character:GetDescendants()) do
        if desc:IsA("BasePart") then
            desyncCreateGhostPartFor(desc)
        end
    end
    table.insert(DesyncModule._ghostConnections, character.DescendantAdded:Connect(function(inst)
        if not DesyncModule.Silhouette then return end
        if inst:IsA("BasePart") then
            desyncCreateGhostPartFor(inst)
        end
    end))
    table.insert(DesyncModule._ghostConnections, character.AncestryChanged:Connect(function(_, parent)
        if parent == nil then
            desyncDestroyGhostModel()
        end
    end))
end
local function desyncBindRenderFix()
    if DesyncModule._renderBound then return end
    DesyncModule._renderBound = true
    RunService:BindToRenderStep("Main_DesyncFix", Enum.RenderPriority.Camera.Value - 1, function()
        if not DesyncModule.Enabled then return end
        local character = Players.LocalPlayer and Players.LocalPlayer.Character
        if not character then return end
        local root = character:FindFirstChild("HumanoidRootPart")
        if not root then return end
        if not DesyncModule._savedRealCFrame then return end
        root.CFrame = DesyncModule._savedRealCFrame
        if DesyncModule._savedRealVelocity then
            root.AssemblyLinearVelocity = DesyncModule._savedRealVelocity
        end
    end)
end
local function desyncUnbindRenderFix()
    if not DesyncModule._renderBound then return end
    DesyncModule._renderBound = false
    pcall(function()
        RunService:UnbindFromRenderStep("Main_DesyncFix")
    end)
end
local function desyncRestoreCharacter()
    local character = Players.LocalPlayer and Players.LocalPlayer.Character
    if not character then return end
    local root = character:FindFirstChild("HumanoidRootPart")
    if root and DesyncModule._savedRealCFrame then
        root.CFrame = DesyncModule._savedRealCFrame
        if DesyncModule._savedRealVelocity then
            root.AssemblyLinearVelocity = DesyncModule._savedRealVelocity
        end
        pcall(function()
            root.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
        end)
    end
    local humanoid = character:FindFirstChildWhichIsA("Humanoid")
    if humanoid then
        humanoid.PlatformStand = false
        humanoid.Sit = false
        humanoid.AutoRotate = true
        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    end
    DesyncModule._savedRealCFrame = nil
    DesyncModule._savedRealVelocity = nil
end
local function desyncStop()
    DesyncModule.Enabled = false
    desyncRestoreCharacter()
    if DesyncModule._heartbeatConnection then
        DesyncModule._heartbeatConnection:Disconnect()
        DesyncModule._heartbeatConnection = nil
    end
    if DesyncModule._characterAddedConnection then
        DesyncModule._characterAddedConnection:Disconnect()
        DesyncModule._characterAddedConnection = nil
    end
    desyncUnbindRenderFix()
    desyncDestroyGhostModel()
end
pcall(function()
    _G.MainDesync_Stop = desyncStop
end)
local function desyncStart()
    if DesyncModule._heartbeatConnection then
        DesyncModule._heartbeatConnection:Disconnect()
        DesyncModule._heartbeatConnection = nil
    end
    if DesyncModule._characterAddedConnection then
        DesyncModule._characterAddedConnection:Disconnect()
        DesyncModule._characterAddedConnection = nil
    end
    DesyncModule.Enabled = true
    DesyncModule._stopping = false
    DesyncModule._currentPos = Vector3.new(0, 0, 0)
    DesyncModule._currentRot = Vector3.new(0, 0, 0)
    DesyncModule._spinYaw = 0
    DesyncModule._suspendUntil = tick() + (DesyncModule.SafeStartDelay or 12)
    DesyncModule._wasDead = false
    desyncBindRenderFix()
    local currentCharacter = Players.LocalPlayer and Players.LocalPlayer.Character
    if currentCharacter then
        local root = currentCharacter:FindFirstChild("HumanoidRootPart")
        if root then
            DesyncModule._savedRealCFrame = root.CFrame
            DesyncModule._savedRealVelocity = root.AssemblyLinearVelocity
        end
        if DesyncModule.Silhouette then
            desyncRebuildGhostModel(currentCharacter)
        end
    end
    DesyncModule._characterAddedConnection = Players.LocalPlayer.CharacterAdded:Connect(function(character)
        DesyncModule._savedRealCFrame = nil
        DesyncModule._savedRealVelocity = nil
        DesyncModule._wasDead = false
        local baseDelay = DesyncModule.SafeStartDelay or 12
        if baseDelay < 10 then
            baseDelay = 10
        end
        DesyncModule._suspendUntil = tick() + baseDelay
        desyncDestroyGhostModel()
        if DesyncModule.Enabled and DesyncModule.Silhouette then
            task.defer(function()
                if DesyncModule.Enabled and DesyncModule.Silhouette and character and character.Parent and tick() >= DesyncModule._suspendUntil then
                    desyncRebuildGhostModel(character)
                end
            end)
        end
    end)
    DesyncModule._heartbeatConnection = RunService.Heartbeat:Connect(function(dt)
        if not DesyncModule.Enabled and not DesyncModule._stopping then return end
        local character = Players.LocalPlayer and Players.LocalPlayer.Character
        if not character then
            DesyncModule._savedRealCFrame = nil
            DesyncModule._savedRealVelocity = nil
            desyncDestroyGhostModel()
            if DesyncModule._stopping then
                desyncStop()
            end
            return
        end
        local root = character:FindFirstChild("HumanoidRootPart")
        if not root then
            DesyncModule._savedRealCFrame = nil
            DesyncModule._savedRealVelocity = nil
            desyncDestroyGhostModel()
            if DesyncModule._stopping then
                desyncStop()
            end
            return
        end
        local humanoid = character:FindFirstChildWhichIsA("Humanoid")
        if humanoid and humanoid.Health <= 0 then
            DesyncModule._wasDead = true
            DesyncModule._suspendUntil = math.huge
            desyncDestroyGhostModel()
            return
        end
        local suspended = (not DesyncModule._stopping) and (DesyncModule._wasDead or tick() < (DesyncModule._suspendUntil or 0))
        if suspended then
        elseif DesyncModule._wasDead then
            DesyncModule._wasDead = false
        end
        DesyncModule._savedRealCFrame = root.CFrame
        DesyncModule._savedRealVelocity = root.AssemblyLinearVelocity
        local targetPos = Vector3.new(0, 0, 0)
        local targetRot = Vector3.new(0, 0, 0)
        local dt2 = (type(dt) == "number" and dt > 0) and dt or (1 / 60)
        if (not DesyncModule._stopping) and (not suspended) then
            local mode = DesyncModule.Mode or "Custom"
            if mode == "Spinbot" then
                local spinSpeed = DesyncModule.SpinSpeed or 720
                local radius = DesyncModule.SpinRadius or 0
                local maxRadius = DesyncModule.SafeMaxRadius or 16
                if radius > maxRadius then
                    radius = maxRadius
                end
                DesyncModule._spinYaw = (DesyncModule._spinYaw or 0) + (spinSpeed * dt2)
                local angle = math.rad(DesyncModule._spinYaw)
                local x = math.cos(angle) * radius
                local z = math.sin(angle) * radius
                targetPos = Vector3.new(x, math.max(DesyncModule.Position.Y, DesyncModule.SafeMinY or -2), z)
                local baseYaw = DesyncModule.Rotation.Y or 0
                targetRot = Vector3.new(DesyncModule.Rotation.X or 0, baseYaw + (DesyncModule._spinYaw or 0), DesyncModule.Rotation.Z or 0)
            elseif mode == "SpazBot" then
                local radius = DesyncModule.SpazRadius or 1.5
                local maxRadius = DesyncModule.SafeMaxRadius or 16
                if radius > maxRadius then
                    radius = maxRadius
                end
                local bestPos = nil
                local bestRot = nil
                local baseCFrame = DesyncModule._savedRealCFrame or root.CFrame
                local tries = 0
                while tries < 8 do
                    tries = tries + 1
                    local rx = (math.random() * 2) - 1
                    local rz = (math.random() * 2) - 1
                    local len = math.sqrt(rx * rx + rz * rz)
                    if len < 1e-3 then
                        rx = 1
                        rz = 0
                        len = 1
                    end
                    rx = rx / len
                    rz = rz / len
                    local dist = radius * (0.3 + math.random() * 0.7)
                    local offset = Vector3.new(rx * dist, 0, rz * dist)
                    if desyncIsDirectionClear(baseCFrame, offset, character) then
                        local y = math.max(DesyncModule.SafeMinY or -2, -1)
                        bestPos = Vector3.new(offset.X, y, offset.Z)
                        local yawJitter = (math.random() * 60) - 30
                        bestRot = Vector3.new(0, yawJitter, 0)
                        break
                    end
                end
                if bestPos and bestRot then
                    targetPos = bestPos
                    targetRot = bestRot
                else
                    targetPos = Vector3.new(0, math.max(DesyncModule.SafeMinY or -2, -1), 0)
                    targetRot = Vector3.new(0, 0, 0)
                end
            else
                targetPos = Vector3.new(DesyncModule.Position.X, math.max(DesyncModule.Position.Y, DesyncModule.SafeMinY or -2), DesyncModule.Position.Z)
                targetRot = Vector3.new(DesyncModule.Rotation.X, DesyncModule.Rotation.Y, DesyncModule.Rotation.Z)
            end
        end
        local alpha = 1
        local rate = 12
        local modeForAlpha = DesyncModule.Mode or "Custom"
        if modeForAlpha == "SpazBot" then
            local sharp = DesyncModule.SpazSharpness or 8
            rate = 12 * math.max(0.25, sharp)
        end
        alpha = 1 - math.exp(-rate * dt2)
        DesyncModule._currentPos = DesyncModule._currentPos:Lerp(targetPos, alpha)
        DesyncModule._currentRot = DesyncModule._currentRot:Lerp(targetRot, alpha)
        if DesyncModule._stopping then
            if DesyncModule._currentPos.Magnitude < 0.05 and DesyncModule._currentRot.Magnitude < 0.05 then
                DesyncModule._stopping = false
                desyncStop()
                return
            end
        end
        local posOffset = DesyncModule._currentPos
        local rotOffset = CFrame.Angles(
            math.rad(DesyncModule._currentRot.X),
            math.rad(DesyncModule._currentRot.Y),
            math.rad(DesyncModule._currentRot.Z)
        )
        local baseCFrame = DesyncModule._savedRealCFrame or root.CFrame
        local spoofedCFrame = desyncGetSafeCFrame(root, baseCFrame, posOffset, rotOffset, character)
        local delta = spoofedCFrame * root.CFrame:Inverse()
        DesyncModule._lastSpoofedCFrame = spoofedCFrame
        if DesyncModule.Silhouette and (not suspended) then
            if (not DesyncModule._ghostModel or not DesyncModule._ghostModel.Parent) and character then
                desyncRebuildGhostModel(character)
            end
            for originalPart, ghostPart in pairs(DesyncModule._ghostMap) do
                if originalPart and originalPart.Parent and ghostPart and ghostPart.Parent then
                    ghostPart.CFrame = delta * originalPart.CFrame
                else
                    if ghostPart then
                        pcall(function()
                            ghostPart:Destroy()
                        end)
                    end
                    DesyncModule._ghostMap[originalPart] = nil
                end
            end
        else
            desyncDestroyGhostModel()
        end
        if not suspended then
            if not (FakeLagModule and FakeLagModule.Enabled) then
                root.CFrame = spoofedCFrame
            end
        end
    end)
end
local function desyncSetEnabled(value)
    if value then
        if _G.RH_IsConfigLoadingDesync == true then
            return
        end
        DesyncModule._suspendUntil = tick() + (DesyncModule.SafeStartDelay or 12)
        if not DesyncModule.Enabled then
            desyncStart()
        else
            DesyncModule._stopping = false
            DesyncModule.Enabled = true
        end
    else
        DesyncModule.Enabled = false
        DesyncModule._stopping = true
    end
end
_G.allvars.toggleDesync = desyncSetEnabled
pcall(function()
    RunService:UnbindFromRenderStep("Main_DesyncFix")
end)
for _, inst in ipairs(workspace:GetChildren()) do
    if inst:IsA("Model") and inst.Name == "DesyncSilhouette" then
        pcall(function()
            inst:Destroy()
        end)
    end
end
pcall(function()
    if type(_G.MainFakeLag_Stop) == "function" then
        _G.MainFakeLag_Stop()
    end
end)
do
    local env = _G
    env.FakeLagSettings = env.FakeLagSettings or {}
    FakeLagModule = env.FakeLagSettings
    if type(FakeLagModule.Delay) ~= "number" then FakeLagModule.Delay = 0.35 end
    if type(FakeLagModule.MaxDelay) ~= "number" then FakeLagModule.MaxDelay = 1.5 end
    if type(FakeLagModule.Silhouette) ~= "boolean" then FakeLagModule.Silhouette = true end
    if typeof(FakeLagModule.SilhouetteColor) ~= "Color3" then FakeLagModule.SilhouetteColor = Color3.fromRGB(255, 255, 255) end
    if type(FakeLagModule.SilhouetteThickness) ~= "number" then FakeLagModule.SilhouetteThickness = 0.001 end
    if type(FakeLagModule.SilhouetteTransparency) ~= "number" then FakeLagModule.SilhouetteTransparency = 0 end
    if type(FakeLagModule.SilhouetteIgnoreHRP) ~= "boolean" then FakeLagModule.SilhouetteIgnoreHRP = true end
    if MacLib and MacLib.Flags and typeof(MacLib.Flags["FakeLagFreezeKey"]) == "EnumItem" then
        FakeLagModule.FreezeKey = MacLib.Flags["FakeLagFreezeKey"]
    end
    if typeof(FakeLagModule.FreezeKey) ~= "EnumItem" or FakeLagModule.FreezeKey == Enum.KeyCode.V then
        FakeLagModule.FreezeKey = Enum.KeyCode.LeftAlt
    end
    if type(FakeLagModule.FreezeMaxDistance) ~= "number" then FakeLagModule.FreezeMaxDistance = 50 end
    if type(FakeLagModule.MaxSafeDelay) ~= "number" then FakeLagModule.MaxSafeDelay = 0.75 end
    if MacLib and MacLib.Flags and MacLib.Flags["FakeLagFreeze"] ~= nil then
        local b = coerceBool(MacLib.Flags["FakeLagFreeze"])
        if type(b) == "boolean" then
            FakeLagModule.FreezeBindEnabled = b
        end
    end
    if type(FakeLagModule.FreezeBindEnabled) ~= "boolean" then FakeLagModule.FreezeBindEnabled = false end
    if type(FakeLagModule.Freeze) ~= "boolean" then FakeLagModule.Freeze = false end
    if type(FakeLagModule.Enabled) ~= "boolean" then FakeLagModule.Enabled = false end
    FakeLagModule._ghostModel = nil
    FakeLagModule._ghostMap = {}
    FakeLagModule._ghostConnections = {}
    FakeLagModule._history = {}
    FakeLagModule._savedRealCFrame = nil
    FakeLagModule._savedRealVelocity = nil
    FakeLagModule._renderBound = false
    FakeLagModule._heartbeatConnection = nil
    FakeLagModule._freezeCFrame = nil
    FakeLagModule._freezeStartTime = nil
    FakeLagModule._freezeHistory = {}
    FakeLagModule._replayActive = false
    FakeLagModule._replayPath = nil
    FakeLagModule._replayStartTime = nil
    FakeLagModule._replayBaseTime = nil
    FakeLagModule._replayEndTime = nil
    FakeLagModule._replaySpeed = 2
    FakeLagModule._inputConnection = nil
    local function fakeLagBindRenderFix()
        if FakeLagModule._renderBound then
            return
        end
        FakeLagModule._renderBound = true
        RunService:BindToRenderStep("Main_FakeLagFix", Enum.RenderPriority.Camera.Value - 1, function()
            if not FakeLagModule.Enabled then
                return
            end
            local player = Players.LocalPlayer
            local character = player and player.Character
            if not character then
                return
            end
            local root = character:FindFirstChild("HumanoidRootPart")
            if not root then
                return
            end
            local realCF = FakeLagModule._savedRealCFrame
            if not realCF then
                return
            end
            root.CFrame = realCF
            local vel = FakeLagModule._savedRealVelocity
            if vel then
                root.AssemblyLinearVelocity = vel
            end
        end)
    end
    local function fakeLagUnbindRenderFix()
        if not FakeLagModule._renderBound then
            return
        end
        FakeLagModule._renderBound = false
        pcall(function()
            RunService:UnbindFromRenderStep("Main_FakeLagFix")
        end)
    end
    local function fakeLagDestroyGhostModel()
        for _, conn in ipairs(FakeLagModule._ghostConnections) do
            pcall(function()
                conn:Disconnect()
            end)
        end
        FakeLagModule._ghostConnections = {}
        FakeLagModule._ghostMap = {}
        if FakeLagModule._ghostModel then
            pcall(function()
                FakeLagModule._ghostModel:Destroy()
            end)
            FakeLagModule._ghostModel = nil
        end
    end
    local function fakeLagBeginReplayFromFreeze()
        local hist = FakeLagModule._freezeHistory
        if not hist or #hist < 2 then
            FakeLagModule._replayActive = false
            FakeLagModule._replayPath = nil
            FakeLagModule._replayStartTime = nil
            FakeLagModule._replayBaseTime = nil
            FakeLagModule._replayEndTime = nil
            FakeLagModule._freezeHistory = {}
            return
        end
        FakeLagModule._replayActive = true
        FakeLagModule._replayPath = hist
        FakeLagModule._replayStartTime = tick()
        FakeLagModule._replayBaseTime = hist[1].t
        FakeLagModule._replayEndTime = hist[#hist].t
        FakeLagModule._freezeHistory = {}
        FakeLagModule._freezeCFrame = nil
        FakeLagModule._freezeStartTime = nil
    end
    local function fakeLagSetFreezeActive(state)
        if state then
            if FakeLagModule.Freeze then
                return
            end
            FakeLagModule.Freeze = true
            FakeLagModule._freezeCFrame = nil
            FakeLagModule._freezeStartTime = tick()
            FakeLagModule._freezeHistory = {}
            return
        end
        if not FakeLagModule.Freeze then
            return
        end
        FakeLagModule.Freeze = false
        FakeLagModule._freezeCFrame = nil
        FakeLagModule._freezeStartTime = nil
        fakeLagBeginReplayFromFreeze()
    end
    local function fakeLagCreateGhostPartFor(part)
        if not part or not part:IsA("BasePart") then
            return
        end
        if FakeLagModule.SilhouetteIgnoreHRP and part.Name == "HumanoidRootPart" then
            return
        end
        if FakeLagModule._ghostMap[part] then
            return
        end
        if not FakeLagModule._ghostModel then
            return
        end
        local ghostPart = part:Clone()
        for _, child in ipairs(ghostPart:GetDescendants()) do
            child:Destroy()
        end
        ghostPart.Anchored = true
        ghostPart.CanCollide = false
        ghostPart.CanTouch = false
        ghostPart.CanQuery = false
        ghostPart.Massless = true
        ghostPart.Transparency = 1
        ghostPart.Name = part.Name .. "_FakeLagGhost"
        ghostPart.Parent = FakeLagModule._ghostModel
        local box = Instance.new("SelectionBox")
        box.Name = "BoxWireframe"
        box.Adornee = ghostPart
        box.Parent = ghostPart
        box.Color3 = FakeLagModule.SilhouetteColor
        box.LineThickness = FakeLagModule.SilhouetteThickness
        box.Transparency = FakeLagModule.SilhouetteTransparency
        box.SurfaceTransparency = 1
        FakeLagModule._ghostMap[part] = ghostPart
    end
    local function fakeLagRebuildGhostModel(character)
        fakeLagDestroyGhostModel()
        if not character then
            return
        end
        FakeLagModule._ghostModel = Instance.new("Model")
        FakeLagModule._ghostModel.Name = "FakeLagSilhouette"
        FakeLagModule._ghostModel.Parent = workspace
        for _, desc in ipairs(character:GetDescendants()) do
            if desc:IsA("BasePart") then
                fakeLagCreateGhostPartFor(desc)
            end
        end
        table.insert(FakeLagModule._ghostConnections, character.DescendantAdded:Connect(function(inst)
            if not FakeLagModule.Silhouette then
                return
            end
            if inst:IsA("BasePart") then
                fakeLagCreateGhostPartFor(inst)
            end
        end))
        table.insert(FakeLagModule._ghostConnections, character.AncestryChanged:Connect(function(_, parent)
            if parent == nil then
                fakeLagDestroyGhostModel()
            end
        end))
    end
    local function fakeLagGetDelayedCFrame(now)
        local history = FakeLagModule._history
        if not history or #history == 0 then
            return nil
        end
        local delay = FakeLagModule.Delay or 0.35
        local userMaxDelay = FakeLagModule.MaxDelay or 1.5
        local safeCap = FakeLagModule.MaxSafeDelay or userMaxDelay
        local maxDelay = math.min(userMaxDelay, safeCap)
        if delay < 0 then
            delay = 0
        elseif delay > maxDelay then
            delay = maxDelay
        end
        local targetTime = now - delay
        while #history > 2 and history[2].t <= targetTime do
            table.remove(history, 1)
        end
        local first = history[1]
        local second = history[2]
        if not second or targetTime <= first.t then
            return first.cf
        end
        if targetTime >= second.t then
            return second.cf
        end
        local span = second.t - first.t
        if span <= 0 then
            return first.cf
        end
        local alpha = (targetTime - first.t) / span
        if alpha < 0 then
            alpha = 0
        elseif alpha > 1 then
            alpha = 1
        end
        return first.cf:Lerp(second.cf, alpha)
    end
    local function fakeLagRestoreCharacter()
        local player = Players.LocalPlayer
        local character = player and player.Character
        if not character then
            return
        end
        local root = character:FindFirstChild("HumanoidRootPart")
        if not root then
            return
        end
        local realCF = FakeLagModule._savedRealCFrame
        if realCF then
            root.CFrame = realCF
            local vel = FakeLagModule._savedRealVelocity
            if vel then
                root.AssemblyLinearVelocity = vel
            end
            pcall(function()
                root.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
            end)
        end
        FakeLagModule._savedRealCFrame = nil
        FakeLagModule._savedRealVelocity = nil
    end
    local function fakeLagStop()
        FakeLagModule.Enabled = false
        FakeLagModule.Freeze = false
        FakeLagModule._freezeCFrame = nil
        FakeLagModule._freezeStartTime = nil
        FakeLagModule._freezeHistory = {}
        FakeLagModule._replayActive = false
        FakeLagModule._replayPath = nil
        FakeLagModule._replayStartTime = nil
        FakeLagModule._replayBaseTime = nil
        FakeLagModule._replayEndTime = nil
        if FakeLagModule._heartbeatConnection then
            pcall(function()
                FakeLagModule._heartbeatConnection:Disconnect()
            end)
            FakeLagModule._heartbeatConnection = nil
        end
        if FakeLagModule._inputConnection then
            pcall(function()
                FakeLagModule._inputConnection:Disconnect()
            end)
            FakeLagModule._inputConnection = nil
        end
        fakeLagUnbindRenderFix()
        fakeLagDestroyGhostModel()
        fakeLagRestoreCharacter()
        FakeLagModule._history = {}
    end
    local function fakeLagStart()
        if FakeLagModule._heartbeatConnection then
            pcall(function()
                FakeLagModule._heartbeatConnection:Disconnect()
            end)
            FakeLagModule._heartbeatConnection = nil
        end
        FakeLagModule.Enabled = true
        FakeLagModule._history = {}
        FakeLagModule._freezeCFrame = nil
        FakeLagModule._freezeStartTime = nil
        FakeLagModule._freezeHistory = {}
        FakeLagModule._replayActive = false
        FakeLagModule._replayPath = nil
        FakeLagModule._replayStartTime = nil
        FakeLagModule._replayBaseTime = nil
        FakeLagModule._replayEndTime = nil
        FakeLagModule._savedRealCFrame = nil
        FakeLagModule._savedRealVelocity = nil
        local player = Players.LocalPlayer
        local character = player and player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local root = character.HumanoidRootPart
            local now = tick()
            table.insert(FakeLagModule._history, { t = now, cf = root.CFrame })
            if FakeLagModule.Silhouette then
                fakeLagRebuildGhostModel(character)
            end
        end
        fakeLagBindRenderFix()
        if FakeLagModule._inputConnection then
            pcall(function()
                FakeLagModule._inputConnection:Disconnect()
            end)
            FakeLagModule._inputConnection = nil
        end
        FakeLagModule._inputConnection = UserInputService.InputBegan:Connect(function(input)
            if not FakeLagModule.Enabled then
                return
            end
            local uiEnabled = nil
            if MacLib and MacLib.Flags and MacLib.Flags["EnableFakeLag"] ~= nil then
                uiEnabled = coerceBool(MacLib.Flags["EnableFakeLag"])
            else
                local el = ESP and ESP._ui and ESP._ui.fakeLagEnableToggleEl
                if el then
                    local v = rawget(el, "Value") or rawget(el, "Enabled") or rawget(el, "Toggled") or rawget(el, "State") or rawget(el, "Toggle")
                    uiEnabled = coerceBool(v)
                end
            end
            if uiEnabled == false then
                return
            end
            local key = FakeLagModule.FreezeKey
            if typeof(key) ~= "EnumItem" then
                key = Enum.KeyCode.LeftAlt
                FakeLagModule.FreezeKey = key
            end
            local inputKey = input.KeyCode
            local matches
            if key == Enum.KeyCode.LeftAlt or key == Enum.KeyCode.RightAlt then
                matches = (inputKey == Enum.KeyCode.LeftAlt or inputKey == Enum.KeyCode.RightAlt)
            else
                matches = (inputKey == key)
            end
            if not matches then
                return
            end
            local freezeBindOn = FakeLagModule.FreezeBindEnabled and true or false
            if MacLib and MacLib.Flags and MacLib.Flags["FakeLagFreeze"] ~= nil then
                local b = coerceBool(MacLib.Flags["FakeLagFreeze"])
                if type(b) == "boolean" then
                    freezeBindOn = b
                end
            end
            local el = ESP and ESP._ui and ESP._ui.fakeLagFreezeToggleEl
            if el then
                local v = rawget(el, "Value") or rawget(el, "Enabled") or rawget(el, "Toggled") or rawget(el, "State") or rawget(el, "Toggle")
                local b = coerceBool(v)
                if type(b) == "boolean" then
                    freezeBindOn = b
                end
            end
            if not freezeBindOn then
                return
            end
            fakeLagSetFreezeActive(not FakeLagModule.Freeze)
        end)
        FakeLagModule._heartbeatConnection = RunService.Heartbeat:Connect(function()
            if not FakeLagModule.Enabled then
                return
            end
            local plr = Players.LocalPlayer
            local char = plr and plr.Character
            if not char then
                fakeLagDestroyGhostModel()
                FakeLagModule._history = {}
                FakeLagModule._savedRealCFrame = nil
                FakeLagModule._savedRealVelocity = nil
                return
            end
            local root = char:FindFirstChild("HumanoidRootPart")
            if not root then
                fakeLagDestroyGhostModel()
                FakeLagModule._history = {}
                FakeLagModule._savedRealCFrame = nil
                FakeLagModule._savedRealVelocity = nil
                return
            end
            local now = tick()
            local realCF = root.CFrame
            FakeLagModule._savedRealCFrame = realCF
            FakeLagModule._savedRealVelocity = root.AssemblyLinearVelocity
            local sourceCF = realCF
            if DesyncModule and DesyncModule.Enabled and typeof(DesyncModule._lastSpoofedCFrame) == "CFrame" then
                sourceCF = DesyncModule._lastSpoofedCFrame
            end
            if not FakeLagModule.Freeze then
                table.insert(FakeLagModule._history, { t = now, cf = sourceCF })
                local maxDelay = FakeLagModule.MaxDelay or 1.5
                local oldest = now - maxDelay - 0.25
                while #FakeLagModule._history > 0 and FakeLagModule._history[1].t < oldest do
                    table.remove(FakeLagModule._history, 1)
                end
            else
                FakeLagModule._freezeHistory = FakeLagModule._freezeHistory or {}
                table.insert(FakeLagModule._freezeHistory, { t = now, cf = sourceCF })
                local maxLen = 256
                if #FakeLagModule._freezeHistory > maxLen then
                    table.remove(FakeLagModule._freezeHistory, 1)
                end
            end
            if FakeLagModule.Silhouette then
                if (not FakeLagModule._ghostModel or not FakeLagModule._ghostModel.Parent) then
                    fakeLagRebuildGhostModel(char)
                end
            else
                fakeLagDestroyGhostModel()
            end
            if FakeLagModule.Freeze then
                if not FakeLagModule._freezeCFrame then
                    FakeLagModule._freezeCFrame = sourceCF
                    FakeLagModule._freezeStartTime = now
                end
                local maxDist = FakeLagModule.FreezeMaxDistance or 50
                if type(maxDist) ~= "number" then
                    maxDist = 50
                    FakeLagModule.FreezeMaxDistance = maxDist
                end
                local dist = (realCF.Position - FakeLagModule._freezeCFrame.Position).Magnitude
                local tooFar = dist > maxDist
                if tooFar then
                    fakeLagSetFreezeActive(false)
                end
            end
            local delayedCF
            if FakeLagModule._replayActive and FakeLagModule._replayPath and FakeLagModule._replayStartTime and FakeLagModule._replayBaseTime and FakeLagModule._replayEndTime then
                local speed = FakeLagModule._replaySpeed or 2
                local elapsed = now - FakeLagModule._replayStartTime
                local playbackTime = FakeLagModule._replayBaseTime + elapsed * speed
                local endTime = FakeLagModule._replayEndTime
                local path = FakeLagModule._replayPath
                if playbackTime >= endTime or #path < 1 then
                    FakeLagModule._replayActive = false
                    FakeLagModule._replayPath = nil
                    FakeLagModule._replayStartTime = nil
                    FakeLagModule._replayBaseTime = nil
                    FakeLagModule._replayEndTime = nil
                    delayedCF = FakeLagModule.Freeze and FakeLagModule._freezeCFrame or fakeLagGetDelayedCFrame(now)
                else
                    local first = path[1]
                    local last = path[#path]
                    if playbackTime <= first.t then
                        delayedCF = first.cf
                    elseif playbackTime >= last.t then
                        delayedCF = last.cf
                    else
                        local segCF = last.cf
                        for i = 2, #path do
                            local prev = path[i - 1]
                            local nxt = path[i]
                            if playbackTime <= nxt.t then
                                local span = nxt.t - prev.t
                                if span <= 0 then
                                    segCF = prev.cf
                                else
                                    local alpha = (playbackTime - prev.t) / span
                                    if alpha < 0 then
                                        alpha = 0
                                    elseif alpha > 1 then
                                        alpha = 1
                                    end
                                    segCF = prev.cf:Lerp(nxt.cf, alpha)
                                end
                                break
                            end
                        end
                        delayedCF = segCF
                    end
                end
            else
                delayedCF = FakeLagModule.Freeze and FakeLagModule._freezeCFrame or fakeLagGetDelayedCFrame(now)
            end
            if not delayedCF then
                return
            end
            local delta = delayedCF * root.CFrame:Inverse()
            for originalPart, ghostPart in pairs(FakeLagModule._ghostMap) do
                if originalPart and originalPart.Parent and ghostPart and ghostPart.Parent then
                    ghostPart.CFrame = delta * originalPart.CFrame
                else
                    if ghostPart then
                        pcall(function()
                            ghostPart:Destroy()
                        end)
                    end
                    FakeLagModule._ghostMap[originalPart] = nil
                end
            end
            root.CFrame = delayedCF
        end)
    end
    local function fakeLagSetEnabled(state)
        if state then
            if FakeLagModule.Enabled then
                return
            end
            fakeLagStart()
        else
            if not FakeLagModule.Enabled then
                return
            end
            fakeLagStop()
        end
    end
    _G.MainFakeLag_Stop = fakeLagStop
    _G.FakeLag_SetEnabled = fakeLagSetEnabled
    if _G and _G.allvars then
        _G.allvars.toggleFakeLag = fakeLagSetEnabled
    end
end
pcall(function()
    RunService:UnbindFromRenderStep("Main_FakeLagFix")
end)
for _, inst in ipairs(workspace:GetChildren()) do
    if inst:IsA("Model") and inst.Name == "FakeLagSilhouette" then
        pcall(function()
            inst:Destroy()
        end)
    end
end
local desyncSection = tabs.Player:Section({ Side = "Right", Name = "Desync" })
desyncSection:Header({ Text = "Desync [Detection Risk]" })
ESP._ui.desyncEnableToggleEl = desyncSection:Toggle({
    Name = "Enable Desync",
    Default = false,
    Callback = function(value)
        desyncSetEnabled(value)
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "EnableDesync")
ESP._ui.desyncSilhouetteToggleEl = desyncSection:Toggle({
    Name = "Desync Silhouette",
    Default = false,
    Callback = function(value)
        DesyncModule.Silhouette = value
        if not value then
            desyncDestroyGhostModel()
        elseif DesyncModule.Enabled then
            local character = Players.LocalPlayer and Players.LocalPlayer.Character
            if character then
                desyncRebuildGhostModel(character)
            end
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "DesyncSilhouette")
ESP._ui.desyncIgnoreHRPToggleEl = desyncSection:Toggle({
    Name = "Ignore HRP",
    Default = true,
    Callback = function(value)
        DesyncModule.SilhouetteIgnoreHRP = value
        if DesyncModule.Silhouette then
            local character = Players.LocalPlayer and Players.LocalPlayer.Character
            if character then
                desyncRebuildGhostModel(character)
            end
        end
    end
}, "DesyncIgnoreHRP")
ESP._ui.desyncSilhouetteColorPickerEl = desyncSection:Colorpicker({
    Name = "Silhouette Color",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(color)
        DesyncModule.SilhouetteColor = color
        for _, ghostPart in pairs(DesyncModule._ghostMap) do
            local box = ghostPart and ghostPart:FindFirstChild("BoxWireframe")
            if box then
                box.Color3 = color
            end
        end
    end
}, "DesyncSilhouetteColor")
ESP._ui.desyncModeDropdownEl = desyncSection:Dropdown({
    Name = "Mode",
    Multi = false,
    Required = true,
    Options = {"Custom", "Spinbot", "SpazBot"},
    Default = "Custom",
    Callback = function(value)
        DesyncModule.Mode = value
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "DesyncMode")
ESP._ui.desyncOffsetXSliderEl = desyncSection:Slider({
    Name = "Offset X",
    Default = 0,
    Minimum = -10,
    Maximum = 10,
    Precision = 2,
    Callback = function(value)
        DesyncModule.Position.X = value
    end
}, "DesyncOffsetX")
ESP._ui.desyncOffsetYSliderEl = desyncSection:Slider({
    Name = "Offset Y",
    Default = 0,
    Minimum = -2,
    Maximum = 10,
    Precision = 2,
    Callback = function(value)
        DesyncModule.Position.Y = math.max(value, -2)
    end
}, "DesyncOffsetY")
ESP._ui.desyncOffsetZSliderEl = desyncSection:Slider({
    Name = "Offset Z",
    Default = 0,
    Minimum = -10,
    Maximum = 10,
    Precision = 2,
    Callback = function(value)
        DesyncModule.Position.Z = value
    end
}, "DesyncOffsetZ")
ESP._ui.desyncRotXSliderEl = desyncSection:Slider({
    Name = "Rotation X",
    Default = 0,
    Minimum = -180,
    Maximum = 180,
    Precision = 0,
    Callback = function(value)
        DesyncModule.Rotation.X = value
    end
}, "DesyncRotX")
ESP._ui.desyncRotYSliderEl = desyncSection:Slider({
    Name = "Rotation Y",
    Default = 0,
    Minimum = -180,
    Maximum = 180,
    Precision = 0,
    Callback = function(value)
        DesyncModule.Rotation.Y = value
    end
}, "DesyncRotY")
ESP._ui.desyncRotZSliderEl = desyncSection:Slider({
    Name = "Rotation Z",
    Default = 0,
    Minimum = -180,
    Maximum = 180,
    Precision = 0,
    Callback = function(value)
        DesyncModule.Rotation.Z = value
    end
}, "DesyncRotZ")
ESP._ui.desyncSpinSpeedSliderEl = desyncSection:Slider({
    Name = "Spin Speed",
    Default = 720,
    Minimum = 90,
    Maximum = 1440,
    Precision = 0,
    Callback = function(value)
        DesyncModule.SpinSpeed = value
    end
}, "DesyncSpinSpeed")
ESP._ui.desyncSpazRadiusSliderEl = desyncSection:Slider({
    Name = "Spaz Radius",
    Default = 1.5,
    Minimum = 0.1,
    Maximum = 12,
    Precision = 2,
    Callback = function(value)
        DesyncModule.SpazRadius = value
    end
}, "DesyncSpazRadius")
ESP._ui.desyncSpazSharpnessSliderEl = desyncSection:Slider({
    Name = "Spaz Sharpness",
    Default = 8,
    Minimum = 1,
    Maximum = 25,
    Precision = 1,
    Callback = function(value)
        DesyncModule.SpazSharpness = value
    end
}, "DesyncSpazSharpness")
local fakeLagSection = tabs.Player:Section({ Side = "Right", Name = "Fake Lag" })
fakeLagSection:Header({ Text = "Fake Lag" })
ESP._ui.fakeLagEnableToggleEl = fakeLagSection:Toggle({
    Name = "Enable Fake Lag",
    Default = false,
    Callback = function(value)
        if _G and _G.allvars and type(_G.allvars.toggleFakeLag) == "function" then
            _G.allvars.toggleFakeLag(value)
        elseif type(_G.FakeLag_SetEnabled) == "function" then
            _G.FakeLag_SetEnabled(value)
        else
            FakeLagModule.Enabled = value and true or false
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "EnableFakeLag")
ESP._ui.fakeLagDelaySliderEl = fakeLagSection:Slider({
    Name = "Delay",
    Default = 0.35,
    Minimum = 0,
    Maximum = 1.5,
    Precision = 2,
    Callback = function(value)
        FakeLagModule.Delay = value
        if type(FakeLagModule.MaxDelay) == "number" and FakeLagModule.Delay > FakeLagModule.MaxDelay then
            FakeLagModule.Delay = FakeLagModule.MaxDelay
        end
    end
}, "FakeLagDelay")
ESP._ui.fakeLagMaxDelaySliderEl = fakeLagSection:Slider({
    Name = "Max Delay",
    Default = 1.5,
    Minimum = 0.1,
    Maximum = 3,
    Precision = 2,
    Callback = function(value)
        FakeLagModule.MaxDelay = value
        if type(FakeLagModule.Delay) == "number" and FakeLagModule.Delay > FakeLagModule.MaxDelay then
            FakeLagModule.Delay = FakeLagModule.MaxDelay
        end
    end
}, "FakeLagMaxDelay")
ESP._ui.fakeLagFreezeToggleEl = fakeLagSection:Toggle({
    Name = "Enable Freeze Bind",
    Default = FakeLagModule.FreezeBindEnabled and true or false,
    Callback = function(value)
        FakeLagModule.FreezeBindEnabled = value and true or false
        if MacLib and MacLib.Flags then
            MacLib.Flags["FakeLagFreeze"] = FakeLagModule.FreezeBindEnabled
        end
        if not FakeLagModule.FreezeBindEnabled then
            fakeLagSetFreezeActive(false)
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "FakeLagFreeze")
ESP._ui.fakeLagFreezeKeybindEl = fakeLagSection:Keybind({
    Name = "Freeze Key",
    Default = FakeLagModule.FreezeKey,
    Flag = "FakeLagFreezeKey",
    Callback = function(key)
        local k = key
        if typeof(k) ~= "EnumItem" and type(k) == "table" then
            local fields = {"Key", "Value", "SelectedKey", "Bind"}
            for _, f in ipairs(fields) do
                local v = k[f]
                if typeof(v) == "EnumItem" then
                    k = v
                    break
                end
            end
        end
        if typeof(k) ~= "EnumItem" then
            return
        end
        FakeLagModule.FreezeKey = k
        if MacLib and MacLib.Flags then
            MacLib.Flags["FakeLagFreezeKey"] = k
        end
    end,
    KeyChanged = function(key)
        local k = key
        if typeof(k) ~= "EnumItem" and type(k) == "table" then
            local fields = {"Key", "Value", "SelectedKey", "Bind"}
            for _, f in ipairs(fields) do
                local v = k[f]
                if typeof(v) == "EnumItem" then
                    k = v
                    break
                end
            end
        end
        if typeof(k) ~= "EnumItem" then
            return
        end
        FakeLagModule.FreezeKey = k
        if MacLib and MacLib.Flags then
            MacLib.Flags["FakeLagFreezeKey"] = k
        end
    end
})
ESP._ui.fakeLagSilhouetteToggleEl = fakeLagSection:Toggle({
    Name = "Silhouette",
    Default = true,
    Callback = function(value)
        FakeLagModule.Silhouette = value and true or false
        if not FakeLagModule.Silhouette then
            if FakeLagModule._ghostModel then
                pcall(function()
                    FakeLagModule._ghostModel:Destroy()
                end)
            end
            FakeLagModule._ghostModel = nil
            FakeLagModule._ghostMap = {}
        elseif FakeLagModule.Enabled then
            local player = Players.LocalPlayer
            local character = player and player.Character
            if character then
                pcall(function()
                    if _G and _G.allvars and type(_G.allvars.toggleFakeLag) == "function" then
                        FakeLagModule._ghostModel = nil
                    end
                end)
            end
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "FakeLagSilhouette")
ESP._ui.fakeLagIgnoreHRPToggleEl = fakeLagSection:Toggle({
    Name = "Ignore HRP",
    Default = true,
    Callback = function(value)
        FakeLagModule.SilhouetteIgnoreHRP = value and true or false
        if FakeLagModule.Enabled and FakeLagModule.Silhouette then
            local player = Players.LocalPlayer
            local character = player and player.Character
            if character and FakeLagModule._ghostModel then
                pcall(function()
                    FakeLagModule._ghostModel:Destroy()
                end)
                FakeLagModule._ghostModel = nil
                FakeLagModule._ghostMap = {}
            end
        end
    end
}, "FakeLagIgnoreHRP")
ESP._ui.fakeLagSilhouetteColorPickerEl = fakeLagSection:Colorpicker({
    Name = "Silhouette Color",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(color)
        FakeLagModule.SilhouetteColor = color
        for _, ghostPart in pairs(FakeLagModule._ghostMap or {}) do
            local box = ghostPart and ghostPart:FindFirstChild("BoxWireframe")
            if box then
                box.Color3 = color
            end
        end
    end
}, "FakeLagSilhouetteColor")
ESP._ui.fakeLagThicknessSliderEl = fakeLagSection:Slider({
    Name = "Line Thickness",
    Default = 0.001,
    Minimum = 0.0001,
    Maximum = 0.02,
    Precision = 4,
    Callback = function(value)
        FakeLagModule.SilhouetteThickness = value
        for _, ghostPart in pairs(FakeLagModule._ghostMap or {}) do
            local box = ghostPart and ghostPart:FindFirstChild("BoxWireframe")
            if box then
                box.LineThickness = value
            end
        end
    end
}, "FakeLagThickness")
ESP._ui.fakeLagTransparencySliderEl = fakeLagSection:Slider({
    Name = "Line Transparency",
    Default = 0,
    Minimum = 0,
    Maximum = 1,
    Precision = 2,
    Callback = function(value)
        FakeLagModule.SilhouetteTransparency = value
        for _, ghostPart in pairs(FakeLagModule._ghostMap or {}) do
            local box = ghostPart and ghostPart:FindFirstChild("BoxWireframe")
            if box then
                box.Transparency = value
            end
        end
    end
}, "FakeLagTransparency")
if ESP and ESP._ui and ESP._ui._syncESPVisibility then
    ESP._ui._syncESPVisibility()
end
sections.PlayerMovement:Header({
    Text = "Movement Settings"
})
sections.PlayerMovement:Toggle({
    Name = "Enable SpeedHack",
    Default = false,
    Callback = function(value)
        CFrameSpeed.Enabled = value
        if CFrameSpeed.Enabled then
            if CFrameSpeed.Connection then CFrameSpeed.Connection:Disconnect() end
            CFrameSpeed.Connection = RunService.RenderStepped:Connect(function()
                local player = Players.LocalPlayer
                local character = player.Character
                if not character or not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChild("Humanoid") then return end
                local hrp = character.HumanoidRootPart
                local humanoid = character.Humanoid
                if humanoid.MoveDirection.Magnitude > 0 or (CFrameSpeed.KeysEnabled.Space and UserInputService:IsKeyDown(Enum.KeyCode.Space)) then
                    local moveDirection = Vector3.new(0, 0, 0)
                    if CFrameSpeed.KeysEnabled.W and UserInputService:IsKeyDown(Enum.KeyCode.W) then
                        moveDirection = moveDirection + (Workspace.CurrentCamera.CFrame.LookVector * Vector3.new(1, 0, 1)).Unit
                    end
                    if CFrameSpeed.KeysEnabled.S and UserInputService:IsKeyDown(Enum.KeyCode.S) then
                        moveDirection = moveDirection - (Workspace.CurrentCamera.CFrame.LookVector * Vector3.new(1, 0, 1)).Unit
                    end
                    if CFrameSpeed.KeysEnabled.A and UserInputService:IsKeyDown(Enum.KeyCode.A) then
                        moveDirection = moveDirection - (Workspace.CurrentCamera.CFrame.RightVector * Vector3.new(1, 0, 1)).Unit
                    end
                    if CFrameSpeed.KeysEnabled.D and UserInputService:IsKeyDown(Enum.KeyCode.D) then
                        moveDirection = moveDirection + (Workspace.CurrentCamera.CFrame.RightVector * Vector3.new(1, 0, 1)).Unit
                    end
                    if CFrameSpeed.KeysEnabled.Space and UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                        moveDirection = moveDirection + Vector3.new(0, 1, 0)
                    end
                    if moveDirection.Magnitude > 0 then
                        moveDirection = moveDirection.Unit
                    end
                    hrp.CFrame = hrp.CFrame + moveDirection * CFrameSpeed.Speed
                end
            end)
        else
            if CFrameSpeed.Connection then
                CFrameSpeed.Connection:Disconnect()
                CFrameSpeed.Connection = nil
            end
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "EnableSpeedHack")
ESP._ui.playerFastWalkToggleEl = sections.PlayerMovement:Toggle({
    Name = "Fast Walk",
    Default = false,
    Callback = function(value)
        CFrameSpeed.FastWalkEnabled = value
        CFrameSpeed.DirectWalkSpeedEnabled = value
        if CFrameSpeed.WalkSpeedConnection then
            CFrameSpeed.WalkSpeedConnection:Disconnect()
            CFrameSpeed.WalkSpeedConnection = nil
        end
        if value then
            CFrameSpeed.OriginalSpeed = CFrameSpeed.Speed
            CFrameSpeed.Speed = CFrameSpeed.FastWalkSpeed
            CFrameSpeed.WalkSpeedConnection = RunService.Heartbeat:Connect(function()
                local player = Players.LocalPlayer
                if not player then return end
                local character = player.Character
                if not character then return end
                local humanoid = character:FindFirstChild("Humanoid")
                if not humanoid then return end
                if not CFrameSpeed.OriginalWalkSpeedSaved then
                    CFrameSpeed.OriginalWalkSpeed = humanoid.WalkSpeed
                    CFrameSpeed.OriginalWalkSpeedSaved = true
                end
                humanoid.WalkSpeed = CFrameSpeed.FastWalkSpeedValue
            end)
            if not CFrameSpeed.Enabled then
                CFrameSpeed.Enabled = true
                if CFrameSpeed.Connection then
                    CFrameSpeed.Connection:Disconnect()
                end
                CFrameSpeed.Connection = RunService.RenderStepped:Connect(function()
                    local player = Players.LocalPlayer
                    local character = player.Character
                    if not character or not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChild("Humanoid") then return end
                    local hrp = character.HumanoidRootPart
                    local humanoid = character.Humanoid
                    if humanoid.MoveDirection.Magnitude > 0 or (CFrameSpeed.KeysEnabled.Space and UserInputService:IsKeyDown(Enum.KeyCode.Space)) then
                        local moveDirection = Vector3.new(0, 0, 0)
                        if CFrameSpeed.KeysEnabled.W and UserInputService:IsKeyDown(Enum.KeyCode.W) then
                            moveDirection = moveDirection + (Workspace.CurrentCamera.CFrame.LookVector * Vector3.new(1, 0, 1)).Unit
                        end
                        if CFrameSpeed.KeysEnabled.S and UserInputService:IsKeyDown(Enum.KeyCode.S) then
                            moveDirection = moveDirection - (Workspace.CurrentCamera.CFrame.LookVector * Vector3.new(1, 0, 1)).Unit
                        end
                        if CFrameSpeed.KeysEnabled.A and UserInputService:IsKeyDown(Enum.KeyCode.A) then
                            moveDirection = moveDirection - (Workspace.CurrentCamera.CFrame.RightVector * Vector3.new(1, 0, 1)).Unit
                        end
                        if CFrameSpeed.KeysEnabled.D and UserInputService:IsKeyDown(Enum.KeyCode.D) then
                            moveDirection = moveDirection + (Workspace.CurrentCamera.CFrame.RightVector * Vector3.new(1, 0, 1)).Unit
                        end
                        if CFrameSpeed.KeysEnabled.Space and UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                            moveDirection = moveDirection + Vector3.new(0, 1, 0)
                        end
                        if moveDirection.Magnitude > 0 then
                            moveDirection = moveDirection.Unit
                        end
                        hrp.CFrame = hrp.CFrame + moveDirection * CFrameSpeed.Speed
                    end
                end)
            end
        else
            CFrameSpeed.Speed = CFrameSpeed.OriginalSpeed
            if CFrameSpeed.OriginalWalkSpeedSaved then
                local player = Players.LocalPlayer
                if player and player.Character and player.Character:FindFirstChild("Humanoid") then
                    player.Character.Humanoid.WalkSpeed = CFrameSpeed.OriginalWalkSpeed
                end
                CFrameSpeed.OriginalWalkSpeedSaved = false
            end
            if CFrameSpeed.Connection and not CFrameSpeed.Enabled then
                CFrameSpeed.Connection:Disconnect()
                CFrameSpeed.Connection = nil
            end
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "FastWalk")
if ESP and ESP._ui and ESP._ui._syncESPVisibility then
    ESP._ui._syncESPVisibility()
end
sections.PlayerMovement:Toggle({
    Name = "Jesus (Walk on Water)",
    Default = false,
    Callback = function(value)
        JesusEnabled = value
        if not value then
             if waterplatforms then
                for _, v in ipairs(waterplatforms:GetChildren()) do
                    v:Destroy()
                end
            end
        end
    end
}, "JesusToggle")
ESP._ui.playerNoFallToggleEl = sections.PlayerMovement:Toggle({
    Name = "No Fall Damage",
    Default = false,
    Callback = function(value)
        nofall = value
        if not value and instafall then
            instafall = false
            if ESP and ESP._ui and ESP._ui.playerInstaFallToggleEl then
                pcall(function()
                    if ESP._ui.playerInstaFallToggleEl.Set then
                        ESP._ui.playerInstaFallToggleEl:Set(false)
                    end
                end)
            end
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "NoFallToggle")
ESP._ui.playerInstaFallToggleEl = sections.PlayerMovement:Toggle({
    Name = "Insta Fall",
    Default = false,
    Callback = function(value)
        if value and not nofall then
            nofall = true
            if ESP and ESP._ui and ESP._ui.playerNoFallToggleEl then
                pcall(function()
                    if ESP._ui.playerNoFallToggleEl.Set then
                        ESP._ui.playerNoFallToggleEl:Set(true)
                    end
                end)
            end
        end
        instafall = value
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "InstaFallToggle")
if ESP and ESP._ui and ESP._ui._syncESPVisibility then
    ESP._ui._syncESPVisibility()
end
local function updateJesusPlatforms()
    if not JesusEnabled or not localplayer or not localplayer.Character or not localplayer.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    local hrp = localplayer.Character.HumanoidRootPart
    local origin = hrp.Position
    local direction = Vector3.new(0, -5, 0) + hrp.CFrame.LookVector * 5
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {localplayer.Character}
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.IgnoreWater = false
    local hitPart = workspace:Raycast(origin, direction, params)
    if hitPart and hitPart.Material == Enum.Material.Water then
        local clone = Instance.new("Part")
        clone.Parent = waterplatforms
        clone.Position = hitPart.Position
        clone.Anchored = true
        clone.CanCollide = true
        clone.Size = Vector3.new(10, 0.2, 10)
        clone.Transparency = 1
        clone.Name = "JesusPlatform"
    end
end
_G.allvars._rt.track(runs.RenderStepped:Connect(updateJesusPlatforms))
local INV_CURRENCY = utf8 and utf8.char and utf8.char(0x20BD) or "RUB"
InventoryViewer = {
    Enabled = false,
    GUIEnabled = false,
    ScreenGui = nil,
    MainContainer = nil,
    ScrollingFrame = nil,
    HotbarScrollingFrame = nil,
    ArmorScrollingFrame = nil,
    UpdateConnection = nil,
    RespawnConnection = nil,
    Theme = {
        Background = Color3.fromRGB(25, 25, 25),
        Border = Color3.fromRGB(60, 60, 60),
        Text = Color3.fromRGB(255, 255, 255),
        ItemBg = Color3.fromRGB(40, 40, 40),
        ItemHover = Color3.fromRGB(70, 70, 70),
        SlotBg = Color3.fromRGB(20, 20, 20)
    },
    CompactMode = true
}
local inventoryViewerSection = sections.PlayerInventory
inventoryViewerSection:Header({
    Text = "Inventory Viewer "
})
local function setupInventoryViewerRespawnHandler()
    if InventoryViewer.RespawnConnection then
        InventoryViewer.RespawnConnection:Disconnect()
        InventoryViewer.RespawnConnection = nil
    end
    InventoryViewer.RespawnConnection = Players.LocalPlayer.CharacterAdded:Connect(function()
        if InventoryViewer.Enabled and InventoryViewer.ScreenGui then
            local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui", 10)
            if playerGui and InventoryViewer.ScreenGui then
                InventoryViewer.ScreenGui.Parent = playerGui
            end
        end
    end)
end
inventoryViewerSection:Toggle({
    Name = "Enable",
    Default = false,
    Callback = function(value)
        InventoryViewer.Enabled = value
        if InventoryViewer.Enabled then
            if not InventoryViewer.ScreenGui then
                local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui", 10)
                if not playerGui then return end
                local screenGui = CreateInstance("ScreenGui", {
                    Name = "PlayerModelFinder",
                    Parent = playerGui,
                    ResetOnSpawn = false,
                    ZIndexBehavior = Enum.ZIndexBehavior.Global,
                    DisplayOrder = 1000
                })
                InventoryViewer.ScreenGui = screenGui
                local mainContainer = CreateInstance("Frame", {
                    Name = "MainContainer",
                    Parent = screenGui,
                    Size = UDim2.new(0, 420, 0, 265),
                    Position = UDim2.new(0.5, -210, 1, -378),
                    BackgroundTransparency = 1,
                    BorderSizePixel = 0
                })
                local realHotbar = CreateInstance("Frame", {
                    Name = "RealHotbar",
                    Parent = mainContainer,
                    Size = UDim2.new(0, 420, 0, 55),
                    Position = UDim2.new(0.5, -210, 1, -65),
                    BackgroundColor3 = InventoryViewer.Theme.Background,
                    BackgroundTransparency = 0.25,
                    BorderSizePixel = 0
                })
                CreateInstance("UICorner", {
                    CornerRadius = UDim.new(0, 20),
                    Parent = realHotbar
                })
                CreateInstance("UIStroke", {
                    Color = InventoryViewer.Theme.Border,
                    Thickness = 1,
                    Transparency = 0.25,
                    Parent = realHotbar
                })
                local function CreateInventoryHeaderLabel(parent, name, text, bgTransparency)
                    local label = CreateInstance("TextLabel", {
                        Name = name,
                        Parent = parent,
                        Size = UDim2.new(0, 80, 0, 20),
                        Position = UDim2.new(0, 10, 0, -22),
                        BackgroundColor3 = InventoryViewer.Theme.Background,
                        BackgroundTransparency = bgTransparency or 0.25,
                        TextColor3 = InventoryViewer.Theme.Text,
                        Text = text,
                        Font = Enum.Font.GothamBold,
                        TextSize = 12,
                        TextXAlignment = Enum.TextXAlignment.Center
                    })
                    CreateInstance("UICorner", {
                        CornerRadius = UDim.new(0, 4),
                        Parent = label
                    })
                    return label
                end
                CreateInventoryHeaderLabel(realHotbar, "RealHotbarLabel", "hotbar", 0.25)
                local inventoryViewerHotbar = CreateInstance("Frame", {
                    Name = "InventoryViewerHotbar",
                    Parent = mainContainer,
                    Size = UDim2.new(0, 360, 0, 45),
                    Position = UDim2.new(0.5, -180, 1, -135),
                    BackgroundColor3 = InventoryViewer.Theme.Background,
                    BackgroundTransparency = 0.25,
                    BorderSizePixel = 0
                })
                CreateInstance("UICorner", {
                    CornerRadius = UDim.new(0, 20),
                    Parent = inventoryViewerHotbar
                })
                CreateInstance("UIStroke", {
                    Color = InventoryViewer.Theme.Border,
                    Thickness = 1,
                    Transparency = 0.25,
                    Parent = inventoryViewerHotbar
                })
                CreateInventoryHeaderLabel(inventoryViewerHotbar, "InventoryViewerHotbarLabel", "equip", 0.253)
                local inventoryViewArmor = CreateInstance("Frame", {
                    Name = "InventoryViewArmor",
                    Parent = mainContainer,
                    Size = UDim2.new(0, 320, 0, 45),
                    Position = UDim2.new(0.5, -160, 1, -205),
                    BackgroundColor3 = InventoryViewer.Theme.Background,
                    BackgroundTransparency = 0.25,
                    BorderSizePixel = 0
                })
                CreateInstance("UICorner", {
                    CornerRadius = UDim.new(0, 20),
                    Parent = inventoryViewArmor
                })
                CreateInstance("UIStroke", {
                    Color = InventoryViewer.Theme.Border,
                    Thickness = 1,
                    Transparency = 0.3,
                    Parent = inventoryViewArmor
                })
                CreateInventoryHeaderLabel(inventoryViewArmor, "InventoryViewArmorLabel", "armor", 0.3)
                InventoryViewer.MainContainer = mainContainer
                local listFrame = CreateInstance("Frame", {
                    Name = "InventoryList",
                    Parent = screenGui,
                    Size = UDim2.new(0, 280, 0, 40),
                    Position = UDim2.new(0, 20, 0, 80),
                    BackgroundColor3 = InventoryViewer.Theme.Background,
                    BackgroundTransparency = 0.25,
                    BorderSizePixel = 0,
                    AutomaticSize = Enum.AutomaticSize.Y,
                    ZIndex = 100
                })
                CreateInstance("UICorner", {
                    CornerRadius = UDim.new(0, 20),
                    Parent = listFrame
                })
                CreateInstance("UIStroke", {
                    Color = InventoryViewer.Theme.Border,
                    Thickness = 2,
                    Transparency = 0.35,
                    Parent = listFrame
                })
                CreateInstance("UIListLayout", {
                    FillDirection = Enum.FillDirection.Vertical,
                    SortOrder = Enum.SortOrder.LayoutOrder,
                    Padding = UDim.new(0, 2),
                    Parent = listFrame
                })
                InventoryViewer.ListFrame = listFrame
                realHotbar.Visible = false
                inventoryViewerHotbar.Visible = false
                inventoryViewArmor.Visible = false
                local scrollingFrame = CreateInstance("ScrollingFrame", {
                    Parent = realHotbar,
                    Size = UDim2.new(1, -10, 1, -5),
                    Position = UDim2.new(0, 5, 0, 0),
                    CanvasSize = UDim2.new(0, 0, 0, 0),
                    ScrollBarThickness = 0,
                    BackgroundTransparency = 1
                })
                InventoryViewer.ScrollingFrame = scrollingFrame
                CreateInstance("UIListLayout", {
                    SortOrder = Enum.SortOrder.Name,
                    Padding = UDim.new(0, 10),
                    FillDirection = Enum.FillDirection.Horizontal,
                    HorizontalAlignment = Enum.HorizontalAlignment.Center,
                    VerticalAlignment = Enum.VerticalAlignment.Center,
                    Parent = scrollingFrame
                })
                CreateInstance("UIPadding", {
                    PaddingTop = UDim.new(0, -3),
                    Parent = scrollingFrame
                })
                local hotbarScrollingFrame = CreateInstance("ScrollingFrame", {
                    Parent = inventoryViewerHotbar,
                    Size = UDim2.new(1, -10, 1, -5),
                    Position = UDim2.new(0, 5, 0, 0),
                    CanvasSize = UDim2.new(0, 0, 0, 0),
                    ScrollBarThickness = 0,
                    BackgroundTransparency = 1
                })
                InventoryViewer.HotbarScrollingFrame = hotbarScrollingFrame
                CreateInstance("UIListLayout", {
                    SortOrder = Enum.SortOrder.Name,
                    Padding = UDim.new(0, 10),
                    FillDirection = Enum.FillDirection.Horizontal,
                    HorizontalAlignment = Enum.HorizontalAlignment.Center,
                    VerticalAlignment = Enum.VerticalAlignment.Center,
                    Parent = hotbarScrollingFrame
                })
                CreateInstance("UIPadding", {
                    PaddingTop = UDim.new(0, -3),
                    Parent = hotbarScrollingFrame
                })
                local armorScrollingFrame = CreateInstance("ScrollingFrame", {
                    Parent = inventoryViewArmor,
                    Size = UDim2.new(1, -10, 1, -5),
                    Position = UDim2.new(0, 5, 0, 0),
                    CanvasSize = UDim2.new(0, 0, 0, 0),
                    ScrollBarThickness = 0,
                    BackgroundTransparency = 1
                })
                InventoryViewer.ArmorScrollingFrame = armorScrollingFrame
                CreateInstance("UIListLayout", {
                    SortOrder = Enum.SortOrder.Name,
                    Padding = UDim.new(0, 10),
                    FillDirection = Enum.FillDirection.Horizontal,
                    HorizontalAlignment = Enum.HorizontalAlignment.Center,
                    VerticalAlignment = Enum.VerticalAlignment.Center,
                    Parent = armorScrollingFrame
                })
                CreateInstance("UIPadding", {
                    PaddingTop = UDim.new(0, -3),
                    Parent = armorScrollingFrame
                })
            end
            InventoryViewer.ScreenGui.Enabled = true
            InventoryViewer.GUIEnabled = true
            if not InventoryViewer.UpdateConnection then
                InventoryViewer.UpdateConnection = task.spawn(function()
                     while InventoryViewer.Enabled and InventoryViewer.GUIEnabled do
                        if InventoryViewer.updateGUI then
                             pcall(InventoryViewer.updateGUI)
                        end
                        task.wait(0.5)
                     end
                     InventoryViewer.UpdateConnection = nil
                end)
            end
            setupInventoryViewerRespawnHandler()
        else
            if InventoryViewer.ScreenGui then
                InventoryViewer.ScreenGui.Enabled = false
            end
            InventoryViewer.GUIEnabled = false
            if InventoryViewer.UpdateConnection then
                pcall(function()
                    if type(InventoryViewer.UpdateConnection) == "thread" then
                        task.cancel(InventoryViewer.UpdateConnection)
                    else
                        InventoryViewer.UpdateConnection:Disconnect()
                    end
                end)
                InventoryViewer.UpdateConnection = nil
            end
            if InventoryViewer.RespawnConnection then
                InventoryViewer.RespawnConnection:Disconnect()
                InventoryViewer.RespawnConnection = nil
            end
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "EnableInventoryViewer")
InventoryViewer.isPlayerInFOV = function(player)
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(hrp.Position)
    if not onScreen then return false end
    local center = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
    local distance = (center - Vector2.new(screenPos.X, ApplyResolutionStretchY(screenPos.Y, workspace.CurrentCamera))).Magnitude
    local radius = aimfov or 150
    return distance <= radius
end
InventoryViewer.scanForItems = function(player)
    local result = {
        clothing = {},
        equipment = {},
        inventory = {}
    }
    local root = game:GetService("ReplicatedStorage"):FindFirstChild("Players")
    if not root then return result end
    local playerFolder = root:FindFirstChild(player.Name)
    if not playerFolder then
        local userId = tostring(player.UserId)
        playerFolder = root:FindFirstChild(userId)
    end
    if not playerFolder then return result end
    local invRoot = playerFolder:FindFirstChild("Inventory")
    if not invRoot then return result end
    local function getItemType(item)
        local itemType = item:GetAttribute("ItemType") or item:GetAttribute("Type")
        if itemType == "Clothing" or itemType == "Armor" then
            return "clothing"
        elseif itemType == "Weapon" or itemType == "Tool" or itemType == "Equipment" then
            return "equipment"
        end
        local itemProps = item:FindFirstChild("ItemProperties")
        if itemProps then
            local typeVal = itemProps:FindFirstChild("ItemType") or itemProps:FindFirstChild("Type")
            if typeVal and typeVal:IsA("StringValue") then
                local typeStr = typeVal.Value:lower()
                if typeStr:find("cloth") or typeStr:find("armor") then
                    return "clothing"
                elseif typeStr:find("weapon") or typeStr:find("tool") or typeStr:find("equip") then
                    return "equipment"
                end
            end
        end
        local itemName = item.Name:lower()
        if itemName:find("shirt") or itemName:find("pants") or itemName:find("gloves") or itemName:find("helmet") or itemName:find("vest") or itemName:find("armor") or itemName:find("balaclava") or itemName:find("knee") then
            return "clothing"
        elseif itemName:find("gun") or itemName:find("weapon") or itemName:find("knife") or itemName:find("tool") then
            return "equipment"
        end
        return "inventory"
    end
    local function collectItems(folder)
        for _, child in ipairs(folder:GetChildren()) do
            if child:IsA("Folder") and (child.Name == "Inventory" or child.Name == "Attachments") then
                collectItems(child)
            else
                local isItem = true
                if isItem then
                    local itemType = getItemType(child)
                    if itemType == "clothing" then
                        table.insert(result.clothing, child)
                    elseif itemType == "equipment" then
                        table.insert(result.equipment, child)
                    else
                        table.insert(result.inventory, child)
                    end
                    local subInv = child:FindFirstChild("Inventory")
                    if subInv and subInv:IsA("Folder") then
                        collectItems(subInv)
                    end
                    local subAtt = child:FindFirstChild("Attachments")
                    if subAtt and subAtt:IsA("Folder") then
                        collectItems(subAtt)
                    end
                end
            end
        end
    end
    collectItems(invRoot)
    return result
end
InventoryViewer.PriceCache = {}
InventoryViewer.ItemsListFolder = nil
InventoryViewer.getItemPrice = function(item)
    if not item then return 0 end
    local attrPrice = item:GetAttribute("Price") or item:GetAttribute("price")
    if attrPrice then return tonumber(attrPrice) or 0 end
    local itemName = item.Name
    if InventoryViewer.PriceCache[itemName] then
        return InventoryViewer.PriceCache[itemName]
    end
    local props = item:FindFirstChild("ItemProperties")
    if props then
        local propPrice = props:GetAttribute("Price") or props:GetAttribute("price")
        if propPrice then
            local p = tonumber(propPrice) or 0
            InventoryViewer.PriceCache[itemName] = p
            return p
        end
        local valPrice = props:FindFirstChild("Price") or props:FindFirstChild("price")
        if valPrice and (valPrice:IsA("NumberValue") or valPrice:IsA("IntValue")) then
             local p = valPrice.Value
             InventoryViewer.PriceCache[itemName] = p
             return p
        end
    end
    if not InventoryViewer.ItemsListFolder then
        InventoryViewer.ItemsListFolder = game:GetService("ReplicatedStorage"):FindFirstChild("ItemsList")
    end
    local itemsList = InventoryViewer.ItemsListFolder
    if itemsList then
        local itemFolder = itemsList:FindFirstChild(itemName)
        if itemFolder then
             local itemProps = itemFolder:FindFirstChild("ItemProperties")
             if itemProps then
                 local listPrice = itemProps:GetAttribute("Price") or itemProps:GetAttribute("price")
                 if listPrice then
                    local p = tonumber(listPrice) or 0
                    InventoryViewer.PriceCache[itemName] = p
                    return p
                 end
                 local listValPrice = itemProps:FindFirstChild("Price") or itemProps:FindFirstChild("price")
                 if listValPrice and (listValPrice:IsA("NumberValue") or listValPrice:IsA("IntValue")) then
                      local p = listValPrice.Value
                      InventoryViewer.PriceCache[itemName] = p
                      return p
                 end
             end
        end
    end
    InventoryViewer.PriceCache[itemName] = 0
    return 0
end
InventoryViewer.getPlayerTotalInventoryValue = function(player)
    local total = 0
    local root = game:GetService("ReplicatedStorage"):FindFirstChild("Players")
    if not root then return 0 end
    local playerFolder = root:FindFirstChild(player.Name)
    if not playerFolder then
        local userId = tostring(player.UserId)
        playerFolder = root:FindFirstChild(userId)
    end
    if not playerFolder then return 0 end
    local function sumFolder(folder)
        local children = folder:GetChildren()
        for i = 1, #children do
            local child = children[i]
            if child:IsA("Folder") and (child.Name == "Inventory" or child.Name == "Attachments") then
                sumFolder(child)
            else
                 local p = InventoryViewer.getItemPrice(child)
                 total = total + p
                 local subInv = child:FindFirstChild("Inventory")
                 if subInv then sumFolder(subInv) end
                 local subAtt = child:FindFirstChild("Attachments")
                 if subAtt then sumFolder(subAtt) end
            end
        end
    end
    local invRoot = playerFolder:FindFirstChild("Inventory")
    if invRoot then sumFolder(invRoot) end
    return total
end
InventoryViewer.getItemIcon = function(item)
    local iconAttr = nil
    pcall(function()
        iconAttr = item:GetAttribute("Icon") or item:GetAttribute("ItemIcon")
    end)
    if type(iconAttr) == "string" and #iconAttr > 0 then
        return iconAttr
    end
    local props = item:FindFirstChild("ItemProperties")
    if props then
        local iconVal = props:FindFirstChild("ItemIcon")
        if iconVal then
            if iconVal:IsA("StringValue") then return iconVal.Value
            elseif iconVal:IsA("ImageLabel") then return iconVal.Image
            elseif iconVal:IsA("Decal") or iconVal:IsA("Texture") then return iconVal.Texture end
        end
    end
    local itemName = item.Name
    local itemsList = game:GetService("ReplicatedStorage"):FindFirstChild("ItemsList")
    if itemsList then
        local itemFolder = itemsList:FindFirstChild(itemName)
        if itemFolder then
            local itemProps = itemFolder:FindFirstChild("ItemProperties")
            if itemProps then
                local itemIcon = itemProps:FindFirstChild("ItemIcon")
                if itemIcon then
                    if itemIcon:IsA("StringValue") then return itemIcon.Value
                    elseif itemIcon:IsA("ImageLabel") then return itemIcon.Image
                    elseif itemIcon:IsA("Decal") or itemIcon:IsA("Texture") then return itemIcon.Texture end
                end
            end
        end
    end
    return "rbxassetid://0"
end
InventoryViewer.clearGUI = function()
    if InventoryViewer.ScrollingFrame then
        for _, child in ipairs(InventoryViewer.ScrollingFrame:GetChildren()) do
            if not child:IsA("UIListLayout") then
                child:Destroy()
            end
        end
    end
    if InventoryViewer.HotbarScrollingFrame then
        for _, child in ipairs(InventoryViewer.HotbarScrollingFrame:GetChildren()) do
            if not child:IsA("UIListLayout") then
                child:Destroy()
            end
        end
    end
    if InventoryViewer.ArmorScrollingFrame then
        for _, child in ipairs(InventoryViewer.ArmorScrollingFrame:GetChildren()) do
            if not child:IsA("UIListLayout") then
                child:Destroy()
            end
        end
    end
    if InventoryViewer.ListFrame then
        for _, child in ipairs(InventoryViewer.ListFrame:GetChildren()) do
            if not child:IsA("UIListLayout") then
                child:Destroy()
            end
        end
    end
end
InventoryViewer.createItemIcon = function(itemName, image, parent)
    if not parent then return end
    local size = InventoryViewer.CompactMode and 40 or 50
    local frame = CreateInstance("Frame", {
        Parent = parent,
        Size = UDim2.new(0, size, 0, size),
        BackgroundColor3 = InventoryViewer.Theme.SlotBg,
        BackgroundTransparency = 0.2,
        BorderSizePixel = 0
    })
    CreateInstance("UICorner", {
        CornerRadius = UDim.new(0, InventoryViewer.CompactMode and 4 or 6),
        Parent = frame
    })
    local stroke = CreateInstance("UIStroke", {
        Color = InventoryViewer.Theme.Border,
        Thickness = 1,
        Transparency = 0.25,
        Parent = frame
    })
    CreateInstance("ImageLabel", {
        Name = "InnerShadow",
        Parent = frame,
        BackgroundTransparency = 1,
        Position = UDim2.new(0, 0, 0, 0),
        Size = UDim2.new(1, 0, 1, 0),
        ZIndex = 2,
        Image = "rbxassetid://5554236805",
        ImageColor3 = Color3.fromRGB(0, 0, 0),
        ImageTransparency = 0.9,
        ScaleType = Enum.ScaleType.Slice,
        SliceCenter = Rect.new(23, 23, 277, 277)
    })
    local icon = CreateInstance("ImageLabel", {
        Parent = frame,
        Size = UDim2.new(0.8, 0, 0.8, 0),
        Position = UDim2.new(0.1, 0, 0.1, 0),
        BackgroundTransparency = 1,
        ZIndex = 3
    })
    if image then
        icon.Image = image
    else
        icon.BackgroundColor3 = Color3.fromRGB(150, 150, 150)
        icon.BackgroundTransparency = 0.7
    end
    local tooltip = CreateInstance("Frame", {
        Parent = frame,
        Size = UDim2.new(0, 120, 0, 25),
        Position = UDim2.new(0.5, -60, 0, -30),
        BackgroundColor3 = InventoryViewer.Theme.Background,
        BackgroundTransparency = 0.3,
        Visible = false,
        ZIndex = 10
    })
    CreateInstance("UICorner", {
        CornerRadius = UDim.new(0, 4),
        Parent = tooltip
    })
    CreateInstance("UIStroke", {
        Color = InventoryViewer.Theme.Border,
        Thickness = 1,
        Transparency = 0.3,
        Parent = tooltip
    })
    CreateInstance("TextLabel", {
        Parent = tooltip,
        Text = itemName,
        Size = UDim2.new(1, -10, 1, 0),
        Position = UDim2.new(0, 5, 0, 0),
        BackgroundTransparency = 1,
        TextColor3 = InventoryViewer.Theme.Text,
        TextSize = 11,
        Font = Enum.Font.GothamBold,
        TextWrapped = true,
        ZIndex = 11
    })
    frame.MouseEnter:Connect(function()
        game:GetService("TweenService"):Create(frame, TweenInfo.new(0.2), {BackgroundColor3 = InventoryViewer.Theme.ItemHover}).Play()
        game:GetService("TweenService"):Create(stroke, TweenInfo.new(0.2), {Thickness = 2}).Play()
        tooltip.Visible = true
    end)
    frame.MouseLeave:Connect(function()
        game:GetService("TweenService"):Create(frame, TweenInfo.new(0.2), {BackgroundColor3 = InventoryViewer.Theme.SlotBg}).Play()
        game:GetService("TweenService"):Create(stroke, TweenInfo.new(0.2), {Thickness = 1.5}).Play()
        tooltip.Visible = false
    end)
    return frame
end
InventoryViewer.updateGUI = function()
    InventoryViewer.clearGUI()
    local closestPlayer = nil
    if aimbool and aimtarget then
        closestPlayer = aimtarget
    else
        local closestDistance = math.huge
        local camera = workspace.CurrentCamera
        if not camera then return end
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= Players.LocalPlayer and player.Character then
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local screenPos, onScreen = camera:WorldToScreenPoint(hrp.Position)
                    if onScreen then
                        local center = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
                        local distance = (center - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
                        local maxDistance = aimfov or 150
                        if distance <= maxDistance and distance < closestDistance then
                            closestDistance = distance
                            closestPlayer = player
                        end
                    end
                end
            end
        end
    end
    if closestPlayer then
        if InventoryViewer.ListFrame then
            local rplayers = game:GetService("ReplicatedStorage"):FindFirstChild("Players")
            local playerFolder = rplayers and rplayers:FindFirstChild(closestPlayer.Name)
            if not playerFolder then
                local userId = tostring(closestPlayer.UserId)
                playerFolder = rplayers and rplayers:FindFirstChild(userId)
            end
            local invRoot = playerFolder and playerFolder:FindFirstChild("Inventory")
            local totalValue = InventoryViewer.getPlayerTotalInventoryValue(closestPlayer)
            local order = 1
            local function CreateInventoryRowText(parent, text, textColor, font, textSize, zIndex, layoutOrder, textStrokeTransparency)
                local props = {
                    Parent = parent,
                    AutomaticSize = Enum.AutomaticSize.X,
                    Size = UDim2.new(0, 0, 1, 0),
                    BackgroundTransparency = 1,
                    TextColor3 = textColor,
                    Font = font,
                    TextSize = textSize,
                    TextTransparency = 0,
                    ZIndex = zIndex,
                    TextXAlignment = Enum.TextXAlignment.Left,
                    Text = text,
                    LayoutOrder = layoutOrder
                }
                if textStrokeTransparency ~= nil then
                    props.TextStrokeTransparency = textStrokeTransparency
                end
                return CreateInstance("TextLabel", props)
            end
            local function addRow(text, iconId, count, price)
                local row = CreateInstance("Frame", {
                    Parent = InventoryViewer.ListFrame,
                    Size = UDim2.new(1, 0, 0, 28),
                    BackgroundTransparency = 1,
                    BorderSizePixel = 0,
                    LayoutOrder = order,
                    ZIndex = 101
                })
                order = order + 1
                CreateInstance("UIListLayout", {
                    FillDirection = Enum.FillDirection.Horizontal,
                    SortOrder = Enum.SortOrder.LayoutOrder,
                    Padding = UDim.new(0, 6),
                    VerticalAlignment = Enum.VerticalAlignment.Center,
                    Parent = row
                })
                CreateInstance("UIPadding", {
                    PaddingLeft = UDim.new(0, 10),
                    Parent = row
                })
                CreateInventoryRowText(row, text, Color3.fromRGB(255, 255, 255), Enum.Font.GothamBold, 14, 102, 1, 1)
                if iconId and iconId ~= "" then
                    CreateInstance("ImageLabel", {
                        Parent = row,
                        Size = UDim2.new(0, 26, 0, 26),
                        BackgroundTransparency = 1,
                        ImageTransparency = 0,
                        ImageColor3 = Color3.fromRGB(255, 255, 255),
                        Image = iconId,
                        LayoutOrder = 2,
                        ZIndex = 103
                    })
                    if price and price > 0 then
                        CreateInventoryRowText(row, "[" .. tostring(price) .. " " .. INV_CURRENCY .. "]", Color3.fromRGB(100, 255, 100), Enum.Font.GothamSemibold, 13, 104, 3)
                    end
                    if count and count > 1 then
                        CreateInventoryRowText(row, "(x" .. tostring(count) .. ")", Color3.fromRGB(255, 255, 255), Enum.Font.GothamSemibold, 13, 104, 4)
                    end
                end
                return row
            end
            addRow(closestPlayer.Name .. " inventory: (Total: " .. tostring(totalValue) .. " " .. INV_CURRENCY .. ")")
            if invRoot then
                local function renderFolder(folder, indent)
                    local children = folder:GetChildren()
                    table.sort(children, function(a,b) return a.Name < b.Name end)
                    local groups = {}
                    for _, child in ipairs(children) do
                        local key = child.Name
                        local subInv = child:FindFirstChild("Inventory")
                        local subAtt = child:FindFirstChild("Attachments")
                        local hasChildren = (subInv and #subInv:GetChildren() > 0) or (subAtt and #subAtt:GetChildren() > 0)
                        local bucket = groups[key]
                        if not bucket then bucket = {items = {}, count = 0, representative = child, hasChildren = hasChildren} groups[key] = bucket end
                        bucket.count = bucket.count + 1
                        table.insert(bucket.items, child)
                        if hasChildren then bucket.hasChildren = true end
                    end
                    local entries = {}
                    for _, bucket in pairs(groups) do
                        table.insert(entries, bucket)
                    end
                    table.sort(entries, function(a,b) return a.representative.Name < b.representative.Name end)
                    local isRoot = (indent or "") == ""
                    for i, entry in ipairs(entries) do
                        local child = entry.representative
                        local subInv = child:FindFirstChild("Inventory")
                        local subAtt = child:FindFirstChild("Attachments")
                        local hasChildren = entry.hasChildren
                        local connector
                        if isRoot then
                            connector = (i == 1 and " ") or (i == #entries and " ") or " "
                        else
                            connector = (i == #entries) and " " or " "
                        end
                        local branch = hasChildren and " " or ""
                        local count = (not hasChildren and entry.count > 1) and entry.count or nil
                        local price = InventoryViewer.getItemPrice(child)
                        addRow((indent or "") .. connector .. branch .. child.Name, InventoryViewer.getItemIcon(child), count, price)
                        if hasChildren then
                            local nextIndent = (indent or "") .. "    "
                            if subInv then renderFolder(subInv, nextIndent) end
                            if subAtt then renderFolder(subAtt, nextIndent) end
                        end
                    end
                end
                renderFolder(invRoot, "")
            end
        end
    end
end
local bulletTracerSection = sections.PlayerBulletTracer
bulletTracerSection:Header({
    Text = "Bullet Tracers"
})
bulletTracerSection:Toggle({
    Name = "Enable Bullet Tracers",
    Default = false,
    Callback = function(value)
        _G.ScriptData = _G.ScriptData or {
        activeBulletTracers = {},
            bulletTracerEnabled = false,
        bulletTracerLifetime = 1,
        bulletTracerWidth = 0.2,
        bulletTracerFadeoutPoint = 0.7,
        bulletTracerColor = Color3.fromRGB(255, 255, 255),
        bulletTracerSpeed = 5,
        bulletTracerTexture = "http://www.roblox.com/asset/?id=446111271",
        bulletTracerMaxDistance = 1300
    }
        _G.ScriptData.bulletTracerEnabled = value
        if not value then
            if _G.ScriptData.activeBulletTracers then
                for _, tracer in pairs(_G.ScriptData.activeBulletTracers) do
                    if tracer and tracer.part then
                        pcall(function() tracer.part:Destroy() end)
                    end
                end
                _G.ScriptData.activeBulletTracers = {}
            end
        end
        ensureBulletHook()
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "EnableBulletTracers")
ESP._ui.playerTracerLifetimeSliderEl = bulletTracerSection:Slider({
    Name = "Tracer Lifetime",
    Default = 1,
    Minimum = 0,
    Maximum = 5,
    Precision = 1,
    Callback = function(value)
        if not _G.ScriptData then return end
        _G.ScriptData.bulletTracerLifetime = value
    end
}, "TracerLifetime")
ESP._ui.playerTracerColorPickerEl = bulletTracerSection:Colorpicker({
    Name = "Tracer Color",
    Default = _G.ScriptData and _G.ScriptData.bulletTracerColor or Color3.fromRGB(255, 255, 255),
    Alpha = 0,
    Callback = function(color)
        if not _G.ScriptData then return end
        _G.ScriptData.bulletTracerColor = color
    end
}, "TracerColor")
if ESP and ESP._ui and ESP._ui._syncESPVisibility then
    ESP._ui._syncESPVisibility()
end
local function hasWeaponEquipped()
    local camera = workspace.CurrentCamera
    if not camera then return false end
    local viewModel = camera:FindFirstChild("ViewModel")
    if not viewModel then return false end
    local item = viewModel:FindFirstChild("Item")
    if not item then return false end
    local hasGunPart = false
    for _, part in ipairs(item:GetDescendants()) do
        if part:IsA("BasePart") and (part.Name == "AimPart" or part.Name == "Gunmuzzle" or part.Name:match("Barrel")) then
            hasGunPart = true
            break
        end
    end
    return hasGunPart
end
local function createBulletTracer()
    if not _G.ScriptData or not _G.ScriptData.bulletTracerEnabled then return end
    if not hasWeaponEquipped() then return end
    local camera = workspace.CurrentCamera
    if not camera then return end
    local startPos = camera.CFrame.Position
    local viewModel = camera:FindFirstChild("ViewModel")
    local muzzle = nil
    local aimPart = nil
    if viewModel then
        local weapon = viewModel:FindFirstChild("Item")
        if weapon then
            for _, part in pairs(weapon:GetDescendants()) do
                if part:IsA("BasePart") then
                    if part.Name == "Gunmuzzle" then
                        muzzle = part
                    elseif part.Name == "AimPart" then
                        aimPart = part
                    end
                end
            end
        end
    end
    if muzzle then
        startPos = muzzle.Position
    elseif aimPart then
        startPos = aimPart.Position
    end
    local direction = camera.CFrame.LookVector
    local endPos = nil
    if aimbool and aimtarget and aimtargetpart and isvisible(aimtarget:IsA("Model") and aimtarget or aimtarget.Character, aimtargetpart) then
        local targetPos = aimtargetpart.Position
        if aimtype == "Prediction" then
            local ammoStats = getAmmoStats()
            local bulletSpeed = ammoStats.MuzzleVelocity
            targetPos = predictpos(aimtargetpart, bulletSpeed)
        end
        direction = (targetPos - startPos).Unit
        endPos = targetPos
    else
        endPos = startPos + direction * (_G.ScriptData.bulletTracerMaxDistance or 1300)
        local ray = Ray.new(startPos, direction * (_G.ScriptData.bulletTracerMaxDistance or 1300))
        local ignoreList = {Players.LocalPlayer.Character, camera, viewModel}
        local hit, hitPos = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
        if hit then
            endPos = hitPos
        end
    end
    local beamPart = Instance.new("Part")
    beamPart.Name = "BulletTracer"
    beamPart.Size = Vector3.new(_G.ScriptData.bulletTracerWidth or 0.2, 0.1, 0.1)
    beamPart.Transparency = 1
    beamPart.CanCollide = false
    beamPart.Anchored = true
    beamPart.CFrame = CFrame.new(startPos)
    beamPart.Parent = workspace
    local startAttachment = Instance.new("Attachment", beamPart)
    startAttachment.WorldPosition = startPos
    local endAttachment = Instance.new("Attachment", beamPart)
    endAttachment.WorldPosition = endPos
    local beam = Instance.new("Beam")
    beam.Attachment0 = startAttachment
    beam.Attachment1 = endAttachment
    beam.Texture = _G.ScriptData.bulletTracerTexture or "http://www.roblox.com/asset/?id=446111271"
    beam.TextureMode = Enum.TextureMode.Wrap
    beam.TextureLength = 1
    beam.TextureSpeed = _G.ScriptData.bulletTracerSpeed or 5
    beam.FaceCamera = true
    beam.Color = ColorSequence.new(_G.ScriptData.bulletTracerColor or Color3.fromRGB(255, 255, 255))
    beam.Width0 = _G.ScriptData.bulletTracerWidth or 0.2
    beam.Width1 = _G.ScriptData.bulletTracerWidth or 0.2
    beam.LightEmission = 1
    beam.Parent = beamPart
    local tracerLifetime = _G.ScriptData.bulletTracerLifetime or 1
    local startTime = tick()
    local beamRef = setmetatable({value = beam}, {__mode = "v"})
    local beamPartRef = setmetatable({value = beamPart}, {__mode = "v"})
    local maxTracers = 10
    if not _G.ScriptData.activeBulletTracers then
        _G.ScriptData.activeBulletTracers = {}
    end
    while #_G.ScriptData.activeBulletTracers >= maxTracers do
        local oldestTracer = table.remove(_G.ScriptData.activeBulletTracers, 1)
        if oldestTracer and oldestTracer.part then
            pcall(function()
                if oldestTracer.part:IsDescendantOf(workspace) then
                    oldestTracer.part:Destroy()
                end
            end)
        end
    end
    table.insert(_G.ScriptData.activeBulletTracers, {
        part = beamPart,
        beam = beam,
        startTime = startTime
    })
    local bulletAnimation = RunService.RenderStepped:Connect(function()
        local currentTime = tick() - startTime
        local beam = beamRef and beamRef.value
        local beamPart = beamPartRef and beamPartRef.value
        if currentTime >= tracerLifetime or not beam or not beamPart or not beam.Parent or not beamPart:IsDescendantOf(workspace) then
            if bulletAnimation then
                pcall(function() bulletAnimation:Disconnect() end)
                bulletAnimation = nil
            end
            if beamPart and beamPart:IsDescendantOf(workspace) then
                if beam then
                    pcall(function() beam.Enabled = false end)
                end
                pcall(function() beamPart:Destroy() end)
            end
            return
        end
        local fadeStartTime = tracerLifetime * (_G.ScriptData.bulletTracerFadeoutPoint or 0.7)
        if currentTime > fadeStartTime then
            local fadeProgress = (currentTime - fadeStartTime) / (tracerLifetime - fadeStartTime)
            local transparencySequence = NumberSequence.new({
                NumberSequenceKeypoint.new(0, fadeProgress),
                NumberSequenceKeypoint.new(1, 1)
            })
            beam.Transparency = transparencySequence
            if fadeProgress > 0.9 then
                local widthScale = 1 - ((fadeProgress - 0.9) * 10)
                beam.Width0 = (_G.ScriptData.bulletTracerWidth or 0.2) * widthScale
                beam.Width1 = (_G.ScriptData.bulletTracerWidth or 0.2) * widthScale
            end
        end
    end)
end
local function clearAllBulletTracers()
    if not _G.ScriptData.activeBulletTracers then
        _G.ScriptData.activeBulletTracers = {}
        return
    end
    for _, tracer in pairs(_G.ScriptData.activeBulletTracers) do
        if tracer and tracer.part then
            pcall(function()
                if tracer.part:IsDescendantOf(workspace) then
                    tracer.part:Destroy()
                end
            end)
        end
    end
    _G.ScriptData.activeBulletTracers = {}
end
_G.allvars._rt.track(UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
end))
_G.allvars._rt.track(UserInputService.InputBegan:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton1 then
        SilentAim.IsAiming = true
    end
end))
_G.allvars._rt.track(UserInputService.InputEnded:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton1 then
        SilentAim.IsAiming = false
        if SilentAim.LockedPlayerGUI then
            SilentAim.LockedPlayerGUI.Enabled = false
        end
    end
end))
_G.allvars._rt.track(RunService.RenderStepped:Connect(function()
    if SilentAim.FOVCircle then
        SilentAim.FOVCircle.Position = getCenter()
        SilentAim.FOVCircle.Radius = SilentAim.CircleRadius
        SilentAim.FOVCircle.Filled = SilentAim.CircleFilled
        SilentAim.FOVCircle.Color = SilentAim.CircleColor
        SilentAim.FOVCircle.Visible = SilentAim.CircleVisible and SilentAim.Enabled
        SilentAim.FOVCircle.Transparency = SilentAim.CircleTransparency
        SilentAim.FOVCircle.NumSides = SilentAim.CircleSides
        SilentAim.FOVCircle.Thickness = SilentAim.CircleThickness
        if InventoryViewer and InventoryViewer.Enabled then
            if InventoryViewer.GUIEnabled then
                InventoryViewer.updateGUI()
            end
        end
    end
    if SilentAim.Enabled and SilentAim.IsAiming then
        local closestPlayer = GetClosestPlayer()
        if closestPlayer then
            if SilentAim.TrackerEnabled then
                if not SilentAim.Tracker2D then
                    SilentAim.Tracker2D = Drawing.new("Line")
                    SilentAim.Tracker2D.Color = SilentAim.CircleColor
                    SilentAim.Tracker2D.Thickness = 1
                    SilentAim.Tracker2D.Transparency = 1
                    SilentAim.Tracker2D.Visible = true
                end
                local targetPart = closestPlayer.Character and closestPlayer.Character:FindFirstChild(SilentAim.AimPart)
                if targetPart then
                    local camera = Workspace.CurrentCamera
                    local screenPos = worldToScreenPoint2D(targetPart.Position, camera)
                    if screenPos then
                        SilentAim.Tracker2D.From = getCenter()
                        SilentAim.Tracker2D.To = screenPos
                        SilentAim.Tracker2D.Visible = true
                    else
                        SilentAim.Tracker2D.Visible = false
                    end
                end
            else
                if SilentAim.Tracker2D then
                    SilentAim.Tracker2D.Visible = false
        end
    end
                if SilentAim.ShowTargetName and SilentAim.UsernameLabel then
                    SilentAim.UsernameLabel.Text = "Target: " .. closestPlayer.Name
                    SilentAim.UsernameLabel.Visible = true
                    if SilentAim.LockedPlayerGUI then
                        SilentAim.LockedPlayerGUI.Enabled = true
                    end
                else
                     if SilentAim.UsernameLabel then
                         SilentAim.UsernameLabel.Visible = false
                     end
                end
            else
                if SilentAim.Tracker2D then
                    SilentAim.Tracker2D.Visible = false
                end
                if SilentAim.LockedPlayerGUI then
                    SilentAim.LockedPlayerGUI.Enabled = false
                end
                if SilentAim.UsernameLabel then
                     SilentAim.UsernameLabel.Visible = false
                end
            end
        else
            if SilentAim.Tracker2D then
                SilentAim.Tracker2D.Visible = false
            end
            if SilentAim.LockedPlayerGUI then
                SilentAim.LockedPlayerGUI.Enabled = false
            end
            if SilentAim.UsernameLabel then
                 SilentAim.UsernameLabel.Visible = false
            end
        end
end))
sections.WorldVisual:Header({
    Text = "Lighting Settings"
})
local CombatLogConnection = nil
local CombatLogLabel = nil
sections.PlayerOther:Header({
    Text = "Other"
})
sections.PlayerOther:Toggle({
    Name = "Skin Changer",
    Default = true,
    Callback = function(value)
        if _G.ToggleSkinChanger then
            _G.ToggleSkinChanger(value)
        else
            if _G.allvars then
                _G.allvars.skinChangerEnabled = value
            end
        end
    end
}, "SkinChangerToggle")
sections.PlayerOther:Toggle({
    Name = "Show Combat Timer",
    Default = false,
    Callback = function(value)
        if value then
            if not CombatLogLabel then
                CombatLogLabel = CreateInstance("TextLabel", {
                    Name = "CombatLogLabel",
                    Size = UDim2.new(0, 200, 0, 30),
                    Position = UDim2.new(0.5, 0, 0.9, 0),
                    AnchorPoint = Vector2.new(0.5, 1),
                    BackgroundTransparency = 1,
                    TextColor3 = Color3.fromRGB(255, 50, 50),
                    Font = 3,
                    TextSize = 24,
                    TextStrokeTransparency = 0,
                    TextStrokeColor3 = Color3.fromRGB(0, 0, 0),
                    Visible = false,
                    Parent = CoreGui:FindFirstChild("ESPHolder") or CoreGui
                })
            end
            if CombatLogConnection then CombatLogConnection:Disconnect() end
            CombatLogConnection = RunService.RenderStepped:Connect(function()
                if not localplayer then return end
                local repStorage = game:GetService("ReplicatedStorage")
                if not repStorage then return end
                local playersFolder = repStorage:FindFirstChild("Players")
                if not playersFolder then return end
                local myFolder = playersFolder:FindFirstChild(localplayer.Name)
                if not myFolder then return end
                local status = myFolder:FindFirstChild("Status")
                if not status then return end
                local gameplayVars = status:FindFirstChild("GameplayVariables")
                if not gameplayVars then return end
                local combat = gameplayVars:FindFirstChild("Combat")
                if combat then
                    local val = combat:GetAttribute("Value") or combat:GetAttribute("value")
                    if val and tonumber(val) and tonumber(val) > 0 then
                        CombatLogLabel.Text = string.format("Combat: %d", math.ceil(tonumber(val)))
                        CombatLogLabel.Visible = true
                        if not CombatLogLabel.Parent then
                             CombatLogLabel.Parent = CoreGui:FindFirstChild("ESPHolder") or CoreGui
                        end
                    else
                        CombatLogLabel.Visible = false
                    end
                else
                    CombatLogLabel.Visible = false
                end
            end)
        else
            if CombatLogConnection then
                CombatLogConnection:Disconnect()
                CombatLogConnection = nil
            end
            if CombatLogLabel then
                CombatLogLabel.Visible = false
                CombatLogLabel:Destroy()
                CombatLogLabel = nil
            end
        end
    end
}, "CombatLogToggle")
sections.WorldVisual:Toggle({
    Name = "Full Bright",
    Default = false,
    Callback = function(value)
        if value then
            _G.OriginalLightingSettings = {
                Brightness = Lighting.Brightness,
                Ambient = Lighting.Ambient,
                OutdoorAmbient = Lighting.OutdoorAmbient,
                GlobalShadows = Lighting.GlobalShadows
            }
            Lighting.Brightness = 2
            Lighting.GlobalShadows = false
            Lighting.Ambient = Color3.fromRGB(199, 199, 199)
            Lighting.OutdoorAmbient = Color3.fromRGB(199, 199, 199)
        else
            if _G.OriginalLightingSettings then
                Lighting.Brightness = _G.OriginalLightingSettings.Brightness
                Lighting.Ambient = _G.OriginalLightingSettings.Ambient
                Lighting.OutdoorAmbient = _G.OriginalLightingSettings.OutdoorAmbient
                Lighting.GlobalShadows = _G.OriginalLightingSettings.GlobalShadows
                _G.OriginalLightingSettings = nil
            end
        end
    end
}, "FullBright")
sections.WorldVisual:Toggle({
    Name = "X-Ray",
    Default = false,
    Callback = function(value)
        if value then
            _G.XRayOriginalProperties = {}
            for _, obj in pairs(Workspace:GetDescendants()) do
                if obj:IsA("BasePart") and not obj:IsA("Terrain") then
                    _G.XRayOriginalProperties[obj] = {
                        Transparency = obj.Transparency,
                        Material = obj.Material,
                        Color = obj.Color
                    }
                    obj.Transparency = 0.75
                    obj.Material = Enum.Material.SmoothPlastic
                end
            end
            _G.XRayConnection = Workspace.DescendantAdded:Connect(function(obj)
                if obj:IsA("BasePart") and not obj:IsA("Terrain") then
                    _G.XRayOriginalProperties[obj] = {
                        Transparency = obj.Transparency,
                        Material = obj.Material,
                        Color = obj.Color
                    }
                    obj.Transparency = 0.75
                    obj.Material = Enum.Material.SmoothPlastic
                end
            end)
        else
            if _G.XRayOriginalProperties then
                for obj, props in pairs(_G.XRayOriginalProperties) do
                    if obj and obj:IsA("BasePart") then
                        for prop, value in pairs(props) do
                            pcall(function() obj[prop] = value end)
                            end
                        end
                    end
                _G.XRayOriginalProperties = nil
            end
            if _G.XRayConnection then
                _G.XRayConnection:Disconnect()
                _G.XRayConnection = nil
            end
        end
    end
}, "XRay")
sections.WorldVisual:Header({
    Text = "Map Settings"
})
sections.WorldVisual:Toggle({
    Name = "Hide Leaves",
    Default = false,
    Callback = function(value)
        if value then
            local folcheck = workspace:FindFirstChild("SpawnerZones")
            if not folcheck then return end
            for _, v in pairs(folcheck.Foliage:GetDescendants()) do
                if v:FindFirstChildOfClass("SurfaceAppearance") then
                    if not _G.OriginalLeavesTransparency then
                        _G.OriginalLeavesTransparency = {}
                    end
                    if not _G.OriginalLeavesTransparency[v] then
                        _G.OriginalLeavesTransparency[v] = v.Transparency
                    end
                    v.Transparency = 1
                end
            end
            if _G.LeavesAddedConnection then
                _G.LeavesAddedConnection:Disconnect()
            end
            _G.LeavesAddedConnection = folcheck.Foliage.DescendantAdded:Connect(function(v)
                if v:FindFirstChildOfClass("SurfaceAppearance") then
                    if not _G.OriginalLeavesTransparency then
                        _G.OriginalLeavesTransparency = {}
                    end
                    if not _G.OriginalLeavesTransparency[v] then
                        _G.OriginalLeavesTransparency[v] = v.Transparency
                    end
                    v.Transparency = 1
                end
            end)
        else
            if _G.OriginalLeavesTransparency then
                for obj, transparency in pairs(_G.OriginalLeavesTransparency) do
                    pcall(function()
                        if obj then
                            obj.Transparency = transparency
                        end
                    end)
                end
                _G.OriginalLeavesTransparency = nil
            end
            if _G.LeavesAddedConnection then
                _G.LeavesAddedConnection:Disconnect()
                _G.LeavesAddedConnection = nil
            end
        end
    end
}, "HideLeaves")
sections.WorldVisual:Toggle({
    Name = "Hide Grass",
    Default = false,
    Callback = function(value)
        if Workspace and Workspace:FindFirstChild("Terrain") then
            sethiddenproperty(Workspace.Terrain, "Decoration", not value)
        end
    end
}, "DisableGrass")
task.spawn(function()
    while wait(10.5) do
        table.clear(aimignoreparts)
        for i,v in pairs(workspace:GetDescendants()) do
            if v:GetAttribute("PassThrough") then
                table.insert(aimignoreparts, v)
            elseif allvars.worldnomines and (v.Name == "PMN2" or v.Name == "MON50" or (v.Name == "BridgeClaymores" and v.Parent and v.Parent.Name == "AiZones")) and v:IsA("Model") then
                v:Destroy()
            end
        end
    end
end)
sections.WorldVisual:Toggle({
    Name = "No Mines",
    Default = false,
    Callback = function(value)
        allvars.worldnomines = value
    end
}, "NoMines")
sections.WorldVisual:Header({
    Text = "Fog Settings"
})
_G.FogSettings = {
    originalAtmosphereDensity = nil,
    originalFogEnd = nil,
    originalFogStart = nil,
    removeFogEnabled = false
}
sections.WorldVisual:Toggle({
    Name = "Remove Fog",
    Default = false,
    Callback = function(value)
        _G.FogSettings.removeFogEnabled = value
        if value then
            if Lighting:FindFirstChild("Atmosphere") and _G.FogSettings.originalAtmosphereDensity == nil then
                _G.FogSettings.originalAtmosphereDensity = Lighting.Atmosphere.Density
            end
            if _G.FogSettings.originalFogEnd == nil then
                _G.FogSettings.originalFogEnd = Lighting.FogEnd
            end
            if _G.FogSettings.originalFogStart == nil then
                _G.FogSettings.originalFogStart = Lighting.FogStart
            end
            if not _G.FogRemovalConnection then
                _G.FogRemovalConnection = RunService.Heartbeat:Connect(function()
                    if _G.FogSettings.removeFogEnabled then
                        if Lighting:FindFirstChild("Atmosphere") then
                            Lighting.Atmosphere.Density = 0
                        end
                        Lighting.FogEnd = 100000
                        Lighting.FogStart = 0
                    end
                end)
            end
        else
            if _G.FogRemovalConnection then
                _G.FogRemovalConnection:Disconnect()
                _G.FogRemovalConnection = nil
            end
            if Lighting:FindFirstChild("Atmosphere") and _G.FogSettings.originalAtmosphereDensity then
                Lighting.Atmosphere.Density = _G.FogSettings.originalAtmosphereDensity
            end
            if _G.FogSettings.originalFogEnd then
                Lighting.FogEnd = _G.FogSettings.originalFogEnd
            end
            if _G.FogSettings.originalFogStart then
                Lighting.FogStart = _G.FogSettings.originalFogStart
            end
        end
    end
}, "RemoveFog")
local function SafeCloudAccess()
    local terrain = workspace:FindFirstChildOfClass("Terrain")
    if not terrain then return nil end
    local clouds = nil
    local success = pcall(function()
        clouds = terrain.Clouds
    end)
    if not success or not clouds then return nil end
    return {
        getEnabled = function()
            local enabled = false
            pcall(function() enabled = clouds.Enabled end)
            return enabled
        end,
        setEnabled = function(value)
            pcall(function() clouds.Enabled = value end)
        end,
        getColor = function()
            local color = Color3.fromRGB(255, 255, 255)
            pcall(function() color = clouds.Color end)
            return color
        end,
        setColor = function(value)
            pcall(function() clouds.Color = value end)
        end,
        getCover = function()
            local cover = 0.5
            pcall(function() cover = clouds.Cover end)
            return cover
        end,
        setCover = function(value)
            pcall(function() clouds.Cover = value end)
        end,
        getDensity = function()
            local density = 0.5
            pcall(function() density = clouds.Density end)
            return density
        end,
        setDensity = function(value)
            pcall(function() clouds.Density = value end)
        end
    }
end
local cloudSection = tabs.World:Section({ Side = "Right", Name = "Cloud Settings" })
cloudSection:Header({
    Text = "Cloud Controls"
})
ESP._ui.worldCloudToggleEl = cloudSection:Toggle({
    Name = "Toggle Clouds",
    Flag = "WorldToggleClouds",
    Default = false,
    Callback = function(value)
        local function syncCloudUI()
            if ESP and ESP._ui and ESP._ui._syncESPVisibility then
                ESP._ui._syncESPVisibility()
            end
        end
        local prev = WorldCloudsEnabled and true or false
        WorldCloudsEnabled = value and true or false
        if prev == WorldCloudsEnabled and not _G.CloudSettings then
            syncCloudUI()
            return
        end
        if not value and not _G.CloudSettings then
            syncCloudUI()
            return
        end
        if not _G.CloudSettings then
            _G.CloudSettings = {
                Enabled = true,
                Color = Color3.fromRGB(255, 255, 255),
                Cover = 0.5,
                Density = 0.5,
                OriginalColor = nil,
                OriginalCover = nil,
                OriginalDensity = nil,
                OverrideActive = false
            }
        end
        _G.CloudSettings.Enabled = value
        syncCloudUI()
        local terrain = Workspace:FindFirstChildOfClass("Terrain")
        if not terrain then return end
        local cloudExists = false
        pcall(function() cloudExists = terrain.Clouds ~= nil end)
        if not cloudExists then
            return
        end
        if not _G.CloudSettings.OriginalCover then
            local cloudAccess = SafeCloudAccess()
            if cloudAccess then
                _G.CloudSettings.OriginalColor = cloudAccess.getColor()
                _G.CloudSettings.OriginalCover = cloudAccess.getCover()
                _G.CloudSettings.OriginalDensity = cloudAccess.getDensity()
            end
        end
        if _G.CloudsUpdateConnection then
            _G.CloudsUpdateConnection:Disconnect()
            _G.CloudsUpdateConnection = nil
        end
        if value then
            _G.CloudSettings.OverrideActive = true
            _G.CloudsUpdateConnection = RunService.Heartbeat:Connect(function()
                if _G.CloudSettings.OverrideActive then
                    local cloudAccess = SafeCloudAccess()
                    if not cloudAccess then return end
                    cloudAccess.setEnabled(true)
                    cloudAccess.setColor(_G.CloudSettings.Color)
                    cloudAccess.setCover(_G.CloudSettings.Cover)
                    cloudAccess.setDensity(_G.CloudSettings.Density)
                end
            end)
        else
            _G.CloudSettings.OverrideActive = false
            local cloudAccess = SafeCloudAccess()
            if cloudAccess then
                cloudAccess.setEnabled(false)
            end
        end
        syncCloudUI()
    end
}, "WorldToggleClouds")
WorldCloudsEnabled = false
ESP._ui.worldCloudColorPickerEl = cloudSection:Colorpicker({
    Name = "Cloud Color",
    Flag = "WorldCloudColor",
    Default = Color3.fromRGB(255, 255, 255),
    Alpha = 0,
    Callback = function(color)
        if not _G.CloudSettings then
            _G.CloudSettings = {
                Enabled = true,
                Color = Color3.fromRGB(255, 255, 255),
                Cover = 0.5,
                Density = 0.5,
                OriginalColor = nil,
                OriginalCover = nil,
                OriginalDensity = nil,
                OverrideActive = false
            }
        end
        _G.CloudSettings.Color = color
        local terrain = Workspace:FindFirstChildOfClass("Terrain")
        if not terrain then return end
        local cloudExists = false
        pcall(function() cloudExists = terrain.Clouds ~= nil end)
        if not cloudExists then
            return
        end
        if not _G.CloudSettings.OriginalCover then
            local cloudAccess = SafeCloudAccess()
            if cloudAccess then
                _G.CloudSettings.OriginalColor = cloudAccess.getColor()
                _G.CloudSettings.OriginalCover = cloudAccess.getCover()
                _G.CloudSettings.OriginalDensity = cloudAccess.getDensity()
            end
        end
        if _G.CloudSettings.OverrideActive then
            local cloudAccess = SafeCloudAccess()
            if cloudAccess then
                cloudAccess.setColor(color)
            end
        end
    end
}, "WorldCloudColor")
ESP._ui.worldCloudCoverSliderEl = cloudSection:Slider({
    Name = "Cloud Cover",
    Flag = "WorldCloudCover",
    Default = 0.5,
    Minimum = 0,
    Maximum = 1,
    Precision = 2,
    Callback = function(value)
        if not _G.CloudSettings then
            _G.CloudSettings = {
                Enabled = true,
                Color = Color3.fromRGB(255, 255, 255),
                Cover = 0.5,
                Density = 0.5,
                OriginalColor = nil,
                OriginalCover = nil,
                OriginalDensity = nil,
                OverrideActive = false
            }
        end
        _G.CloudSettings.Cover = value
        local terrain = Workspace:FindFirstChildOfClass("Terrain")
        if not terrain then return end
        local cloudExists = false
        pcall(function() cloudExists = terrain.Clouds ~= nil end)
        if not cloudExists then
            return
        end
        if not _G.CloudSettings.OriginalCover then
            local cloudAccess = SafeCloudAccess()
            if cloudAccess then
                _G.CloudSettings.OriginalColor = cloudAccess.getColor()
                _G.CloudSettings.OriginalCover = cloudAccess.getCover()
                _G.CloudSettings.OriginalDensity = cloudAccess.getDensity()
            end
        end
        if _G.CloudSettings.OverrideActive then
            local cloudAccess = SafeCloudAccess()
            if cloudAccess then
                cloudAccess.setCover(value)
            end
        end
    end
}, "WorldCloudCover")
ESP._ui.worldCloudDensitySliderEl = cloudSection:Slider({
    Name = "Cloud Density",
    Flag = "WorldCloudDensity",
    Default = 0.5,
    Minimum = 0,
    Maximum = 1,
    Precision = 2,
    Callback = function(value)
        if not _G.CloudSettings then
            _G.CloudSettings = {
                Enabled = true,
                Color = Color3.fromRGB(255, 255, 255),
                Cover = 0.5,
                Density = 0.5,
                OriginalColor = nil,
                OriginalCover = nil,
                OriginalDensity = nil,
                OverrideActive = false
            }
        end
        _G.CloudSettings.Density = value
        local terrain = Workspace:FindFirstChildOfClass("Terrain")
        if not terrain then return end
        local cloudExists = false
        pcall(function() cloudExists = terrain.Clouds ~= nil end)
        if not cloudExists then
            return
        end
        if not _G.CloudSettings.OriginalCover then
            local cloudAccess = SafeCloudAccess()
            if cloudAccess then
                _G.CloudSettings.OriginalColor = cloudAccess.getColor()
                _G.CloudSettings.OriginalCover = cloudAccess.getCover()
                _G.CloudSettings.OriginalDensity = cloudAccess.getDensity()
            end
        end
        if _G.CloudSettings.OverrideActive then
            local cloudAccess = SafeCloudAccess()
            if cloudAccess then
                cloudAccess.setDensity(value)
            end
        end
    end
}, "WorldCloudDensity")
ESP._ui.worldCloudResetButtonEl = cloudSection:Button({
    Name = "Reset Cloud Settings",
    Callback = function()
        if _G.CloudSettings then
            _G.CloudSettings.OverrideActive = false
            if _G.CloudsUpdateConnection then
                _G.CloudsUpdateConnection:Disconnect()
                _G.CloudsUpdateConnection = nil
            end
            local terrain = Workspace:FindFirstChildOfClass("Terrain")
            if terrain and _G.CloudSettings.OriginalCover then
                local cloudExists = false
                pcall(function() cloudExists = terrain.Clouds ~= nil end)
                if not cloudExists then
                    return
                end
                local cloudAccess = SafeCloudAccess()
                if cloudAccess then
                    cloudAccess.setColor(_G.CloudSettings.OriginalColor)
                    cloudAccess.setCover(_G.CloudSettings.OriginalCover)
                    cloudAccess.setDensity(_G.CloudSettings.OriginalDensity)
                    cloudAccess.setEnabled(true)
                end
            end
            _G.CloudSettings = nil
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
})
local timeSection = tabs.World:Section({ Side = "Right", Name = "Time Settings" })
timeSection:Header({
    Text = "Time Changer"
})
ESP._ui.worldCustomTimeToggleEl = timeSection:Toggle({
    Name = "Custom Time",
    Flag = "WorldCustomTime",
    Default = false,
    Callback = function(value)
        local prev = WorldCustomTimeEnabled and true or false
        WorldCustomTimeEnabled = value and true or false
        _G.TimeChangerEnabled = value
        if prev == WorldCustomTimeEnabled then
            if ESP and ESP._ui and ESP._ui._syncESPVisibility then
                ESP._ui._syncESPVisibility()
            end
            return
        end
        if value then
            _G.OriginalTimeSettings = {
                ClockTime = Lighting.ClockTime,
                GeographicLatitude = Lighting.GeographicLatitude
            }
            if _G.ServerTimeUpdateConnection then
                _G.ServerTimeUpdateConnection:Disconnect()
                _G.ServerTimeUpdateConnection = nil
            end
            if not _G.TimeChangerConnection then
                _G.TimeChangerConnection = RunService.Heartbeat:Connect(function()
                    if _G.TimeChangerEnabled then
                        Lighting.ClockTime = _G.CustomTime or 12
                    end
                end)
            end
        else
            if _G.TimeChangerConnection then
                _G.TimeChangerConnection:Disconnect()
                _G.TimeChangerConnection = nil
            end
            if _G.OriginalTimeSettings then
                Lighting.ClockTime = _G.OriginalTimeSettings.ClockTime
                Lighting.GeographicLatitude = _G.OriginalTimeSettings.GeographicLatitude
                _G.OriginalTimeSettings = nil
            end
            _G.ServerTimeUpdateConnection = RunService.Heartbeat:Connect(function()
                task.wait(0.5)
                if _G.ServerTimeUpdateConnection then
                    _G.ServerTimeUpdateConnection:Disconnect()
                    _G.ServerTimeUpdateConnection = nil
                end
            end)
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "WorldCustomTime")
WorldCustomTimeEnabled = false
ESP._ui.worldTimeOfDaySliderEl = timeSection:Slider({
    Name = "Time of Day",
    Flag = "WorldTimeOfDay",
    Default = 12,
    Minimum = 0,
    Maximum = 24,
    Precision = 1,
    Callback = function(value)
        _G.CustomTime = value
        if _G.TimeChangerEnabled then
            Lighting.ClockTime = value
        end
    end
}, "WorldTimeOfDay")
if ESP and ESP._ui and ESP._ui._syncESPVisibility then
    ESP._ui._syncESPVisibility()
end
LootESP.StartDroppedItemTracking = function()
    task.spawn(function()
        local droppedItemsFolder = workspace:FindFirstChild("DroppedItems")
        if not droppedItemsFolder then
            droppedItemsFolder = workspace:WaitForChild("DroppedItems", 10)
        end
        if not droppedItemsFolder then return end
        local function addDroppedItem(model)
            if not model:IsA("Model") then return end
            if model.Parent ~= droppedItemsFolder then return end
            if LootESP.DroppedItems.Cache[model] or LootESP.Corpses.Cache[model] then return end
            local isCorpse = model:FindFirstChild("Humanoid") and (model:FindFirstChild("Head") or model:FindFirstChild("HumanoidRootPart"))
            if not isCorpse and safeLength(LootESP.DroppedItems.PriorityList) > 0 then
                 if not table.find(LootESP.DroppedItems.PriorityList, model.Name) then
                     return
                 end
            end
            local targetCache = isCorpse and LootESP.Corpses or LootESP.DroppedItems
            local adorneePart = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("Head") or model:FindFirstChild("UpperTorso") or model:FindFirstChild("Torso") or model:FindFirstChildWhichIsA("BasePart") or model
            local highlight = CreateInstance("Highlight", {
                Adornee = model,
                Parent = LootESP:_GetHolder(),
                FillColor = targetCache.ChamsColor,
                OutlineColor = Color3.fromRGB(255, 255, 255),
                FillTransparency = LootESP.ChamsTransparency,
                OutlineTransparency = 0,
                DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            })
            local billboard = CreateInstance("BillboardGui", {
                Parent = model,
                Adornee = adorneePart,
                Size = UDim2.new(0, 200, 0, 55),
                StudsOffset = Vector3.new(0, 2, 0),
                AlwaysOnTop = true,
                LightInfluence = 0
            })
            local icon = CreateInstance("ImageLabel", {
                Name = "Icon",
                Parent = billboard,
                BackgroundTransparency = 1,
                Image = isCorpse and LootESP.Icons.Corpse or LootESP.Icons.Item,
                ImageColor3 = targetCache.NameColor,
                ImageTransparency = LootESP.TextTransparency,
                ScaleType = Enum.ScaleType.Fit,
                Size = UDim2.new(0, 18, 0, 18),
                Position = UDim2.new(0.5, -9, 0, 0),
                ZIndex = 2,
                Visible = LootESP.Enabled and targetCache.Enabled and targetCache.IconEnabled
            })
            pcall(function()
                game:GetService("ContentProvider"):PreloadAsync({ icon })
            end)
            local textLabel = CreateInstance("TextLabel", {
                Parent = billboard,
                Size = UDim2.new(1, 0, 0, 33),
                Position = UDim2.new(0, 0, 0, 20),
                BackgroundTransparency = 1,
                Text = model.Name,
                TextColor3 = targetCache.NameColor,
                TextStrokeTransparency = 0,
                TextTransparency = LootESP.TextTransparency,
                Font = Enum.Font.SourceSansBold,
                TextSize = ESP.FontSize or 14,
                RichText = true,
                Visible = LootESP.Enabled and targetCache.Enabled and targetCache.NameEnabled
            })
            highlight.Enabled = LootESP.Enabled and targetCache.Enabled and targetCache.ChamsEnabled
            billboard.Enabled = LootESP.Enabled and targetCache.Enabled and (targetCache.NameEnabled or targetCache.IconEnabled)
            targetCache.Cache[model] = {
                Highlight = highlight,
                Billboard = billboard,
                Icon = icon,
                TextLabel = textLabel
            }
        end
        for _, v in pairs(droppedItemsFolder:GetChildren()) do
            addDroppedItem(v)
        end
        LootESP.DroppedItems.Connection = droppedItemsFolder.ChildAdded:Connect(addDroppedItem)
    end)
end
LootESP.StopDroppedItemTracking = function()
    if LootESP.DroppedItems.Connection then
        LootESP.DroppedItems.Connection:Disconnect()
        LootESP.DroppedItems.Connection = nil
    end
    for model, data in pairs(LootESP.DroppedItems.Cache) do
        if data.Highlight then data.Highlight:Destroy() end
        if data.Billboard then data.Billboard:Destroy() end
    end
    LootESP.DroppedItems.Cache = {}
    for model, data in pairs(LootESP.Corpses.Cache) do
        if data.Highlight then data.Highlight:Destroy() end
        if data.Billboard then data.Billboard:Destroy() end
    end
    LootESP.Corpses.Cache = {}
end
LootESP.StartContainerTracking = function()
    task.spawn(function()
        local containerFolder = workspace:FindFirstChild("Containers")
        if not containerFolder then
            containerFolder = workspace:WaitForChild("Containers", 10)
        end
        if not containerFolder then return end
        local function addContainer(model)
            if not model:IsA("Model") then return end
            if LootESP.Containers.Cache[model] then return end
            if safeLength(LootESP.PriorityList) > 0 then
                 if not table.find(LootESP.PriorityList, model.Name) then
                     return
                 end
            end
            local highlight = CreateInstance("Highlight", {
                Adornee = model,
                Parent = LootESP:_GetHolder(),
                FillColor = LootESP.Containers.ChamsColor,
                OutlineColor = Color3.fromRGB(255, 255, 255),
                FillTransparency = LootESP.ChamsTransparency,
                OutlineTransparency = 0,
                DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            })
            local billboard = CreateInstance("BillboardGui", {
                Parent = model,
                Adornee = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart") or model:FindFirstChild("HumanoidRootPart") or model,
                Size = UDim2.new(0, 200, 0, 55),
                StudsOffset = Vector3.new(0, 2, 0),
                AlwaysOnTop = true,
                LightInfluence = 0
            })
            local icon = CreateInstance("ImageLabel", {
                Name = "Icon",
                Parent = billboard,
                BackgroundTransparency = 1,
                Image = LootESP.Icons.Container,
                ImageColor3 = LootESP.Containers.NameColor,
                ImageTransparency = LootESP.TextTransparency,
                ScaleType = Enum.ScaleType.Fit,
                Size = UDim2.new(0, 18, 0, 18),
                Position = UDim2.new(0.5, -9, 0, 0),
                ZIndex = 2,
                Visible = LootESP.Enabled and LootESP.Containers.Enabled and LootESP.Containers.IconEnabled
            })
            pcall(function()
                game:GetService("ContentProvider"):PreloadAsync({ icon })
            end)
            local textLabel = CreateInstance("TextLabel", {
                Parent = billboard,
                Size = UDim2.new(1, 0, 0, 33),
                Position = UDim2.new(0, 0, 0, 20),
                BackgroundTransparency = 1,
                Text = model.Name,
                TextColor3 = LootESP.Containers.NameColor,
                TextStrokeTransparency = 0,
                TextTransparency = LootESP.TextTransparency,
                Font = Enum.Font.SourceSansBold,
                TextSize = ESP.FontSize or 14,
                RichText = true,
                Visible = LootESP.Enabled and LootESP.Containers.Enabled and LootESP.Containers.NameEnabled
            })
            highlight.Enabled = LootESP.Enabled and LootESP.Containers.Enabled and LootESP.Containers.ChamsEnabled
            billboard.Enabled = LootESP.Enabled and LootESP.Containers.Enabled and (LootESP.Containers.NameEnabled or LootESP.Containers.IconEnabled)
            LootESP.Containers.Cache[model] = {
                Highlight = highlight,
                Billboard = billboard,
                Icon = icon,
                TextLabel = textLabel
            }
        end
        for _, v in pairs(containerFolder:GetDescendants()) do
            addContainer(v)
        end
        LootESP.Containers.Connection = containerFolder.DescendantAdded:Connect(addContainer)
    end)
end
LootESP.StopContainerTracking = function()
    if LootESP.Containers.Connection then
        LootESP.Containers.Connection:Disconnect()
        LootESP.Containers.Connection = nil
    end
    for model, data in pairs(LootESP.Containers.Cache) do
        if data.Highlight then data.Highlight:Destroy() end
        if data.Billboard then data.Billboard:Destroy() end
    end
    LootESP.Containers.Cache = {}
end
LootESP.StartExitTracking = function()
    task.spawn(function()
        local noCollision = workspace:FindFirstChild("NoCollision")
        if not noCollision then
            noCollision = workspace:WaitForChild("NoCollision", 10)
        end
        if not noCollision then return end
        local exitLocations = noCollision:FindFirstChild("ExitLocations")
        if not exitLocations then
            exitLocations = noCollision:WaitForChild("ExitLocations", 10)
        end
        if not exitLocations then return end
        local function addExit(obj)
            if LootESP.Exits.Cache[obj] then return end
            local adorneePart
            if obj:IsA("BasePart") then
                adorneePart = obj
            elseif obj:IsA("Model") then
                adorneePart = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
            else
                return
            end
            if not adorneePart then return end
            local billboard = CreateInstance("BillboardGui", {
                Name = "ExitESP",
                Parent = obj,
                Adornee = adorneePart,
                Size = UDim2.new(0, 90, 0, 55),
                StudsOffset = Vector3.new(0, 2.5, 0),
                AlwaysOnTop = true,
                LightInfluence = 0
            })
            local icon = CreateInstance("ImageLabel", {
                Name = "Icon",
                Parent = billboard,
                BackgroundTransparency = 1,
                Image = "rbxthumb://type=Asset&id=9405925538&w=420&h=420",
                ImageColor3 = LootESP.Exits.Color,
                ImageTransparency = 0,
                ScaleType = Enum.ScaleType.Fit,
                Size = UDim2.new(0, 24, 0, 24),
                Position = UDim2.new(0.5, -12, 0, 0),
                ZIndex = 2,
                Visible = LootESP.Exits.IconEnabled
            })
            pcall(function()
                game:GetService("ContentProvider"):PreloadAsync({ icon })
            end)
            local textLabel = CreateInstance("TextLabel", {
                Name = "Distance",
                Parent = billboard,
                BackgroundTransparency = 1,
                Size = UDim2.new(1, 0, 0, 22),
                Position = UDim2.new(0, 0, 0, 28),
                TextColor3 = LootESP.Exits.Color,
                TextStrokeTransparency = 0,
                Font = Enum.Font.SourceSansBold,
                TextSize = ESP.FontSize or 14,
                Text = obj.Name,
                ZIndex = 1,
                Visible = LootESP.Exits.DistanceEnabled
            })
            LootESP.Exits.Cache[obj] = {
                Billboard = billboard,
                Icon = icon,
                TextLabel = textLabel,
                Adornee = adorneePart
            }
        end
        for _, v in pairs(exitLocations:GetChildren()) do
            addExit(v)
        end
        if LootESP.Exits.Connection then
            LootESP.Exits.Connection:Disconnect()
        end
        LootESP.Exits.Connection = exitLocations.ChildAdded:Connect(addExit)
    end)
end
LootESP.StopExitTracking = function()
    if LootESP.Exits.Connection then
        LootESP.Exits.Connection:Disconnect()
        LootESP.Exits.Connection = nil
    end
    for obj, data in pairs(LootESP.Exits.Cache) do
        if data.Billboard then data.Billboard:Destroy() end
        LootESP.Exits.Cache[obj] = nil
    end
end
LootESP._Clock = LootESP._Clock or (os_clock or os.clock)
LootESP._UpdateInterval = LootESP._UpdateInterval or 0.12
LootESP._NextUpdate = LootESP._NextUpdate or 0
function LootESP:_SetEnabled(inst, v)
    if inst and inst.Enabled ~= v then
        inst.Enabled = v
    end
end
function LootESP:_SetVisible(inst, v)
    if inst and inst.Visible ~= v then
        inst.Visible = v
    end
end
function LootESP:_StepCache(cache, iterKey, budget, typeEnabled, chamsEnabled, nameEnabled, iconEnabled, chamsColor, nameColor, lpPos, studsPerMeter, maxDistSq)
    local processed = 0
    local k = iterKey
    while processed < budget do
        local model, data = next(cache, k)
        if not model then
            return nil
        end
        k = model
        if not model.Parent then
            if data.Highlight then pcall(function() data.Highlight:Destroy() end) end
            if data.Billboard then pcall(function() data.Billboard:Destroy() end) end
            cache[model] = nil
            processed += 1
            continue
        end
        if not typeEnabled then
            if data.Highlight then self:_SetEnabled(data.Highlight, false) end
            if data.Billboard then self:_SetEnabled(data.Billboard, false) end
            processed += 1
            continue
        end
        local rootPart = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart") or model:FindFirstChild("Head") or model:FindFirstChild("UpperTorso") or model:FindFirstChild("Torso") or model:FindFirstChildWhichIsA("BasePart")
        if rootPart and rootPart.Parent then
            local diff = rootPart.Position - lpPos
            local distSq = diff:Dot(diff)
            if distSq > maxDistSq then
                if data.Highlight then self:_SetEnabled(data.Highlight, false) end
                if data.Billboard then self:_SetEnabled(data.Billboard, false) end
            else
                local distM = math.sqrt(distSq) / studsPerMeter
                local distFloor = math.floor(distM)
                if data.Highlight then
                    if chamsEnabled then
                        self:_SetEnabled(data.Highlight, true)
                        if data._lastChamsTrans ~= self.ChamsTransparency then
                            data.Highlight.FillTransparency = self.ChamsTransparency
                            data._lastChamsTrans = self.ChamsTransparency
                        end
                        if data._lastChamsColor ~= chamsColor then
                            data.Highlight.FillColor = chamsColor
                            data._lastChamsColor = chamsColor
                        end
                    else
                        self:_SetEnabled(data.Highlight, false)
                    end
                end
                local billboardEnabled = nameEnabled or iconEnabled
                if data.Billboard then
                    self:_SetEnabled(data.Billboard, billboardEnabled)
                end
                if billboardEnabled then
                    if data.Icon then
                        self:_SetVisible(data.Icon, iconEnabled)
                        if data._lastIconColor ~= nameColor then
                            data.Icon.ImageColor3 = nameColor
                            data._lastIconColor = nameColor
                        end
                        if data._lastIconTrans ~= self.TextTransparency then
                            data.Icon.ImageTransparency = self.TextTransparency
                            data._lastIconTrans = self.TextTransparency
                        end
                    end
                    if data.TextLabel then
                        self:_SetVisible(data.TextLabel, nameEnabled)
                        if data._lastTextColor ~= nameColor then
                            data.TextLabel.TextColor3 = nameColor
                            data._lastTextColor = nameColor
                        end
                        if data._lastTextTrans ~= self.TextTransparency then
                            data.TextLabel.TextTransparency = self.TextTransparency
                            data._lastTextTrans = self.TextTransparency
                        end
                        if nameEnabled then
                            if data._lastDist ~= distFloor then
                                data.TextLabel.Text = model.Name .. " [" .. distFloor .. "m]"
                                data._lastDist = distFloor
                            end
                        else
                            if data._lastDist ~= -1 then
                                data.TextLabel.Text = model.Name
                                data._lastDist = -1
                            end
                        end
                    end
                end
            end
        end
        processed += 1
    end
    return k
end
function LootESP:_StepExits(cache, iterKey, budget, enabled, lpPos, studsPerMeter, maxDistSq)
    local processed = 0
    local k = iterKey
    while processed < budget do
        local obj, data = next(cache, k)
        if not obj then
            return nil
        end
        k = obj
        if not obj.Parent then
            if data.Billboard then pcall(function() data.Billboard:Destroy() end) end
            cache[obj] = nil
            processed += 1
            continue
        end
        if not enabled then
            if data.Billboard then self:_SetEnabled(data.Billboard, false) end
            processed += 1
            continue
        end
        local adornee = data.Adornee
        if not adornee or not adornee.Parent then
            if data.Billboard then self:_SetEnabled(data.Billboard, false) end
            processed += 1
            continue
        end
        local diff = adornee.Position - lpPos
        local distSq = diff:Dot(diff)
        if distSq > maxDistSq then
            if data.Billboard then self:_SetEnabled(data.Billboard, false) end
        else
            local distM = math.sqrt(distSq) / studsPerMeter
            local distFloor = math.floor(distM)
            if data.Billboard then self:_SetEnabled(data.Billboard, true) end
            if data.Icon then
                self:_SetVisible(data.Icon, self.Exits.IconEnabled)
                if data._lastExitIconColor ~= self.Exits.Color then
                    data.Icon.ImageColor3 = self.Exits.Color
                    data._lastExitIconColor = self.Exits.Color
                end
            end
            if data.TextLabel then
                self:_SetVisible(data.TextLabel, self.Exits.DistanceEnabled)
                if data._lastExitTextColor ~= self.Exits.Color then
                    data.TextLabel.TextColor3 = self.Exits.Color
                    data._lastExitTextColor = self.Exits.Color
                end
                if self.Exits.DistanceEnabled then
                    if data._lastExitDist ~= distFloor then
                        data.TextLabel.Text = obj.Name .. " [" .. distFloor .. "m]"
                        data._lastExitDist = distFloor
                    end
                else
                    if data._lastExitDist ~= -1 then
                        data.TextLabel.Text = obj.Name
                        data._lastExitDist = -1
                    end
                end
            end
        end
        processed += 1
    end
    return k
end
runs.Heartbeat:Connect(function()
    local now = LootESP._Clock()
    if now < LootESP._NextUpdate then return end
    LootESP._NextUpdate = now + LootESP._UpdateInterval
    local character = localplayer.Character
    local rootPart = character and (character.PrimaryPart or character:FindFirstChild("HumanoidRootPart"))
    if not rootPart then
        local dummyPos = Vector3.new(0, 0, 0)
        LootESP._IterContainers = LootESP:_StepCache(LootESP.Containers.Cache, LootESP._IterContainers, 150, false, false, false, false, LootESP.Containers.ChamsColor, LootESP.Containers.NameColor, dummyPos, 1, 0)
        LootESP._IterDropped = LootESP:_StepCache(LootESP.DroppedItems.Cache, LootESP._IterDropped, 150, false, false, false, false, LootESP.DroppedItems.ChamsColor, LootESP.DroppedItems.NameColor, dummyPos, 1, 0)
        LootESP._IterCorpses = LootESP:_StepCache(LootESP.Corpses.Cache, LootESP._IterCorpses, 150, false, false, false, false, LootESP.Corpses.ChamsColor, LootESP.Corpses.NameColor, dummyPos, 1, 0)
        LootESP._IterExits = LootESP:_StepExits(LootESP.Exits.Cache, LootESP._IterExits, 120, false, dummyPos, 1, 0)
        return
    end
    local studsPerMeter = (allvars and allvars._units and allvars._units.studsPerMeter) or 1
    local lpPos = rootPart.Position
    local maxStuds = LootESP.MaxDistance * studsPerMeter
    local maxDistSq = maxStuds * maxStuds
    local exitsMaxStuds = LootESP.Exits.MaxDistance * studsPerMeter
    local exitsMaxDistSq = exitsMaxStuds * exitsMaxStuds
    local worldEnabled = LootESP.Enabled
    LootESP._IterContainers = LootESP:_StepCache(LootESP.Containers.Cache, LootESP._IterContainers, 90, worldEnabled and LootESP.Containers.Enabled, LootESP.Containers.ChamsEnabled, LootESP.Containers.NameEnabled, LootESP.Containers.IconEnabled, LootESP.Containers.ChamsColor, LootESP.Containers.NameColor, lpPos, studsPerMeter, maxDistSq)
    LootESP._IterDropped = LootESP:_StepCache(LootESP.DroppedItems.Cache, LootESP._IterDropped, 90, worldEnabled and LootESP.DroppedItems.Enabled, LootESP.DroppedItems.ChamsEnabled, LootESP.DroppedItems.NameEnabled, LootESP.DroppedItems.IconEnabled, LootESP.DroppedItems.ChamsColor, LootESP.DroppedItems.NameColor, lpPos, studsPerMeter, maxDistSq)
    LootESP._IterCorpses = LootESP:_StepCache(LootESP.Corpses.Cache, LootESP._IterCorpses, 90, worldEnabled and LootESP.Corpses.Enabled, LootESP.Corpses.ChamsEnabled, LootESP.Corpses.NameEnabled, LootESP.Corpses.IconEnabled, LootESP.Corpses.ChamsColor, LootESP.Corpses.NameColor, lpPos, studsPerMeter, maxDistSq)
    LootESP._IterExits = LootESP:_StepExits(LootESP.Exits.Cache, LootESP._IterExits, 60, LootESP.Exits.Enabled, lpPos, studsPerMeter, exitsMaxDistSq)
end)
local Functions = {}
    function Functions:Create(Class, Properties)
        local inst = typeof(Class) == "string" and CreateInstance(Class) or Class
        for property, value in pairs(Properties) do
            inst[property] = value
        end
    return inst
    end
    function Functions:FadeOutOnDist(element, distance)
        local transparency = math.max(0.1, 1 - (distance / ESP.MaxDistance))
        if element:IsA("TextLabel") then
            element.TextTransparency = 1 - transparency
        elseif element:IsA("ImageLabel") then
            element.ImageTransparency = 1 - transparency
        elseif element:IsA("UIStroke") then
            element.Transparency = 1 - transparency
        elseif element:IsA("Frame") and (element.Name == "Healthbar" or element.Name == "BehindHealthbar") then
            element.BackgroundTransparency = 1 - transparency
        elseif element:IsA("Frame") then
            element.BackgroundTransparency = 1 - transparency
        elseif element:IsA("Highlight") then
            element.FillTransparency = 1 - transparency
            element.OutlineTransparency = 1 - transparency
    end
end
    function Functions:SilentAim()
        if Functions:TargetPlayer() and Configurations.Aimbot.Enabled then
            if Configurations.Aimbot['Aim Type'] == "Silent" and Configurations.Aimbot.Enabled and Functions:TargetPlayer() and SilentAim.Holding and tick() - autoshootdelay >= 0.30 then
                local Origin = Camera.CFrame.p
                local Distination = Functions:TargetPlayer().Position
                local Velocity = Functions:TargetPlayer().Velocity
                local vm = game.FindFirstChildOfClass(Camera, "Model") or nil
                local aimpart = vm and game.FindFirstChild(vm, "AimPart") or nil
                autoshootdelay = tick()
                local rnd = math.random(-10000, 10000)
                FireProjectile:InvokeServer(
                    Vector3.new(0/0, 0/0, 0/0),
                    rnd,
                    autoshootdelay
                )
                local drawing, deleteme, deleteme1 = make_beam(aimpart and aimpart.Position or Camera.CFrame.p, Distination, Configurations.FOVSettings['FOV Circle'].Color)
                local wtf = -1
                local conn; conn = RunService.RenderStepped:Connect(LPH_JIT_MAX(function(delta)
                    wtf = wtf + delta
                    drawing.Transparency = NumberSequence.new(math.clamp(wtf, 0, 1))
                    if wtf >= 1 then
                        drawing:Destroy()
                        deleteme:Destroy()
                        deleteme1:Destroy()
                        conn:Disconnect()
                    end
                end))
            end
        end
    end
local function handleModDetect()
    if allvars.detectmods then
        for _, player in pairs(game.Players:GetPlayers()) do
            if detectedmods[player.Name] ~= nil then continue end
            local pinfo = game.ReplicatedStorage.Players:FindFirstChild(player.Name)
            if not pinfo then continue end
            local status = pinfo:FindFirstChild("Status")
            if not status then continue end
            if not status:FindFirstChild("UAC") then continue end
            if not status:FindFirstChild("GameplayVariables") then continue end
            local function detectmod(plrname, reason)
                detectedmods[plrname] = true
                if mdetect == true then return end
                mdetect = true
                Window:Notify({
                    Title = "MOD DETECTED",
                    Description = "Moderator: " .. plrname .. "\nReason: " .. reason,
                    Lifetime = 60
                })
                local notsound = Instance.new("Sound")
                notsound.SoundId = "rbxassetid://1841354443"
                notsound.Parent = workspace
                notsound:Play()
                if allvars.espextract then
                    allvars.espextract = false
                    Window:Notify({
                        Title = "Safety",
                        Description = "Extract ESP Disabled",
                        Lifetime = 5
                    })
                end
            end
            if status.UAC:GetAttribute("Enabled") == true then
                detectmod(player.Name, "uac enabled")
                continue
            elseif (status.GameplayVariables:GetAttribute("Godmode") == true or status.GameplayVariables:GetAttribute("GodMode") == true) then
                detectmod(player.Name, "godmode enabled")
                continue
            elseif status.GameplayVariables:GetAttribute("PremiumLevel") and status.GameplayVariables:GetAttribute("PremiumLevel") >= 4 then
                detectmod(player.Name, "premium level >= 4")
                continue
            elseif status.UAC:GetAttribute("A1Detected") == true then
                detectmod(player.Name, "A1Detected")
                continue
            elseif status.UAC:GetAttribute("A2Detected") == true then
                detectmod(player.Name, "A2Detected")
                continue
            elseif status.UAC:GetAttribute("A3Detected") == true then
                detectmod(player.Name, "A3Detected")
                continue
            end
        end
    end
end
task.spawn(function()
    while true do
        handleModDetect()
        task.wait(1)
    end
end)
local function InitializeESP()
    local ScreenGui = GetOrCreateCoreGuiObject("ESPHolder", "ScreenGui")
    local function get_gun(player)
        local Player = game:GetService("ReplicatedStorage").Players:FindFirstChild(player.Name)
        if Player and Player:FindFirstChild("Status") and Player.Status:FindFirstChild("GameplayVariables") and Player.Status.GameplayVariables:FindFirstChild("EquippedTool") and Player.Status.GameplayVariables.EquippedTool.Value then
            local Equipped = Player.Status.GameplayVariables.EquippedTool.Value
            local weaponName = tostring(Equipped)
            local inventory = Player:FindFirstChild("Inventory")
            if inventory then
                local weaponObj = inventory:FindFirstChild(weaponName)
                if weaponObj then
                    local ammo = nil
                    local attachments = weaponObj:FindFirstChild("Attachments")
                    if attachments then
                        for _, child in pairs(attachments:GetChildren()) do
                            if child:GetAttribute("Slot") == "Magazine" and child:GetAttribute("LoadedAmmo") then
                                ammo = child:GetAttribute("LoadedAmmo")
                                break
                            end
                        end
                    end
                    if not ammo and weaponObj:GetAttribute("LoadedAmmo") then
                        ammo = weaponObj:GetAttribute("LoadedAmmo")
                    end
                    if ammo and ESP.Drawing.Weapons.Ammo then
                        return string.format("%s [%s]", weaponName, tostring(ammo))
                    end
                end
            end
            return weaponName
        end
        return "None"
    end
    local function ESP_Draw(plr)
        local lplayer = Players.LocalPlayer
        local RotationAngle, Tick = -45, tick()
        if ScreenGui:FindFirstChild(plr.Name) then
            ScreenGui[plr.Name]:Destroy()
        end
        local ESPContainer = Functions:Create("Folder", {
            Parent = ScreenGui,
            Name = plr.Name
        })
        local Name = CreateEspLabel(ESPContainer, UDim2.new(0.5, 0, 0, -11), ESP.Drawing.Names.RGB, false, true)
        local InventoryValue = CreateEspLabel(ESPContainer, UDim2.new(0.5, 0, 0, -30), Color3.fromRGB(100, 255, 100), false, true)
        Name.Text = plr.Name
        Name.Visible = ESP.Drawing.Names.Enabled
        local Distance = CreateEspLabel(ESPContainer, UDim2.new(0.5, 0, 0, 11), ESP.Drawing.Distances.RGB, false, true)
        local Weapon = CreateEspLabel(ESPContainer, UDim2.new(0.5, 0, 0, 25), ESP.Drawing.Weapons.WeaponTextRGB, false, true)
        local Box = Functions:Create("Frame", {
            Parent = ESPContainer,
            BackgroundColor3 = Color3.fromRGB(0, 0, 0),
            BackgroundTransparency = 0.75,
            BorderSizePixel = 0,
            ClipsDescendants = true,
            Name = "Box"
        })
        local BoxImage = Functions:Create("ImageLabel", {
            Parent = ESPContainer,
            Name = "BoxImage",
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            Position = UDim2.new(0, 0, 0, 0),
            Size = UDim2.new(0, 0, 0, 0),
            ZIndex = 20,
            Visible = false,
            Image = "",
            ImageTransparency = 1,
            ImageColor3 = Color3.fromRGB(255, 255, 255),
            ScaleType = Enum.ScaleType.Stretch
        })
        local espRayParams = RaycastParams.new()
        espRayParams.FilterType = Enum.RaycastFilterType.Exclude
        espRayParams.IgnoreWater = false
        local _boxImageLastVisible = false
        local _boxImageLastRaw = nil
        local _boxImageLastSource = nil
        local _boxImageLastTransp = nil
        local _boxImageLastColor = nil
        local _boxImageLastScale = nil
        local _boxImageLastX, _boxImageLastY, _boxImageLastW, _boxImageLastH = nil, nil, nil, nil
        local _visCached = false
        local _visNextAt = 0
        local _localCharCached = nil
        local function _isVisible()
            if not plr.Character then return false end
            local cam = Workspace.CurrentCamera
            if not cam then return false end
            local lchar = lplayer.Character
            if lchar ~= _localCharCached then
                _localCharCached = lchar
                if lchar then
                    espRayParams.FilterDescendantsInstances = { lchar }
                else
                    espRayParams.FilterDescendantsInstances = {}
                end
            end
            local origin = cam.CFrame.Position
            local head = plr.Character:FindFirstChild("Head")
            local hrp  = plr.Character:FindFirstChild("HumanoidRootPart") or plr.Character.PrimaryPart
            if head and head:IsA("BasePart") then
                local dir = head.Position - origin
                local res = workspace:Raycast(origin, dir, espRayParams)
                if (not res) or (res.Instance and res.Instance:IsDescendantOf(plr.Character)) then
                    return true
                end
            end
            if hrp and hrp:IsA("BasePart") then
                local dir = hrp.Position - origin
                local res = workspace:Raycast(origin, dir, espRayParams)
                if (not res) or (res.Instance and res.Instance:IsDescendantOf(plr.Character)) then
                    return true
                end
            end
            return false
        end
        local Gradient1 = Functions:Create("UIGradient", {
            Parent = Box,
            Enabled = ESP.Drawing.Boxes.GradientFill,
            Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientFillRGB1),
                ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientFillRGB2)
            }
        })
        local Outline = Functions:Create("UIStroke", {
            Parent = Box,
            Enabled = true,
            Transparency = 0,
            Color = ESP.Drawing.Boxes.Full.RGB or Color3.fromRGB(255, 255, 255),
            LineJoinMode = Enum.LineJoinMode.Miter
        })
        local Gradient2 = Functions:Create("UIGradient", {
            Parent = Outline,
            Enabled = ESP.Drawing.Boxes.Gradient,
            Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientRGB1),
                ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientRGB2)
            }
        })
        local cornerLines = {}
        local cornerGradients = {}
        local function createCornerLine(name)
            local line = Functions:Create("Frame", {
                Parent = Box,
                Name = name,
                BackgroundColor3 = ESP.Drawing.Boxes.Full.RGB or Color3.fromRGB(255, 255, 255),
                BackgroundTransparency = 0,
                BorderSizePixel = 0,
                Visible = false,
                ZIndex = 2
            })
            local grad = Functions:Create("UIGradient", {
                Parent = line,
                Enabled = false,
                Rotation = -45,
                Color = ColorSequence.new{
                    ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientRGB1),
                    ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientRGB2)
                }
            })
            cornerLines[name] = line
            cornerGradients[name] = grad
        end
        createCornerLine("CornerTopLeftH")
        createCornerLine("CornerTopLeftV")
        createCornerLine("CornerTopRightH")
        createCornerLine("CornerTopRightV")
        createCornerLine("CornerBottomLeftH")
        createCornerLine("CornerBottomLeftV")
        createCornerLine("CornerBottomRightH")
        createCornerLine("CornerBottomRightV")
        local Healthbar = Functions:Create("Frame", {
            Parent = ESPContainer,
            BackgroundColor3 = Color3.fromRGB(255, 255, 255),
            BackgroundTransparency = 0,
            Name = "Healthbar"
        })
        local BehindHealthbar = Functions:Create("Frame", {
            Parent = ESPContainer,
            ZIndex = -1,
            BackgroundColor3 = Color3.fromRGB(0, 0, 0),
            BackgroundTransparency = 0,
            Name = "BehindHealthbar",
            Visible = ESP.Drawing.Healthbar.Enabled
        })
        local HealthbarGradient = Functions:Create("UIGradient", {
            Parent = Healthbar,
            Enabled = ESP.Drawing.Healthbar.Gradient,
            Rotation = -90,
            Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, ESP.Drawing.Healthbar.GradientRGB1),
                ColorSequenceKeypoint.new(1, ESP.Drawing.Healthbar.GradientRGB2)
            }
        })
        local HealthText = CreateEspLabel(ESPContainer, UDim2.new(0.5, 0, 0, 31), Color3.fromRGB(255, 255, 255), false, false)
        local Chams = Functions:Create("Highlight", {
            Parent = ESPContainer,
            FillTransparency = 1,
            OutlineTransparency = 0,
            OutlineColor = Color3.fromRGB(119, 120, 255),
            DepthMode = "AlwaysOnTop"
        })
        local function HideESP()
            HideGuiObjects(ESPContainer)
            _boxImageLastVisible = false
            _boxImageLastRaw = nil
            _boxImageLastSource = nil
            _boxImageLastTransp = nil
            _boxImageLastColor = nil
            _boxImageLastScale = nil
            _boxImageLastX, _boxImageLastY, _boxImageLastW, _boxImageLastH = nil, nil, nil, nil
            if not plr or not plr.Parent then
                ESPContainer:Destroy()
                return
            end
        end
        local lastInvUpdate = 0
        local cachedInvValue = 0
        local Connection = RunService.RenderStepped:Connect(function()
            local Cam = Workspace.CurrentCamera
            if not Cam then
                HideESP()
                return
            end
            if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and ESP.Enabled then
                local HRP = plr.Character.HumanoidRootPart
                local Humanoid = plr.Character:FindFirstChild("Humanoid")
                if not Humanoid then return end
                if Humanoid.Health <= 0 then
                    HideESP()
                    return
                end
                local Pos, OnScreen = Cam:WorldToViewportPoint(HRP.Position)
                local Dist = (Cam.CFrame.Position - HRP.Position).Magnitude / allvars._units.studsPerMeter
                if OnScreen and Dist <= ESP.MaxDistance then
                    local boxType = tostring(ESP.Drawing.Boxes.BoxType or "Default")
                    local boxTypeKey = boxType:lower():gsub("%s+", "")
                    local useCorner = (boxTypeKey == "corner")
                    local useDynamic = ESP.Drawing.Boxes.Dynamic and true or false
                    local w, hAdj, yTop
                    local centerX, centerY = Pos.X, Pos.Y
                    if useDynamic and plr.Character then
                        local parts = GetCachedBodyParts(plr.Character)
                        local minX, maxX, minYRaw, maxYRaw = ComputeViewportBoundsFromParts(parts, Cam)
                        if minX and maxX and minYRaw and maxYRaw and minX < maxX and minYRaw < maxYRaw then
                            w = maxX - minX
                            centerX = (minX + maxX) * 0.5
                            centerY = (minYRaw + maxYRaw) * 0.5
                            yTop = ApplyResolutionStretchY(minYRaw, Cam)
                            local yBottom = ApplyResolutionStretchY(maxYRaw, Cam)
                            hAdj = yBottom - yTop
                        end
                    end
                    if not w or not hAdj or not yTop then
                        local Size = HRP.Size.Y
                        local realDist = (Cam.CFrame.Position - HRP.Position).Magnitude
                        local baseFOV = 70
                        local fovCompensation = math.tan(math.rad(baseFOV) / 2) / math.tan(math.rad(Cam.FieldOfView) / 2)
                        local fixedScaleFactor = (Size * Cam.ViewportSize.Y) / (realDist * 2) * fovCompensation
                        local h = 4.5 * fixedScaleFactor
                        w = 3 * fixedScaleFactor
                        local yTopRaw = centerY - h / 2
                        local yBottomRaw = centerY + h / 2
                        yTop = ApplyResolutionStretchY(yTopRaw, Cam)
                        local yBottom = ApplyResolutionStretchY(yBottomRaw, Cam)
                        hAdj = yBottom - yTop
                    end
                    local hHalfAdj = hAdj * 0.5
                    if ESP.FadeOut.OnDistance then
                        Functions:FadeOutOnDist(Box, Dist)
                        Functions:FadeOutOnDist(Outline, Dist)
                        if Name.Visible then Functions:FadeOutOnDist(Name, Dist) end
                        if InventoryValue.Visible then Functions:FadeOutOnDist(InventoryValue, Dist) end
                        if Distance.Visible then Functions:FadeOutOnDist(Distance, Dist) end
                        if Healthbar.Visible then Functions:FadeOutOnDist(Healthbar, Dist) end
                        if BehindHealthbar.Visible then Functions:FadeOutOnDist(BehindHealthbar, Dist) end
                        if HealthText.Visible then Functions:FadeOutOnDist(HealthText, Dist) end
                        if Chams.Enabled then Functions:FadeOutOnDist(Chams, Dist) end
                        if Weapon.Visible then Functions:FadeOutOnDist(Weapon, Dist) end
                    end
                    if not ESP.TeamCheck or plr == lplayer or ((lplayer.Team ~= plr.Team and plr.Team) or (not lplayer.Team and not plr.Team)) then
                        local chamsMaxDist = ESP.Drawing.Chams.MaxDistance or ESP.MaxDistance
                        if ESP.Drawing.Chams.Enabled and Dist <= chamsMaxDist then
                            Chams.Adornee = plr.Character
                            Chams.Enabled = true
                            Chams.FillColor = ESP.Drawing.Chams.FillRGB
                            Chams.OutlineColor = ESP.Drawing.Chams.OutlineRGB
                            Chams.FillTransparency = ESP.Drawing.Chams.Fill_Transparency / 100
                            Chams.OutlineTransparency = ESP.Drawing.Chams.Outline_Transparency / 100
                            if ESP.Drawing.Chams.XRay then
                                Chams.DepthMode = "AlwaysOnTop"
                            else
                                Chams.DepthMode = ESP.Drawing.Chams.VisibleCheck and "Occluded" or "AlwaysOnTop"
                            end
                        else
                            Chams.Enabled = false
                        end
                        Box.Position = UDim2.new(0, centerX - w / 2, 0, yTop)
                        Box.Size = UDim2.new(0, w, 0, hAdj)
                        local boxOn = ESP.Drawing.Boxes.Full.Enabled and true or false
                        Box.Visible = boxOn
                        local imgCfg = ESP.Drawing.Boxes.Image
                        if BoxImage then
                            local x = centerX - w / 2
                            local y = yTop
                            if _boxImageLastX ~= x or _boxImageLastY ~= y or _boxImageLastW ~= w or _boxImageLastH ~= hAdj then
                                _boxImageLastX, _boxImageLastY, _boxImageLastW, _boxImageLastH = x, y, w, hAdj
                                BoxImage.Position = UDim2.new(0, x, 0, y)
                                BoxImage.Size = UDim2.new(0, w, 0, hAdj)
                            end
                            local show = (boxOn and imgCfg and imgCfg.Enabled and imgCfg.Image and imgCfg.Image ~= "") and true or false
                            if show then
                                if not _boxImageLastVisible then
                                    _boxImageLastVisible = true
                                    BoxImage.Visible = true
                                end
                                local raw = tostring(imgCfg.Image)
                                if raw ~= _boxImageLastRaw then
                                    _boxImageLastRaw = raw
                                    local src = (ESP._ui and ESP._ui._getBoxImageLabelSource and ESP._ui._getBoxImageLabelSource(raw)) or raw
                                    _boxImageLastSource = src
                                    BoxImage.Image = src
                                end
                                local tr = math.clamp(imgCfg.Transparency or 0.35, 0, 1)
                                if tr ~= _boxImageLastTransp then
                                    _boxImageLastTransp = tr
                                    BoxImage.ImageTransparency = tr
                                end
                                local col = imgCfg.Color or Color3.fromRGB(255, 255, 255)
                                if col ~= _boxImageLastColor then
                                    _boxImageLastColor = col
                                    BoxImage.ImageColor3 = col
                                end
                                local st = imgCfg.ScaleType or Enum.ScaleType.Stretch
                                if st ~= _boxImageLastScale then
                                    _boxImageLastScale = st
                                    BoxImage.ScaleType = st
                                end
                            else
                                if _boxImageLastVisible then
                                    _boxImageLastVisible = false
                                    BoxImage.Visible = false
                                end
                            end
                        end
                        Outline.Enabled = (not useCorner) and true or false
                        Gradient2.Enabled = (not useCorner) and (ESP.Drawing.Boxes.Gradient and true or false)
                        if not useCorner then
                            if ESP.Drawing.Boxes.Gradient then
                                Outline.Color = Color3.fromRGB(255, 255, 255)
                            else
                                Outline.Color = ESP.Drawing.Boxes.Full.RGB or Color3.fromRGB(255, 255, 255)
                            end
                        end
                        for _, line in pairs(cornerLines) do
                            line.Visible = boxOn and useCorner
                        end
                        if useCorner and boxOn then
                            local thickness = 2
                            local cornerLen = math.floor(math.clamp(math.min(w, hAdj) * 0.25, 6, 18))
                            cornerLines.CornerTopLeftH.Position = UDim2.new(0, 0, 0, 0)
                            cornerLines.CornerTopLeftH.Size = UDim2.new(0, cornerLen, 0, thickness)
                            cornerLines.CornerTopLeftV.Position = UDim2.new(0, 0, 0, 0)
                            cornerLines.CornerTopLeftV.Size = UDim2.new(0, thickness, 0, cornerLen)
                            cornerLines.CornerTopRightH.Position = UDim2.new(1, -cornerLen, 0, 0)
                            cornerLines.CornerTopRightH.Size = UDim2.new(0, cornerLen, 0, thickness)
                            cornerLines.CornerTopRightV.Position = UDim2.new(1, -thickness, 0, 0)
                            cornerLines.CornerTopRightV.Size = UDim2.new(0, thickness, 0, cornerLen)
                            cornerLines.CornerBottomLeftH.Position = UDim2.new(0, 0, 1, -thickness)
                            cornerLines.CornerBottomLeftH.Size = UDim2.new(0, cornerLen, 0, thickness)
                            cornerLines.CornerBottomLeftV.Position = UDim2.new(0, 0, 1, -cornerLen)
                            cornerLines.CornerBottomLeftV.Size = UDim2.new(0, thickness, 0, cornerLen)
                            cornerLines.CornerBottomRightH.Position = UDim2.new(1, -cornerLen, 1, -thickness)
                            cornerLines.CornerBottomRightH.Size = UDim2.new(0, cornerLen, 0, thickness)
                            cornerLines.CornerBottomRightV.Position = UDim2.new(1, -thickness, 1, -cornerLen)
                            cornerLines.CornerBottomRightV.Size = UDim2.new(0, thickness, 0, cornerLen)
                            local useGrad = ESP.Drawing.Boxes.Gradient and true or false
                            local rot = ESP.Drawing.Boxes.Animate and RotationAngle or -45
                            local c1 = ESP.Drawing.Boxes.GradientRGB1
                            local c2 = ESP.Drawing.Boxes.GradientRGB2
                            local solid = ESP.Drawing.Boxes.Full.RGB or Color3.fromRGB(255, 255, 255)
                            ApplyUnifiedCornerGradient(cornerLines, cornerGradients, w, hAdj, thickness, cornerLen, rot, useGrad, c1, c2, solid)
                        end
                        Gradient1.Enabled = (ESP.Drawing.Boxes.Filled.Enabled and ESP.Drawing.Boxes.GradientFill) and true or false
                        Gradient1.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientFillRGB1),
                            ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientFillRGB2)
                        }
                        Gradient2.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, ESP.Drawing.Boxes.GradientRGB1),
                            ColorSequenceKeypoint.new(1, ESP.Drawing.Boxes.GradientRGB2)
                        }
                        if ESP.Drawing.Boxes.Filled.Enabled then
                            if ESP.Drawing.Boxes.GradientFill then
                                Box.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                                Box.BackgroundTransparency = ESP.Drawing.Boxes.Filled.Transparency
                            else
                                Box.BackgroundColor3 = ESP.Drawing.Boxes.Filled.RGB or Color3.fromRGB(0, 0, 0)
                                Box.BackgroundTransparency = ESP.Drawing.Boxes.Filled.Transparency
                            end
                            Box.BorderSizePixel = 1
                        else
                            Box.BackgroundTransparency = 1
                        end
                        RotationAngle = RotationAngle + (tick() - Tick) * ESP.Drawing.Boxes.RotationSpeed * math.cos(math.pi / 4 * tick() - math.pi / 2)
                        if ESP.Drawing.Boxes.Animate then
                            Gradient1.Rotation = RotationAngle
                            Gradient2.Rotation = RotationAngle
                        else
                            Gradient1.Rotation = -45
                            Gradient2.Rotation = -45
                        end
                        Tick = tick()
                        local health = Humanoid.Health / Humanoid.MaxHealth
                        Healthbar.Visible = ESP.Drawing.Healthbar.Enabled
                        Healthbar.Position = UDim2.new(0, centerX - w / 2 - 6, 0, yTop + hAdj * (1 - health))
                        Healthbar.Size = UDim2.new(0, ESP.Drawing.Healthbar.Width, 0, hAdj * health)
                        BehindHealthbar.Visible = ESP.Drawing.Healthbar.Enabled
                        BehindHealthbar.Position = UDim2.new(0, centerX - w / 2 - 6, 0, yTop)
                        BehindHealthbar.Size = UDim2.new(0, ESP.Drawing.Healthbar.Width, 0, hAdj)
                        HealthbarGradient.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, ESP.Drawing.Healthbar.GradientRGB1),
                            ColorSequenceKeypoint.new(1, ESP.Drawing.Healthbar.GradientRGB2)
                        }
                        if ESP.Drawing.Healthbar.HealthText then
                            local healthPercentage = math.floor(Humanoid.Health / Humanoid.MaxHealth * 100)
                            HealthText.Position = UDim2.new(0, centerX - w / 2 - 6, 0, yTop + hAdj * (1 - healthPercentage / 100) + 3)
                            HealthText.Text = tostring(healthPercentage)
                            HealthText.Visible = Humanoid.Health < Humanoid.MaxHealth
                            if ESP.Drawing.Healthbar.Lerp then
                                local color = health >= 0.75 and Color3.fromRGB(0, 255, 0) or health >= 0.5 and Color3.fromRGB(255, 255, 0) or health >= 0.25 and Color3.fromRGB(255, 170, 0) or Color3.fromRGB(255, 0, 0)
                                HealthText.TextColor3 = color
                            else
                                HealthText.TextColor3 = ESP.Drawing.Healthbar.HealthTextRGB
                            end
                        end
                        Name.Visible = ESP.Drawing.Names.Enabled
                        Name.TextColor3 = ESP.Drawing.Names.RGB
                        local visPrefix = ""
                        local isVisible = false
                        local needVisCheck = ESP.Drawing.Names.Enabled and (ESP.Options and ESP.Options.VisibleCheck)
                        if needVisCheck then
                             local now = tick()
                             if now >= _visNextAt then
                                 _visCached = _isVisible()
                                 _visNextAt = now + 0.12 + (math.random() * 0.08)
                             end
                             isVisible = _visCached
                             if isVisible then
                                 visPrefix = string.format('(<font color="rgb(%d, %d, %d)">V</font>) ', 0, 170, 0)
                             else
                                 visPrefix = string.format('(<font color="rgb(%d, %d, %d)">NV</font>) ', 170, 0, 0)
                             end
                        end
                        if ESP.Options.Friendcheck and lplayer:IsFriendsWith(plr.UserId) then
                            Name.Text = string.format('%s(<font color="rgb(%d, %d, %d)">F</font>) %s',
                                visPrefix,
                                ESP.Options.FriendcheckRGB.R * 255,
                                ESP.Options.FriendcheckRGB.G * 255,
                                ESP.Options.FriendcheckRGB.B * 255,
                                plr.Name)
                        else
                            Name.Text = string.format('%s%s', visPrefix, plr.Name)
                            Name.Visible = true
                        end
                        local topStackOffset = hHalfAdj + 9
                        local bottomStackOffset = hHalfAdj + 7
                        Name.Visible = ESP.Drawing.Names.Enabled
                        Name.TextColor3 = ESP.Drawing.Names.RGB
                        if Name.Visible then
                             Name.Position = UDim2.new(0, centerX, 0, ApplyResolutionStretchY(centerY - topStackOffset, Cam))
                             topStackOffset = topStackOffset + 14
                        end
                        if ESP.ShowInventoryValue then
                             if tick() - lastInvUpdate > 1 then
                                 lastInvUpdate = tick()
                                 task.spawn(function()
                                     cachedInvValue = InventoryViewer.getPlayerTotalInventoryValue(plr)
                                 end)
                             end
                             InventoryValue.Text = tostring(cachedInvValue) .. " " .. INV_CURRENCY
                             InventoryValue.Visible = true
                             InventoryValue.TextColor3 = ESP.Drawing.InventoryValue.RGB
                             InventoryValue.Position = UDim2.new(0, centerX, 0, ApplyResolutionStretchY(centerY - topStackOffset, Cam))
                             topStackOffset = topStackOffset + 14
                        else
                             InventoryValue.Visible = false
                        end
                        if ESP.Drawing.Distances.Enabled then
                            Distance.TextColor3 = ESP.Drawing.Distances.RGB
                            if ESP.Drawing.Distances.Position == "Bottom" then
                                Distance.Position = UDim2.new(0, centerX, 0, ApplyResolutionStretchY(centerY + bottomStackOffset, Cam))
                                Distance.Text = string.format("%dm", math.floor(Dist))
                                Distance.Visible = true
                                bottomStackOffset = bottomStackOffset + 14
                            elseif ESP.Drawing.Distances.Position == "Text" then
                                Distance.Visible = false
                                if Name.Visible then
                                    if ESP.Options.Friendcheck and lplayer:IsFriendsWith(plr.UserId) then
                                        Name.Text = string.format('%s(<font color="rgb(%d, %d, %d)">F</font>) %s [%dm]',
                                            visPrefix,
                                            ESP.Options.FriendcheckRGB.R * 255,
                                            ESP.Options.FriendcheckRGB.G * 255,
                                            ESP.Options.FriendcheckRGB.B * 255,
                                            plr.Name,
                                            math.floor(Dist))
                                    else
                                        Name.Text = string.format('%s%s [%dm]', visPrefix, plr.Name, math.floor(Dist))
                                    end
                                end
                            end
                        else
                             Distance.Visible = false
                        end
                        if ESP.Drawing.Weapons.Enabled then
                            local weaponName = get_gun(plr)
                            if weaponName and weaponName ~= "None" then
                                Weapon.Text = weaponName
                                Weapon.TextColor3 = ESP.Drawing.Weapons.WeaponTextRGB
                                Weapon.Visible = true
                                Weapon.Position = UDim2.new(0, centerX, 0, ApplyResolutionStretchY(centerY + bottomStackOffset, Cam))
                                bottomStackOffset = bottomStackOffset + 14
                            else
                                Weapon.Visible = false
                            end
                        else
                            Weapon.Visible = false
                        end
                    else
                        HideESP()
                    end
                else
                    HideESP()
                end
            else
                HideESP()
            end
        end)
        plr.AncestryChanged:Connect(function()
            if not plr:IsDescendantOf(game) then
                Connection:Disconnect()
                ESPContainer:Destroy()
            end
        end)
    end
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            task.spawn(ESP_Draw, player)
        end
    end
    _G.allvars._rt.track(Players.PlayerAdded:Connect(function(player)
        if player ~= Players.LocalPlayer then
            task.spawn(ESP_Draw, player)
        end
    end))
end
_G.allvars._rt.track(RunService.RenderStepped:Connect(function()
    if ESP.Enabled and not ESP.Initialized then
        pcall(function()
            local oldGui = CoreGui:FindFirstChild("ESPHolder")
            if oldGui then
                oldGui:Destroy()
            end
        end)
        ESP.Initialized = true
        InitializeESP()
    end
    if ESP.Enabled and ESP.Initialized then
        local espHolder = CoreGui:FindFirstChild("ESPHolder")
        if not espHolder or #espHolder:GetChildren() == 0 then
            ESP.Initialized = false
        end
    end
end))
_G.allvars._rt.track(UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.End then
        ESP.Enabled = not ESP.Enabled
        if ESP.Enabled then
            ForceESPRefresh()
        end
        pcall(function()
            local espToggle = ESP and ESP._ui and ESP._ui.enableESPToggleEl
            if espToggle then
                if espToggle.set_value then
                    local ok = pcall(function()
                        espToggle:set_value(ESP.Enabled)
                    end)
                    if not ok then
                        pcall(function()
                            espToggle:set_value({ Toggle = ESP.Enabled })
                        end)
                    end
                end
            end
        end)
    end
end))
local cfgSection = tabs.Settings:InsertConfigSection("Left")
pcall(function()
    cfgSection:Header({ Text = "Config Presets" })
end)
local settingsOther = tabs.Settings:Section({ Side = "Right", Name = "Other" })
settingsOther:Header({ Text = "Other" })
local function UnloadScript()
    if _G.allvars._rt.unloaded then
        return
    end
    _G.allvars._rt.unloaded = true
    pcall(function()
        aimbool = false
        aimbots = false
        snaplinebool = false
        aimtrigger = false
        aimtarget = nil
        aimtargetpart = nil
        if SilentAim then
            SilentAim.Enabled = false
            SilentAim.IsAiming = false
            SilentAim.Holding = false
            if SilentAim.LockedPlayerGUI then
                SilentAim.LockedPlayerGUI.Enabled = false
            end
            if SilentAim.UsernameLabel then
                SilentAim.UsernameLabel.Visible = false
            end
            if SilentAim.FOVCircle and SilentAim.FOVCircle.Remove then
                SilentAim.FOVCircle:Remove()
            end
            SilentAim.FOVCircle = nil
            if SilentAim.Tracker2D and SilentAim.Tracker2D.Remove then
                SilentAim.Tracker2D:Remove()
            end
            SilentAim.Tracker2D = nil
        end
        if clearAllBulletTracers then
            clearAllBulletTracers()
        end
    end)
    pcall(function()
        if allvars and allvars._autoFire then
            allvars._autoFire.enabled = false
        end
        if allvars then
            allvars.instaequip = false
        end
    end)
    pcall(function()
        JesusEnabled = false
        nofall = false
        instafall = false
        if waterplatforms and waterplatforms.ClearAllChildren then
            waterplatforms:ClearAllChildren()
        end
    end)
    pcall(function()
        if ESP then
            ESP.Enabled = false
            ESP.Initialized = false
            ESP.ShowAIBots = false
        end
    end)
    pcall(function()
        StopBeastChams()
    end)
    pcall(function()
        if CombatLogConnection then
            _G.allvars._rt.disconnect(CombatLogConnection)
            CombatLogConnection = nil
        end
        if CombatLogLabel and CombatLogLabel.Destroy then
            CombatLogLabel:Destroy()
            CombatLogLabel = nil
        end
    end)
    pcall(function()
        if CFrameSpeed then
            _G.allvars._rt.disconnect(CFrameSpeed.Connection)
            _G.allvars._rt.disconnect(CFrameSpeed.WalkSpeedConnection)
            CFrameSpeed.Connection = nil
            CFrameSpeed.WalkSpeedConnection = nil
            CFrameSpeed.FastWalkEnabled = false
            CFrameSpeed.DirectWalkSpeedEnabled = false
        end
    end)
    pcall(function()
        if type(desyncStop) == "function" then
            desyncStop()
        elseif type(_G.MainDesync_Stop) == "function" then
            _G.MainDesync_Stop()
        elseif DesyncModule then
            DesyncModule.Enabled = false
            if DesyncModule._heartbeatConnection then
                _G.allvars._rt.disconnect(DesyncModule._heartbeatConnection)
                DesyncModule._heartbeatConnection = nil
            end
            if DesyncModule._characterAddedConnection then
                _G.allvars._rt.disconnect(DesyncModule._characterAddedConnection)
                DesyncModule._characterAddedConnection = nil
            end
            if DesyncModule._ghostConnections then
                for _, c in ipairs(DesyncModule._ghostConnections) do
                    _G.allvars._rt.disconnect(c)
                end
                DesyncModule._ghostConnections = {}
            end
            if DesyncModule._ghostModel and DesyncModule._ghostModel.Destroy then
                DesyncModule._ghostModel:Destroy()
                DesyncModule._ghostModel = nil
            end
            DesyncModule._ghostMap = {}
            DesyncModule._savedRealCFrame = nil
            DesyncModule._savedRealVelocity = nil
        end
    end)
    pcall(function()
        if cameraProtectionConnection then
            _G.allvars._rt.disconnect(cameraProtectionConnection)
            cameraProtectionConnection = nil
        end
        if ArmsVisual then
            ArmsVisual.Enabled = false
        end
        if CleanupArmsVisualConnections then
            CleanupArmsVisualConnections()
        end
    end)
    pcall(function()
        if ESP and ESP.Connections then
            for _, conn in pairs(ESP.Connections) do
                _G.allvars._rt.disconnect(conn)
            end
            for k in pairs(ESP.Connections) do
                ESP.Connections[k] = nil
            end
        end
    end)
    pcall(function()
        if ZoomSettings then
            _G.allvars._rt.disconnect(ZoomSettings.InputConnection)
            _G.allvars._rt.disconnect(ZoomSettings.EndConnection)
            ZoomSettings.InputConnection = nil
            ZoomSettings.EndConnection = nil
            ZoomSettings.IsZooming = false
        end
    end)
    pcall(function()
        if FOVChangerSettings then
            FOVChangerSettings.Enabled = false
            if FOVChangerSettings.CurrentTween then
                pcall(function() FOVChangerSettings.CurrentTween:Cancel() end)
            end
            _G.allvars._rt.disconnect(FOVChangerSettings.UpdateConnection)
            _G.allvars._rt.disconnect(FOVChangerSettings.CameraConnection)
            _G.allvars._rt.disconnect(FOVChangerSettings.EnforceConnection)
            FOVChangerSettings.UpdateConnection = nil
            FOVChangerSettings.CameraConnection = nil
            FOVChangerSettings.EnforceConnection = nil
            if workspace.CurrentCamera then
                workspace.CurrentCamera.FieldOfView = FOVChangerSettings.DefaultFOV or 70
            end
        end
    end)
    pcall(function()
        if _G.FogRemovalConnection then
            _G.allvars._rt.disconnect(_G.FogRemovalConnection)
            _G.FogRemovalConnection = nil
        end
        if _G.CloudsUpdateConnection then
            _G.allvars._rt.disconnect(_G.CloudsUpdateConnection)
            _G.CloudsUpdateConnection = nil
        end
        if _G.TimeChangerConnection then
            _G.allvars._rt.disconnect(_G.TimeChangerConnection)
            _G.TimeChangerConnection = nil
        end
        if _G.ServerTimeUpdateConnection then
            _G.allvars._rt.disconnect(_G.ServerTimeUpdateConnection)
            _G.ServerTimeUpdateConnection = nil
        end
        if _G.ExtractUpdateConnection then
            _G.allvars._rt.disconnect(_G.ExtractUpdateConnection)
            _G.ExtractUpdateConnection = nil
        end
    end)
    pcall(function()
        if _G.OriginalLightingSettings then
            local Lighting = game:GetService("Lighting")
            Lighting.Brightness = _G.OriginalLightingSettings.Brightness
            Lighting.Ambient = _G.OriginalLightingSettings.Ambient
            Lighting.OutdoorAmbient = _G.OriginalLightingSettings.OutdoorAmbient
            Lighting.GlobalShadows = _G.OriginalLightingSettings.GlobalShadows
            Lighting.ClockTime = _G.OriginalLightingSettings.ClockTime
            _G.OriginalLightingSettings = nil
        end
    end)
    pcall(function()
        if _G.WorldColorSettings then
            local Lighting = game:GetService("Lighting")
            if _G.WorldColorSettings.connection then
                _G.allvars._rt.disconnect(_G.WorldColorSettings.connection)
                _G.WorldColorSettings.connection = nil
            end
            if _G.WorldColorSettings.originalAmbient then
                Lighting.Ambient = _G.WorldColorSettings.originalAmbient
            end
            if _G.WorldColorSettings.originalOutdoorAmbient then
                Lighting.OutdoorAmbient = _G.WorldColorSettings.originalOutdoorAmbient
            end
            _G.WorldColorSettings.enabled = false
        end
    end)
    pcall(function()
        if aimfovcircle and aimfovcircle.Remove then aimfovcircle:Remove() end
        if aimsnapline and aimsnapline.Remove then aimsnapline:Remove() end
        if aimtargetname and aimtargetname.Remove then aimtargetname:Remove() end
        if aimtargetshots and aimtargetshots.Remove then aimtargetshots:Remove() end
    end)
    pcall(function()
        if LinePool and LinePool.Lines then
            for i = #LinePool.Lines, 1, -1 do
                local lineData = LinePool.Lines[i]
                if lineData and lineData.Object and lineData.Object.Remove then
                    pcall(function() lineData.Object:Remove() end)
                end
                LinePool.Lines[i] = nil
            end
            LinePool.ActiveLines = {}
        end
    end)
    pcall(function()
        if invistrack then
            invistrack:Stop()
            invistrack:Destroy()
            invistrack = nil
        end
        invisbool = false
        invisnum = 0
    end)
    pcall(function()
        if _G.allvars and _G.allvars._rt and _G.allvars._rt.clearThirdPersonShiftLock then
            _G.allvars._rt.clearThirdPersonShiftLock()
        end
        if localplayer and localplayer.Character and localplayer.Character:FindFirstChild("Humanoid") then
            localplayer.Character.Humanoid.CameraOffset = Vector3.new(0, 0, 0)
        end
        camthirdp = false
        thirdpshow = false
        pcall(function()
            _G.allvars.camthirdp = false
            _G.thirdpshow = false
        end)
        local original = _G.allvars and _G.allvars._rt and _G.allvars._rt.originalCamera
        if original and localplayer then
            if original.CameraMode ~= nil then
                localplayer.CameraMode = original.CameraMode
            end
            if original.CameraMaxZoomDistance ~= nil then
                localplayer.CameraMaxZoomDistance = original.CameraMaxZoomDistance
            end
            if original.CameraMinZoomDistance ~= nil then
                localplayer.CameraMinZoomDistance = original.CameraMinZoomDistance
            end
        end
    end)
    _G.allvars._rt.disconnectAll()
    pcall(function()
        local cg = game:GetService("CoreGui")
        local h = cg:FindFirstChild("ESPHolder")
        if h then h:Destroy() end
        local wh = cg:FindFirstChild("LootESPHolder")
        if wh then wh:Destroy() end
        local wm = cg:FindFirstChild("OblivionWatermark")
        if wm then wm:Destroy() end
        if _G.CustomWatermark and _G.CustomWatermark.Destroy then
            _G.CustomWatermark:Destroy()
        end
        _G.CustomWatermark = nil
    end)
    pcall(function()
        if Window and typeof(Window.unload) == "function" then
            local ok = pcall(function()
                Window:unload()
            end)
            if not ok then
                pcall(function()
                    Window.unload(Window)
                end)
            end
        end
    end)
    pcall(function()
        local function containsTitle(gui)
            for _, d in ipairs(gui:GetDescendants()) do
                if d:IsA("TextLabel") or d:IsA("TextButton") then
                    local t = d.Text
                    if t == WINDOW_TITLE or t == WINDOW_SUBTITLE then
                        return true
                    end
                    if type(t) == "string" and t:find("Oblivion", 1, true) then
                        return true
                    end
                end
            end
            return false
        end
        local function destroyMatchingGuis(parent)
            for _, ch in ipairs(parent:GetChildren()) do
                if ch:IsA("ScreenGui") and (ch:GetAttribute("OblivionOwned") == true or containsTitle(ch)) then
                    pcall(function() ch:Destroy() end)
                end
            end
        end
        local cg = game:GetService("CoreGui")
        destroyMatchingGuis(cg)
        local lp = game:GetService("Players").LocalPlayer
        if lp and lp:FindFirstChildOfClass("PlayerGui") then
            destroyMatchingGuis(lp:FindFirstChildOfClass("PlayerGui"))
        end
        pcall(function()
            if gethui then
                destroyMatchingGuis(gethui())
            end
        end)
        pcall(function()
            local sg = _G.allvars and _G.allvars._rt and _G.allvars._rt.windowScreenGui
            if sg and sg.Destroy then
                sg:Destroy()
            end
        end)
        if Window and Window.Frame then
            pcall(function() Window.Frame.Visible = false end)
            local sg = Window.Frame:FindFirstAncestorWhichIsA("ScreenGui")
            if sg and sg.Destroy then
                sg:Destroy()
            elseif Window.Frame.Destroy then
                Window.Frame:Destroy()
            end
        end
    end)
    pcall(function()
        if _G.allvars then
            _G.allvars.toggleForceUnderground = nil
            _G.allvars.toggleDesync = nil
            _G.allvars.UnloadScript = nil
        end
    end)
end
_G.allvars.UnloadScript = UnloadScript
settingsOther:Button({
    Name = "Rejoin",
    Callback = function()
        local Players = game:GetService("Players")
        local TeleportService = game:GetService("TeleportService")
        local lp = Players.LocalPlayer
        if not lp then
            return
        end
        pcall(function()
            if game.JobId and game.JobId ~= "" then
                TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, lp)
            else
                TeleportService:Teleport(game.PlaceId, lp)
            end
        end)
    end
})
settingsOther:Button({
    Name = "Unload Script",
    Callback = function()
        UnloadScript()
    end
})
tabs.Aimbot:Select()
MacLib:LoadAutoLoadConfig()
pcall(function()
    if ESP and ESP._ui and ESP._ui._syncESPVisibility then
        ESP._ui._syncESPVisibility()
    end
end)
pcall(function()
    local combatUI = _G.__RAIL_UI and _G.__RAIL_UI.combat
    if combatUI and combatUI.sync then
        combatUI.sync()
    end
end)
pcall(function()
    if LootESP and LootESP._ui and LootESP._ui._syncLootVisibility then
        LootESP._ui._syncLootVisibility()
    end
end)
pcall(function()
    local gunmodUI = _G.__RAIL_UI and _G.__RAIL_UI.gunmod
    if gunmodUI and gunmodUI.sync then
        gunmodUI.sync()
    end
end)
local function CreateCustomWatermark()
    if _G.CustomWatermark then return end
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    local screenGui = CreateInstance("ScreenGui", {
        Name = "OblivionWatermark",
        ResetOnSpawn = false,
        IgnoreGuiInset = true,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    })
    if syn and syn.protect_gui then
        syn.protect_gui(screenGui)
        screenGui.Parent = game:GetService("CoreGui")
    else
        screenGui.Parent = playerGui
    end
    local mainFrame = CreateInstance("Frame", {
        Name = "WatermarkFrame",
        Position = UDim2.new(0, 15, 0, 60),
        BackgroundColor3 = Color3.fromRGB(20, 20, 20),
        BorderSizePixel = 0,
        AutomaticSize = Enum.AutomaticSize.X,
        Size = UDim2.new(0, 0, 0, 30),
        Parent = screenGui
    })
    CreateInstance("UICorner", { CornerRadius = UDim.new(0, 5), Parent = mainFrame })
    CreateInstance("UIPadding", {
        PaddingLeft = UDim.new(0, 10),
        PaddingRight = UDim.new(0, 10),
        PaddingTop = UDim.new(0, 5),
        PaddingBottom = UDim.new(0, 5),
        Parent = mainFrame
    })
    CreateInstance("UIStroke", { Thickness = 1, Color = Color3.fromRGB(60, 60, 60), Parent = mainFrame })
    local accentBar = CreateInstance("Frame", {
        Name = "AccentBar",
        Position = UDim2.new(0, 0, 0, 0),
        Size = UDim2.new(1, 0, 0, 1),
        BorderSizePixel = 0,
        BackgroundColor3 = Color3.fromRGB(113, 93, 255),
        Parent = mainFrame
    })
    local accentGradient = CreateInstance("UIGradient", {
        Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 102, 102)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(113, 93, 255)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(32, 214, 160))
        },
        Parent = accentBar
    })
    local textLabel = CreateInstance("TextLabel", {
        Parent = mainFrame,
        Size = UDim2.new(0, 0, 1, 0),
        BackgroundTransparency = 1,
        TextColor3 = Color3.new(1, 1, 1),
        Font = Enum.Font.Gotham,
        TextSize = 13,
        TextXAlignment = Enum.TextXAlignment.Left,
        AutomaticSize = Enum.AutomaticSize.X
    })
    local fps = 60
    local gradientOffset = 0
    local fpsSampleStartedAt = tick()
    local fpsFrameCount = 0
    _G.allvars._rt.track(RunService.RenderStepped:Connect(function(delta)
        local now = tick()
        fpsFrameCount = fpsFrameCount + 1
        gradientOffset = (gradientOffset + delta * 0.1) % 1
        accentGradient.Offset = Vector2.new(gradientOffset, 0)
        local elapsed = now - fpsSampleStartedAt
        if elapsed >= 0.25 then
            fps = math.clamp(math.floor((fpsFrameCount / math.max(elapsed, 1e-6)) + 0.5), 1, 1000)
            fpsFrameCount = 0
            fpsSampleStartedAt = now
        end
    end))
    local function getPingMs()
        local ok, v = pcall(function()
            return player:GetNetworkPing()
        end)
        if not ok or type(v) ~= "number" then
            return 0
        end
        return math.floor((v * 1000) + 0.5)
    end
    local function updateText()
        local timeStr = os.date("%H:%M:%S")
        local dateStr = os.date("%d/%m/%Y")
        local ping = getPingMs()
        textLabel.Text = string.format("Oblivion | %s | %s | %d ms | %d FPS", timeStr, dateStr, ping, fps)
    end
    local updateConnection
    local nextUpdateAt = 0
    updateConnection = _G.allvars._rt.track(RunService.Heartbeat:Connect(function()
        if screenGui.Enabled then
            local now = tick()
            if now >= nextUpdateAt then
                nextUpdateAt = now + 0.25
                updateText()
            end
            local success, stats = pcall(function() return game:GetService("CoreGui").RobloxGui.PerformanceStats end)
            if success and stats and stats.Visible then
                mainFrame.Position = UDim2.new(0, 15, 0, 110)
            else
                mainFrame.Position = UDim2.new(0, 15, 0, 60)
            end
        end
    end))
    _G.CustomWatermark = screenGui
    screenGui.Enabled = true
    return screenGui
end
task.spawn(CreateCustomWatermark)
local function safeESPOptions()
    ESP.Options = EnsureDefaults(ESP.Options, {
        Teamcheck = false,
        TeamcheckRGB = Color3.fromRGB(0, 255, 0),
        Friendcheck = false,
        FriendcheckRGB = Color3.fromRGB(0, 255, 0),
        Highlight = false,
        HighlightRGB = Color3.fromRGB(255, 0, 0),
        VisibleCheck = true
    })
end
safeESPOptions()
local function UpdateESPSettings()
    if ESP.Enabled then
        for _, player in pairs(game:GetService("Players"):GetPlayers()) do
            if player ~= game:GetService("Players").LocalPlayer then
                local espHolder = game:GetService("CoreGui"):FindFirstChild("ESPHolder")
                if espHolder and espHolder:FindFirstChild(player.Name) then
                    local playerESP = espHolder:FindFirstChild(player.Name)
                    local nameLabel = playerESP:FindFirstChildOfClass("TextLabel")
                    if nameLabel then
                        nameLabel.Visible = ESP.Drawing.Names.Enabled
                    end
                    local distanceLabels = {}
                    for _, child in pairs(playerESP:GetChildren()) do
                        if child:IsA("TextLabel") and child ~= nameLabel then
                            table.insert(distanceLabels, child)
                        end
                    end
                    for _, label in pairs(distanceLabels) do
                        label.Visible = ESP.Drawing.Distances.Enabled
                    end
                end
            end
        end
    end
end
local originalUpdateESP = UpdateESPSettings
UpdateESPSettings = function()
    if originalUpdateESP then
        originalUpdateESP()
    end
    pcall(function()
        local espHolder = game:GetService("CoreGui"):FindFirstChild("ESPHolder")
        if espHolder and ESP.Enabled then
            for _, playerESP in pairs(espHolder:GetChildren()) do
                if not playerESP:IsA("Frame") then continue end
                for _, child in pairs(playerESP:GetChildren()) do
                    if child:IsA("TextLabel") then
                        if (child.Text:find("%%dm") or child.Text:find("%d+m") or child.Text:find("meters") or child.Position.Y.Offset > 0) and
                           ESP.Drawing.Distances.RGB then
                            child.TextColor3 = ESP.Drawing.Distances.RGB
                        end
                        if not child.Text:find("rgb") and
                           (child.Position.Y.Offset < 0 or child.Text:find("E") or child.Text:find("F")) and
                           ESP.Drawing.Names.RGB then
                            child.TextColor3 = ESP.Drawing.Names.RGB
                        end
                    end
                end
            end
    end
end)
end
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
end)
local ScreenSection = sections.PlayerZoom
ScreenSection:Header({
    Text = "Screen Settings"
})
local function createZoom(time, amount, isZoomIn)
    if not Workspace.CurrentCamera then return end
    if ZoomSettings.CurrentTween then
        pcall(function()
            ZoomSettings.CurrentTween:Cancel()
        end)
        ZoomSettings.CurrentTween = nil
    end
    local Tween_Info = TweenInfo.new(time, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
    local Tween = game:GetService("TweenService"):Create(Workspace.CurrentCamera, Tween_Info, {FieldOfView = amount})
    Tween.Completed:Connect(function()
        ZoomSettings.CurrentTween = nil
        if not isZoomIn then
            ZoomSettings.IsZooming = false
            task.wait(0.02)
            if not ZoomSettings.IsZooming and Workspace.CurrentCamera then
                if ZoomSettings.IsFOVChangerActive and FOVChangerSettings and FOVChangerSettings.Enabled then
                    Workspace.CurrentCamera.FieldOfView = FOVChangerSettings.CustomFOV
                else
                    Workspace.CurrentCamera.FieldOfView = ZoomSettings.OldZoom or 70
                end
            end
        end
    end)
    ZoomSettings.CurrentTween = Tween
    return Tween
end
local function resetZoom()
    if not ZoomSettings.IsKeyDown and ZoomSettings.IsZooming then
        ZoomSettings.IsZooming = false
        if ZoomSettings.CurrentTween then
            pcall(function()
                ZoomSettings.CurrentTween:Cancel()
            end)
            ZoomSettings.CurrentTween = nil
        end
        if Workspace.CurrentCamera then
            if ZoomSettings.IsFOVChangerActive and FOVChangerSettings and FOVChangerSettings.Enabled then
                Workspace.CurrentCamera.FieldOfView = FOVChangerSettings.CustomFOV
            else
                Workspace.CurrentCamera.FieldOfView = ZoomSettings.OldZoom or 70
            end
        end
    end
end
local function setupZoomBindings()
    if ZoomSettings.InputConnection then
        ZoomSettings.InputConnection:Disconnect()
        ZoomSettings.InputConnection = nil
    end
    if ZoomSettings.EndConnection then
        ZoomSettings.EndConnection:Disconnect()
        ZoomSettings.EndConnection = nil
    end
    local wasZooming = ZoomSettings.IsZooming
    ZoomSettings.IsZooming = false
    ZoomSettings.IsKeyDown = false
    if not ZoomSettings.Enabled then
        if wasZooming and Workspace.CurrentCamera then
            if FOVChangerSettings and FOVChangerSettings.Enabled then
                Workspace.CurrentCamera.FieldOfView = FOVChangerSettings.CustomFOV
            else
                Workspace.CurrentCamera.FieldOfView = ZoomSettings.OldZoom or 70
            end
        end
        return
    end
    local currentKey = ZoomSettings.Key
    if MacLib and MacLib.Flags and MacLib.Flags["ZoomKey"] then
        currentKey = MacLib.Flags["ZoomKey"]
        ZoomSettings.Key = currentKey
    end
    ZoomSettings.InputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        local activeKey = ZoomSettings.Key
        if input.KeyCode ~= activeKey then return end
        ZoomSettings.IsKeyDown = true
        ZoomSettings.IsFOVChangerActive = FOVChangerSettings and FOVChangerSettings.Enabled
        if not ZoomSettings.IsZooming and Workspace.CurrentCamera then
            local currentFOV = Workspace.CurrentCamera.FieldOfView
            if math.abs(currentFOV - ZoomSettings.ZoomedAmount) > 1 then
                if ZoomSettings.IsFOVChangerActive then
                    ZoomSettings.OldZoom = FOVChangerSettings.CustomFOV
                else
                    ZoomSettings.OldZoom = currentFOV
                end
            end
        end
        ZoomSettings.IsZooming = true
        local zoomTween = createZoom(ZoomSettings.ZoomTime, ZoomSettings.ZoomedAmount, true)
        if zoomTween then
            zoomTween:Play()
        end
    end)
    ZoomSettings.EndConnection = UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        local activeKey = ZoomSettings.Key
        if input.KeyCode ~= activeKey then return end
        ZoomSettings.IsKeyDown = false
        if not ZoomSettings.IsZooming then return end
        local targetFOV
        if ZoomSettings.IsFOVChangerActive and FOVChangerSettings and FOVChangerSettings.Enabled then
            targetFOV = FOVChangerSettings.CustomFOV
        else
            targetFOV = ZoomSettings.OldZoom or 70
        end
        local unzoomTween = createZoom(ZoomSettings.ZoomTime, targetFOV, false)
        if unzoomTween then
            unzoomTween:Play()
        end
    end)
end
ESP._ui = ESP._ui or {}
ScreenSection:Toggle({
    Name = "Enable Zoom",
    Default = false,
    Flag = "EnableZoom",
    Callback = function(value)
        ZoomSettings.Enabled = value
        setupZoomBindings()
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
})
ESP._ui.playerZoomAmountSliderEl = ScreenSection:Slider({
    Name = "Zoom Amount",
    Default = 10,
    Minimum = 5,
    Maximum = 40,
    Precision = 1,
    Flag = "ZoomAmount",
    Callback = function(value)
        ZoomSettings.ZoomedAmount = value
    end
})
ESP._ui.playerZoomKeybindEl = ScreenSection:Keybind({
    Name = "Zoom Key",
    Default = ZoomSettings.Key,
    Flag = "ZoomKey",
    Callback = function() end,
    KeyChanged = function(key)
        ZoomSettings.Key = key
        if MacLib and MacLib.Flags then
            MacLib.Flags["ZoomKey"] = key
        end
        if ZoomSettings.InputConnection then
            ZoomSettings.InputConnection:Disconnect()
            ZoomSettings.InputConnection = nil
        end
        if ZoomSettings.EndConnection then
            ZoomSettings.EndConnection:Disconnect()
            ZoomSettings.EndConnection = nil
        end
        setupZoomBindings()
    end
})
if ESP and ESP._ui and ESP._ui._syncESPVisibility then
    task.defer(function()
        pcall(function()
            ESP._ui._syncESPVisibility()
        end)
    end)
end
local lastKeyCheck = tick()
local lastZoomCheck = tick()
RunService.Heartbeat:Connect(function()
    if tick() - lastKeyCheck > 1 then
        lastKeyCheck = tick()
        if ZoomSettings.Enabled then
            resetZoom()
        end
    end
    if MacLib and MacLib.Flags and MacLib.Flags["ZoomKey"] and ZoomSettings.Key ~= MacLib.Flags["ZoomKey"] then
        ZoomSettings.Key = MacLib.Flags["ZoomKey"]
        if tick() - (ZoomSettings.LastBindUpdate or 0) > 0.5 then
            ZoomSettings.LastBindUpdate = tick()
            if ZoomSettings.Enabled then
                setupZoomBindings()
            end
        end
    end
    if ZoomSettings.IsZooming and not ZoomSettings.IsKeyDown then
        if tick() - lastZoomCheck > 5 then
            lastZoomCheck = tick()
            resetZoom()
        end
    else
        lastZoomCheck = tick()
    end
end)
FOVChangerSettings = {
    Enabled = false,
    CustomFOV = 70,
    DefaultFOV = workspace.CurrentCamera.FieldOfView,
    UpdateConnection = nil,
    CurrentTween = nil,
    CameraConnection = nil,
    EnforceConnection = nil
}
local function updateFOV(instant)
    if not Workspace.CurrentCamera then return end
    if not FOVChangerSettings.Enabled then
        if workspace.CurrentCamera.FieldOfView ~= FOVChangerSettings.DefaultFOV then
            if instant then
                workspace.CurrentCamera.FieldOfView = FOVChangerSettings.DefaultFOV
            else
                if FOVChangerSettings.CurrentTween then
                    FOVChangerSettings.CurrentTween:Cancel()
                end
                FOVChangerSettings.CurrentTween = game:GetService("TweenService"):Create(
                    workspace.CurrentCamera,
                    TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
                    {FieldOfView = FOVChangerSettings.DefaultFOV}
                )
                FOVChangerSettings.CurrentTween:Play()
            end
        end
    else
        if workspace.CurrentCamera.FieldOfView ~= FOVChangerSettings.CustomFOV then
            if instant then
                workspace.CurrentCamera.FieldOfView = FOVChangerSettings.CustomFOV
            else
                if FOVChangerSettings.CurrentTween then
                    FOVChangerSettings.CurrentTween:Cancel()
                end
                FOVChangerSettings.CurrentTween = game:GetService("TweenService"):Create(
                    workspace.CurrentCamera,
                    TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
                    {FieldOfView = FOVChangerSettings.CustomFOV}
                )
                FOVChangerSettings.CurrentTween:Play()
            end
        end
    end
end
local function updateFOVHook()
    if FOVChangerSettings.UpdateConnection then
        FOVChangerSettings.UpdateConnection:Disconnect()
        FOVChangerSettings.UpdateConnection = nil
    end
    local cam = Workspace.CurrentCamera
    if not cam then return end
    FOVChangerSettings.UpdateConnection = cam:GetPropertyChangedSignal("FieldOfView"):Connect(function()
        if ZoomSettings.IsZooming then return end
        if not FOVChangerSettings.Enabled then return end
        if Workspace.CurrentCamera ~= cam then return end
        local target = FOVChangerSettings.CustomFOV
        if cam.FieldOfView ~= target then
            cam.FieldOfView = target
        end
    end)
end
local function setFOVEnforcementEnabled(enabled)
    if not enabled then
        if FOVChangerSettings.UpdateConnection then
            FOVChangerSettings.UpdateConnection:Disconnect()
            FOVChangerSettings.UpdateConnection = nil
        end
        if FOVChangerSettings.CameraConnection then
            FOVChangerSettings.CameraConnection:Disconnect()
            FOVChangerSettings.CameraConnection = nil
        end
        if FOVChangerSettings.EnforceConnection then
            FOVChangerSettings.EnforceConnection:Disconnect()
            FOVChangerSettings.EnforceConnection = nil
        end
        return
    end
    updateFOVHook()
    if not FOVChangerSettings.CameraConnection then
        FOVChangerSettings.CameraConnection = Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
            updateFOVHook()
            if not ZoomSettings.IsZooming and FOVChangerSettings.Enabled and Workspace.CurrentCamera then
                Workspace.CurrentCamera.FieldOfView = FOVChangerSettings.CustomFOV
            end
        end)
    end
    if not FOVChangerSettings.EnforceConnection then
        FOVChangerSettings.EnforceConnection = RunService.RenderStepped:Connect(function()
            if ZoomSettings.IsZooming then return end
            if not FOVChangerSettings.Enabled then return end
            local cam = Workspace.CurrentCamera
            if not cam then return end
            local target = FOVChangerSettings.CustomFOV
            if cam.FieldOfView ~= target then
                cam.FieldOfView = target
            end
        end)
    end
end
ScreenSection:Toggle({
    Name = "Enable FOV Changer",
    Default = false,
    Callback = function(value)
        FOVChangerSettings.Enabled = value
        ZoomSettings.IsFOVChangerActive = value
        if value then
            setFOVEnforcementEnabled(true)
            if not ZoomSettings.IsZooming then
                updateFOV(true)
            end
        else
            setFOVEnforcementEnabled(false)
            if not ZoomSettings.IsZooming then
                updateFOV()
            end
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
})
ESP._ui.playerCustomFovSliderEl = ScreenSection:Slider({
    Name = "Custom FOV",
    Default = 70,
    Minimum = 30,
    Maximum = 120,
    Precision = 2,
    Callback = function(value)
        FOVChangerSettings.CustomFOV = value
        if FOVChangerSettings.Enabled and not ZoomSettings.IsZooming then
            updateFOV()
        end
    end
})
if ESP and ESP._ui and ESP._ui._syncESPVisibility then
    ESP._ui._syncESPVisibility()
end
ScreenSection:Toggle({
    Name = "No screen effects",
    Default = false,
    Tooltip = 'Disables mask effects',
    Callback = function(v)
        allvars.antimaskbool = v
        local player = game.Players.LocalPlayer
        local playerGui = player and player:FindFirstChild("PlayerGui")
        local mainGui = playerGui and playerGui:FindFirstChild("MainGui")
        local mainFrame = mainGui and mainGui:FindFirstChild("MainFrame")
        local effects = mainFrame and mainFrame:FindFirstChild("ScreenEffects")
        if not effects then
            if _G.EnhancedPredictionSettings and _G.EnhancedPredictionSettings.DebugPrint then
            end
            return
        end
        local helmetMask = effects:FindFirstChild("HelmetMask")
        local visor = effects:FindFirstChild("Visor")
        local mask = effects:FindFirstChild("Mask")
        local titanShield = helmetMask and helmetMask:FindFirstChild("TitanShield")
        local gp5 = mask and mask:FindFirstChild("GP5")
        if v == true then
            if titanShield then titanShield.Size = UDim2.new(0,0,1,0) end
            if gp5 then gp5.Size = UDim2.new(0,0,1,0) end
            if visor then
                for _,child in pairs(visor:GetChildren()) do
                    if child:IsA("GuiObject") then
                        child.Size = UDim2.new(0,0,1,0)
                    end
                end
            end
        else
            if titanShield then titanShield.Size = UDim2.new(1,0,1,0) end
            if gp5 then gp5.Size = UDim2.new(1,0,1,0) end
            if visor then
                for _,child in pairs(visor:GetChildren()) do
                    if child:IsA("GuiObject") then
                        child.Size = UDim2.new(1,0,1,0)
                    end
                end
            end
        end
    end
})
FOVChangerSettings.DefaultFOV = Workspace.CurrentCamera.FieldOfView
if FOVChangerSettings.Enabled then
    setFOVEnforcementEnabled(true)
    if not ZoomSettings.IsZooming then
        updateFOV(true)
    end
end
ArmsVisual = {
    Enabled = false,
    Color = Color3.fromRGB(0, 255, 255),
    OpaqueOuterColor = Color3.fromRGB(0, 0, 0),
    OpaqueInnerColor = Color3.fromRGB(0, 255, 255),
    Transparency = 0.5,
    Material = Enum.Material.ForceField,
    LastMode = nil,
    BeastFolder = nil,
    BeastParts = nil,
    BeastInitializedFor = nil,
    SavedAppearances = {},
    CachedViewModel = nil,
    LastViewModelCheck = nil,
    LastUsedColor = nil,
    LastUsedTransparency = nil,
    LastUsedMaterial = nil,
    LastUpdateTime = nil,
    Highlight = nil,
    LastBeastRegisterModel = nil,
    LastBeastRegisterTime = nil,
    IgnoreList = {
        ["camera"] = true,
        ["Camera"] = true,
        ["CAMERA"] = true,
        ["camerapart"] = true,
        ["CameraPart"] = true,
        ["camerascript"] = true,
        ["CameraScript"] = true,
        ["cameramodule"] = true,
        ["CameraModule"] = true,
        ["cameracontroller"] = true,
        ["CameraController"] = true
    },
    StrictPathProcessing = true,
    AllowedPaths = {
        "ViewModel",
        "Arms",
        "Weapon",
        "Gun",
        "Knife",
        "Hands",
        "Tool"
    }
}
local function UpdateArmsVisual(color, transparency)
    if not color or transparency == nil then return end
    local function restoreViewModel(vm)
        if not vm or not vm.Parent then
            return
        end
        for stored, parent in pairs(ArmsVisual.SavedAppearances) do
            if stored and stored:IsA("SurfaceAppearance") and parent and parent:IsDescendantOf(vm) then
                pcall(function()
                    stored.Parent = parent
                end)
            end
        end
        ArmsVisual.SavedAppearances = {}
        for _, d in ipairs(vm:GetDescendants()) do
            if d:IsA("BasePart") or d:IsA("MeshPart") or d:IsA("Part") or d:IsA("UnionOperation") then
                pcall(function()
                    d.Material = Enum.Material.SmoothPlastic
                    d.Transparency = 0
                end)
            elseif d:IsA("Decal") or d:IsA("Texture") then
                pcall(function()
                    d.Transparency = 0
                end)
            elseif d:IsA("ParticleEmitter") or d:IsA("Beam") or d:IsA("Trail") then
                pcall(function()
                    d.Enabled = true
                    d.Transparency = NumberSequence.new(0)
                end)
            end
        end
        ArmsVisual.LastUsedColor = nil
        ArmsVisual.LastUsedTransparency = nil
        ArmsVisual.LastUsedMaterial = nil
        ArmsVisual.LastUpdateTime = nil
    end
    local nextMode = tostring(CurrentHandChamsType or "material"):lower()
    local lastMode = ArmsVisual.LastMode
    if lastMode ~= nextMode then
        if lastMode == "galaxy" and ESP and ESP._GalaxyHands_Stop then
            pcall(ESP._GalaxyHands_Stop)
        end
        if lastMode == "material" and nextMode ~= "material" then
            local vm = ArmsVisual.CachedViewModel
            if not vm or not vm.Parent then
                pcall(function()
                    for _, child in ipairs(workspace.Camera:GetChildren()) do
                        if child and child:IsA("Model") then
                            local name = child.Name:lower()
                            for _, allowedPath in ipairs(ArmsVisual.AllowedPaths) do
                                if name:find(allowedPath:lower()) then
                                    vm = child
                                    break
                                end
                            end
                            if vm then
                                break
                            end
                        end
                    end
                end)
            end
            restoreViewModel(vm)
        end
        ArmsVisual.LastMode = nextMode
    end
    if nextMode == "galaxy" then
        if ArmsVisual.Enabled then
            if ESP and ESP._GalaxyHands_Start then
                pcall(ESP._GalaxyHands_Start)
            end
        else
            if ESP and ESP._GalaxyHands_Stop then
                pcall(ESP._GalaxyHands_Stop)
            end
        end
        return
    end
    if CurrentHandChamsType ~= "opaque force field" and CurrentHandChamsType ~= "beast" then
        if ArmsVisual.BeastFolder then
            pcall(function()
                ArmsVisual.BeastFolder:Destroy()
            end)
            ArmsVisual.BeastFolder = nil
        end
        ArmsVisual.BeastParts = nil
        ArmsVisual.BeastInitializedFor = nil
        if ArmsVisual.Highlight then
            pcall(function()
                ArmsVisual.Highlight:Destroy()
            end)
        end
        ArmsVisual.Highlight = nil
        if _G.BeastChams_UnregisterArms then
            pcall(_G.BeastChams_UnregisterArms)
        end
        ArmsVisual.LastBeastRegisterModel = nil
        ArmsVisual.LastBeastRegisterTime = nil
    end
    if CurrentHandChamsType == "opaque force field" or CurrentHandChamsType == "beast" then
        if not _G.BeastChams_RegisterArms then
            pcall(StartBeastChams, false)
        end
        local setArmsColors = _G.BeastChams_SetArmsColors
        if setArmsColors then
            if CurrentHandChamsType == "opaque force field" then
                local outer = ArmsVisual.OpaqueOuterColor or Color3.fromRGB(0, 0, 0)
                local inner = ArmsVisual.OpaqueInnerColor or color
                pcall(setArmsColors, outer, inner)
            else
                pcall(setArmsColors, Color3.fromRGB(0, 0, 0), color)
            end
        end
        local register = _G.BeastChams_RegisterArms
        local unregister = _G.BeastChams_UnregisterArms
        if not ArmsVisual.Enabled then
            if unregister then
                pcall(unregister)
            end
            ArmsVisual.LastBeastRegisterModel = nil
            ArmsVisual.LastBeastRegisterTime = nil
            return
        end
        local viewModel = ArmsVisual.CachedViewModel
        local currentTime = tick()
        local forceUpdate = not viewModel or not viewModel.Parent
        if forceUpdate or not ArmsVisual.LastViewModelCheck or (currentTime - ArmsVisual.LastViewModelCheck) > 0.5 then
            viewModel = nil
            pcall(function()
                for _, child in ipairs(workspace.Camera:GetChildren()) do
                    if child and child:IsA("Model") then
                        local name = child.Name:lower()
                        local isAllowed = false
                        for _, allowedPath in ipairs(ArmsVisual.AllowedPaths) do
                            if name:find(allowedPath:lower()) then
                                isAllowed = true
                                break
                            end
                        end
                        if isAllowed then
                            viewModel = child
                            break
                        end
                    end
                end
            end)
            if viewModel then
                ArmsVisual.CachedViewModel = viewModel
                ArmsVisual.LastViewModelCheck = currentTime
            end
        end
        if viewModel and register then
            local now = tick()
            local shouldRegister = false
            if ArmsVisual.LastBeastRegisterModel ~= viewModel then
                shouldRegister = true
            elseif not ArmsVisual.LastBeastRegisterTime or (now - ArmsVisual.LastBeastRegisterTime) > 1 then
                shouldRegister = true
            end
            if shouldRegister then
                pcall(register, viewModel)
                ArmsVisual.LastBeastRegisterModel = viewModel
                ArmsVisual.LastBeastRegisterTime = now
            end
        elseif unregister then
            pcall(unregister)
            ArmsVisual.LastBeastRegisterModel = nil
            ArmsVisual.LastBeastRegisterTime = nil
        end
        return
    end
    local function shouldIgnore(obj)
        if not obj then return true end
        local current = obj
        while current and current ~= workspace.Camera do
            local name = current.Name:lower()
            if ArmsVisual.IgnoreList[name] then
                return true
            end
            if name:find("camera") then
                return true
            end
            current = current.Parent
        end
        if ArmsVisual.StrictPathProcessing then
            local isAllowed = false
            local current = obj
            while current and current ~= workspace.Camera do
                local name = current.Name:lower()
                for _, allowedPath in ipairs(ArmsVisual.AllowedPaths) do
                    if name:find(allowedPath:lower()) then
                        isAllowed = true
                        break
                    end
                end
                if isAllowed then break end
                current = current.Parent
            end
            return not isAllowed
        end
        return false
    end
    local viewModel = ArmsVisual.CachedViewModel
    local currentTime = tick()
    local forceUpdate = not viewModel or not viewModel.Parent
    if forceUpdate or not ArmsVisual.LastViewModelCheck or (currentTime - ArmsVisual.LastViewModelCheck) > 0.5 then
        viewModel = nil
        local validViewModels = {}
        pcall(function()
            for _, child in ipairs(workspace.Camera:GetChildren()) do
                if child and child:IsA("Model") and not shouldIgnore(child) then
                    table.insert(validViewModels, child)
                end
            end
        end)
        if #validViewModels > 0 then
            viewModel = validViewModels[1]
        end
        if viewModel then
            ArmsVisual.CachedViewModel = viewModel
            ArmsVisual.LastViewModelCheck = currentTime
        end
    end
    if not viewModel then return end
    local function safeSetTransparency(object, value)
        pcall(function()
            if not object or typeof(object) ~= "Instance" or shouldIgnore(object) then return end
            if object:IsA("ParticleEmitter") or object:IsA("Beam") or object:IsA("Trail") then
                if typeof(value) == "number" then
                    object.Transparency = NumberSequence.new(value)
                end
            elseif typeof(value) == "number" then
                object.Transparency = value
            end
        end)
    end
    local function safeSet(obj, prop, value)
        if not obj or typeof(obj) ~= "Instance" or shouldIgnore(obj) then return end
        pcall(function() obj[prop] = value end)
    end
    local timeThreshold = 0.25
    local skipCacheUpdate = false
    if ArmsVisual.LastUpdateTime and (currentTime - ArmsVisual.LastUpdateTime) < timeThreshold then
        if ArmsVisual.LastUsedColor and ArmsVisual.LastUsedTransparency and
           ArmsVisual.LastUsedMaterial and ArmsVisual.Enabled and
           ArmsVisual.LastUsedColor == color and
           math.abs(ArmsVisual.LastUsedTransparency - transparency) < 0.01 and
           ArmsVisual.LastUsedMaterial == ArmsVisual.Material then
            skipCacheUpdate = true
        end
    end
    if not skipCacheUpdate then
        ArmsVisual.LastUsedColor = color
        ArmsVisual.LastUsedTransparency = transparency
        ArmsVisual.LastUsedMaterial = ArmsVisual.Material
        ArmsVisual.LastUpdateTime = currentTime
        local partsToProcess = {}
        for _, part in ipairs(viewModel:GetDescendants()) do
            if shouldIgnore(part) then
                continue
            end
            local className = part.ClassName
            local validPartTypes = {
                ["BasePart"] = true,
                ["MeshPart"] = true,
                ["Part"] = true,
                ["UnionOperation"] = true
            }
            if validPartTypes[className] then
                if part.Transparency < 1 then
                    table.insert(partsToProcess, part)
                    safeSet(part, "CanCollide", false)
                end
            elseif part:IsA("Decal") or part:IsA("Texture") then
                if ArmsVisual.Enabled then
                    safeSetTransparency(part, 1)
                else
                    safeSetTransparency(part, 0)
                end
            elseif part:IsA("ParticleEmitter") or part:IsA("Beam") or part:IsA("Trail") then
                if ArmsVisual.Enabled then
                    safeSet(part, "Enabled", false)
                    safeSetTransparency(part, 1)
                else
                    safeSet(part, "Enabled", true)
                    safeSetTransparency(part, 0)
                end
            end
        end
        for _, part in ipairs(partsToProcess) do
            pcall(function()
                if ArmsVisual.Enabled then
                    for _, child in ipairs(part:GetChildren()) do
                        if child:IsA("SurfaceAppearance") and not ArmsVisual.SavedAppearances[child] then
                            ArmsVisual.SavedAppearances[child] = part
                            child.Parent = nil
                        end
                    end
                    for _, child in ipairs(part:GetChildren()) do
                        if child:IsA("SpecialMesh") or child:IsA("BlockMesh") or child:IsA("CylinderMesh") then
                            safeSet(child, "TextureId", "")
                            pcall(function()
                                child.VertexColor = Vector3.new(color.R, color.G, color.B)
                            end)
                        end
                    end
                    safeSet(part, "TextureID", "")
                    safeSet(part, "Material", ArmsVisual.Material)
                    safeSet(part, "Reflectance", 0)
                    safeSet(part, "Color", color)
                    if transparency >= 0 then
                        safeSet(part, "Transparency", transparency)
                    end
                else
                    for stored, parent in pairs(ArmsVisual.SavedAppearances) do
                        if parent == part then
                            stored.Parent = parent
                        end
                    end
                    safeSet(part, "Material", Enum.Material.SmoothPlastic)
                    safeSet(part, "Transparency", 0)
                end
            end)
        end
    end
    if not ArmsVisual.Enabled then
        ArmsVisual.SavedAppearances = {}
        ArmsVisual.LastUsedColor = nil
        ArmsVisual.LastUsedTransparency = nil
        ArmsVisual.LastUsedMaterial = nil
    end
    if ArmsVisual.LastUsedTransparency ~= transparency then
        ArmsVisual.LastUsedTransparency = transparency
        ArmsVisual.LastUpdateTime = tick() - 1
    end
end
local function EmergencyDisableArmsVisual()
    ArmsVisual.Enabled = false
    if ArmsVisual.Connection then
        ArmsVisual.Connection:Disconnect()
        ArmsVisual.Connection = nil
    end
    if ArmsVisual.WeaponChangeConnection then
        ArmsVisual.WeaponChangeConnection:Disconnect()
        ArmsVisual.WeaponChangeConnection = nil
    end
    if ArmsVisual.WeaponRemoveConnection then
        ArmsVisual.WeaponRemoveConnection:Disconnect()
        ArmsVisual.WeaponRemoveConnection = nil
    end
    if ArmsVisual.ViewModelChangeConnection then
        ArmsVisual.ViewModelChangeConnection:Disconnect()
        ArmsVisual.ViewModelChangeConnection = nil
    end
    for stored, parent in pairs(ArmsVisual.SavedAppearances) do
        pcall(function()
            if stored and stored:IsA("Instance") and parent and parent:IsA("Instance") and parent.Parent then
                stored.Parent = parent
            end
        end)
    end
    ArmsVisual.SavedAppearances = {}
    ArmsVisual.CachedViewModel = nil
    ArmsVisual.LastViewModelCheck = nil
    ArmsVisual.LastUsedColor = nil
    ArmsVisual.LastUsedTransparency = nil
    ArmsVisual.LastUsedMaterial = nil
    if ArmsVisual.BeastFolder then
        pcall(function()
            ArmsVisual.BeastFolder:Destroy()
        end)
    end
    ArmsVisual.BeastFolder = nil
    ArmsVisual.BeastParts = nil
    ArmsVisual.BeastInitializedFor = nil
    if ArmsVisual.Highlight then
        pcall(function()
            ArmsVisual.Highlight:Destroy()
        end)
    end
    ArmsVisual.Highlight = nil
    pcall(function()
        for _, child in ipairs(workspace.Camera:GetDescendants()) do
            if child:IsA("BasePart") or child:IsA("MeshPart") or
               child:IsA("Part") or child:IsA("UnionOperation") then
                pcall(function()
                    child.Material = Enum.Material.SmoothPlastic
                    child.Transparency = 0
                end)
            elseif child:IsA("Decal") or child:IsA("Texture") then
                pcall(function()
                    child.Transparency = 0
                end)
            elseif child:IsA("ParticleEmitter") or child:IsA("Beam") or child:IsA("Trail") then
                pcall(function()
                    child.Enabled = true
                    if child:IsA("ParticleEmitter") or child:IsA("Beam") or child:IsA("Trail") then
                        child.Transparency = NumberSequence.new(0)
                    end
                end)
            end
        end
    end)
    Window:Notify({
        Title = "Hand Chams",
        Description = "Hand Chams  - ",
        Lifetime = 5
    })
    if PlayerHandSection then
        pcall(function()
            if PlayerHandSection.Objects and
               PlayerHandSection.Objects["EnableHandSkin"] and
               type(PlayerHandSection.Objects["EnableHandSkin"].Set) == "function" then
                PlayerHandSection.Objects["EnableHandSkin"]:Set(false)
            end
        end)
    end
end
local PlayerHandSection = sections.PlayerHand
if PlayerHandSection then
    PlayerHandSection:Header({
        Text = "Hand & Weapon Chams"
    })
end
local function getArmsVisualPrimaryColor()
    local mode = tostring(CurrentHandChamsType or "material"):lower()
    if mode == "opaque force field" then
        return ArmsVisual.OpaqueInnerColor or ArmsVisual.Color or Color3.fromRGB(0, 255, 255)
    end
    return ArmsVisual.Color or Color3.fromRGB(0, 255, 255)
end
PlayerHandSection:Toggle({
    Name = "Enable Hand Chams",
    Default = false,
    Callback = function(value)
        local success, errorMsg = pcall(function()
            ArmsVisual.Enabled = value
            if ArmsVisual.Enabled then
                if ArmsVisual.Connection then
                    ArmsVisual.Connection:Disconnect()
                end
                ArmsVisual.Connection = game:GetService("RunService").RenderStepped:Connect(function()
                    local success, errorMsg = pcall(function()
                        UpdateArmsVisual(getArmsVisualPrimaryColor(), ArmsVisual.Transparency or 0.5)
                    end)
                    if not success then
                        pcall(EmergencyDisableArmsVisual)
                    end
                end)
                pcall(SetupWeaponChangeListener)
                pcall(function()
                    UpdateArmsVisual(getArmsVisualPrimaryColor(), ArmsVisual.Transparency or 0.5)
                end)
            else
                if ArmsVisual.Connection then
                    ArmsVisual.Connection:Disconnect()
                    ArmsVisual.Connection = nil
                end
                if ArmsVisual.WeaponChangeConnection then
                    ArmsVisual.WeaponChangeConnection:Disconnect()
                    ArmsVisual.WeaponChangeConnection = nil
                end
                if ArmsVisual.WeaponRemoveConnection then
                    ArmsVisual.WeaponRemoveConnection:Disconnect()
                    ArmsVisual.WeaponRemoveConnection = nil
                end
                pcall(function()
                    UpdateArmsVisual(Color3.fromRGB(30, 30, 30), 0)
                end)
            end
        end)
        if not success then
            pcall(EmergencyDisableArmsVisual)
            if PlayerHandSection then
                pcall(function()
                    if PlayerHandSection.Objects and
                       PlayerHandSection.Objects["EnableHandSkin"] and
                       type(PlayerHandSection.Objects["EnableHandSkin"].Set) == "function" then
                        PlayerHandSection.Objects["EnableHandSkin"]:Set(false)
                    end
                end)
            end
            pcall(function()
                Window:Notify({
                    Title = "Hand Chams",
                    Description = " : " .. tostring(errorMsg),
                    Lifetime = 5
                })
            end)
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "EnableHandSkin")
ESP._ui.playerHandColorPickerEl = PlayerHandSection:Colorpicker({
    Name = "Hand Color",
    Default = Color3.fromRGB(0, 255, 255),
    Callback = function(value)
        ArmsVisual.Color = value
        if ArmsVisual.Enabled then
            UpdateArmsVisual(getArmsVisualPrimaryColor(), ArmsVisual.Transparency or 0.5)
        end
    end
}, "HandColor")
ESP._ui.playerHandOpaqueOuterColorPickerEl = PlayerHandSection:Colorpicker({
    Name = "Opaque Outer Color",
    Default = Color3.fromRGB(0, 0, 0),
    Callback = function(value)
        ArmsVisual.OpaqueOuterColor = value
        if ArmsVisual.Enabled and tostring(CurrentHandChamsType or "material"):lower() == "opaque force field" then
            UpdateArmsVisual(getArmsVisualPrimaryColor(), ArmsVisual.Transparency or 0.5)
        end
    end
}, "HandOpaqueOuterColor")
ESP._ui.playerHandOpaqueInnerColorPickerEl = PlayerHandSection:Colorpicker({
    Name = "Opaque Inner Color",
    Default = Color3.fromRGB(0, 255, 255),
    Callback = function(value)
        ArmsVisual.OpaqueInnerColor = value
        if ArmsVisual.Enabled and tostring(CurrentHandChamsType or "material"):lower() == "opaque force field" then
            UpdateArmsVisual(getArmsVisualPrimaryColor(), ArmsVisual.Transparency or 0.5)
        end
    end
}, "HandOpaqueInnerColor")
ESP._ui.playerHandTransparencySliderEl = PlayerHandSection:Slider({
    Name = "Transparency",
    Default = 50,
    Minimum = 0.01,
    Maximum = 100,
    Precision = 2,
    Callback = function(value)
        ArmsVisual.Transparency = value / 100
        if ArmsVisual.Enabled then
            UpdateArmsVisual(getArmsVisualPrimaryColor(), ArmsVisual.Transparency)
        end
    end
}, "HandTransparency")
ESP._ui.playerHandMaterialDropdownEl = PlayerHandSection:Dropdown({
    Name = "Material Type",
    Multi = false,
    Required = true,
    Options = {"ForceField", "Neon", "Glass", "SmoothPlastic", "Opaque Force Field", "Galaxy"},
    Default = "ForceField",
    Callback = function(value)
        local materialMap = {
            Neon = Enum.Material.Neon,
            ForceField = Enum.Material.ForceField,
            Glass = Enum.Material.Glass,
            SmoothPlastic = Enum.Material.SmoothPlastic
        }
        local v = tostring(value)
        local vl = v:lower()
        if vl == "galaxy" then
            CurrentHandChamsType = "galaxy"
        elseif v == "Beast" or vl == "beast" or vl == "opaque force field" then
            CurrentHandChamsType = "opaque force field"
        else
            CurrentHandChamsType = "material"
            ArmsVisual.Material = materialMap[value] or Enum.Material.ForceField
        end
        if type(_G) == "table" then
            _G.CurrentHandChamsType = CurrentHandChamsType
        end
        if ArmsVisual.Enabled then
            local safeTransparency = ArmsVisual.Transparency or 0.5
            UpdateArmsVisual(getArmsVisualPrimaryColor(), safeTransparency)
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "MaterialType")
if ESP and ESP._ui and ESP._ui._syncESPVisibility then
    ESP._ui._syncESPVisibility()
end
local function updateGazeLine()
    if not ESP.Enabled or not ESP.Drawing.GazeLine.Enabled then return end
    local localPlayer = game:GetService("Players").LocalPlayer
    local localCharacter = localPlayer.Character
    local localHRP = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
    local camera = Workspace.CurrentCamera
    local maxDistance = ESP.MaxDistance
    local gazeLength = ESP.Drawing.GazeLine.Thickness
    local gazeColor = ESP.Drawing.GazeLine.RGB
    if not localHRP then return end
    if not ESP.GazeLines then
        ESP.GazeLines = {}
    end
    local function processGazeLine(player)
        if player == localPlayer then return end
        if not player or not player.Character then return end
        local head = player.Character:FindFirstChild("Head")
        if not head then return end
        local distanceM = (localHRP.Position - head.Position).Magnitude / allvars._units.studsPerMeter
        if distanceM > maxDistance then
            if ESP.GazeLines[player] then
                ESP.GazeLines[player].Visible = false
            end
            return
        end
        if ESP.TeamCheck then
            local playerTeam = player.Team
            local localTeam = localPlayer.Team
            if playerTeam and localTeam and playerTeam == localTeam then
                if ESP.GazeLines[player] then
                    ESP.GazeLines[player].Visible = false
                end
                return
            end
        end
        local lookVector = head.CFrame.LookVector
        if not ESP.GazeLines[player] then
            ESP.GazeLines[player] = Drawing.new("Line")
            ESP.GazeLines[player].Thickness = ESP.Drawing.GazeLine.Thickness
            ESP.GazeLines[player].Color = gazeColor
            ESP.GazeLines[player].Transparency = 1
        end
        local headPosition = head.Position
        local endPosition = headPosition + (lookVector * ESP.Drawing.GazeLine.Length)
        local distanceToCameraM = (camera.CFrame.Position - headPosition).Magnitude / allvars._units.studsPerMeter
        if distanceToCameraM > maxDistance * 1.2 then
            ESP.GazeLines[player].Visible = false
            return
        end
        local screenHeadPosition = camera:WorldToViewportPoint(headPosition)
        local screenEndPosition = camera:WorldToViewportPoint(endPosition)
        if screenHeadPosition.Z > 0 and screenEndPosition.Z > 0 then
            ESP.GazeLines[player].From = Vector2.new(screenHeadPosition.X, screenHeadPosition.Y)
            ESP.GazeLines[player].To = Vector2.new(screenEndPosition.X, screenEndPosition.Y)
            ESP.GazeLines[player].Visible = true
        else
            ESP.GazeLines[player].Visible = false
        end
    end
    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        processGazeLine(player)
    end
    for player, line in pairs(ESP.GazeLines) do
        if not player or not player.Character or not player.Character:FindFirstChild("Head") then
            line.Visible = false
            ESP.GazeLines[player] = nil
        end
    end
end
local function updateArrows()
    if not ESP.Enabled or not ESP.Drawing.Arrows.Enabled then
        if ESP.ArrowCache then
             for _, arrow in pairs(ESP.ArrowCache) do
                 arrow.Visible = false
             end
        end
        return
    end
    local camera = workspace.CurrentCamera
    local localPlayer = game:GetService("Players").LocalPlayer
    local center = camera.ViewportSize / 2
    local radius = ESP.Drawing.Arrows.Radius or 300
    local size = ESP.Drawing.Arrows.Size or 20
    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        if player ~= localPlayer then
             local character = player.Character
             if character and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0 then
                 if ESP.TeamCheck then
                    local playerTeam = player.Team
                    local localTeam = localPlayer.Team
                    if playerTeam and localTeam and playerTeam == localTeam then
                        if ESP.ArrowCache[player] then ESP.ArrowCache[player].Visible = false end
                        continue
                    end
                 end
                 local rootPart = character.HumanoidRootPart
                 local _, onScreen = camera:WorldToViewportPoint(rootPart.Position)
                 if not onScreen then
                     if not ESP.ArrowCache[player] then
                         ESP.ArrowCache[player] = Drawing.new("Triangle")
                         ESP.ArrowCache[player].Filled = true
                         ESP.ArrowCache[player].Thickness = 1
                     end
                     local arrow = ESP.ArrowCache[player]
                     arrow.Visible = true
                     arrow.Color = ESP.Drawing.Arrows.Color
                     arrow.Transparency = 1
                     local proj = camera.CFrame:PointToObjectSpace(rootPart.Position)
                     local angle = math.atan2(-proj.Y, proj.X)
                     local direction = Vector2.new(math.cos(angle), math.sin(angle))
                     local pos = center + direction * radius
                     local p1 = pos + direction * size
                     local p2 = pos + Vector2.new(math.cos(angle + math.rad(150)), math.sin(angle + math.rad(150))) * (size * 0.7)
                     local p3 = pos + Vector2.new(math.cos(angle - math.rad(150)), math.sin(angle - math.rad(150))) * (size * 0.7)
                     arrow.PointA = p1
                     arrow.PointB = p2
                     arrow.PointC = p3
                 else
                     if ESP.ArrowCache[player] then ESP.ArrowCache[player].Visible = false end
                 end
             else
                 if ESP.ArrowCache[player] then ESP.ArrowCache[player].Visible = false end
             end
        else
             if ESP.ArrowCache[player] then ESP.ArrowCache[player].Visible = false end
        end
    end
    for player, arrow in pairs(ESP.ArrowCache) do
        if not player or not player.Parent then
            arrow.Visible = false
            arrow:Remove()
            ESP.ArrowCache[player] = nil
        end
    end
end
local oldUpdateESP = UpdateESPSettings
UpdateESPSettings = function()
    if oldUpdateESP then
        oldUpdateESP()
    end
    pcall(updateGazeLine)
    pcall(updateArrows)
end
if not ESP.Connections.GazeLineUpdate then
    if ESP.Connections.GazeLineUpdate then
        ESP.Connections.GazeLineUpdate:Disconnect()
    end
    ESP.Connections.GazeLineUpdate = RunService.RenderStepped:Connect(function()
        if ESP.Enabled then
            if ESP.Drawing.GazeLine.Enabled then
                local currentTime = tick()
                if not ESP.Performance then
                    ESP.Performance = {}
                end
                if not ESP.Performance.LastGazeLineUpdate then
                    ESP.Performance.LastGazeLineUpdate = currentTime
                    ESP.Performance.GazeLineUpdateInterval = 0.03
                end
                if currentTime - ESP.Performance.LastGazeLineUpdate >= ESP.Performance.GazeLineUpdateInterval then
                    ESP.Performance.LastGazeLineUpdate = currentTime
                    pcall(updateGazeLine)
                end
            else
                if ESP.GazeLines then
                    for _, line in pairs(ESP.GazeLines) do
                        line.Visible = false
                    end
                end
            end
            if ESP.Drawing.Arrows.Enabled then
                 pcall(updateArrows)
            else
                 if ESP.ArrowCache then
                     for _, arrow in pairs(ESP.ArrowCache) do
                         arrow.Visible = false
                     end
                 end
            end
        end
    end)
    game:GetService("Players").PlayerRemoving:Connect(function(player)
        if ESP.GazeLines and ESP.GazeLines[player] then
            ESP.GazeLines[player].Visible = false
            ESP.GazeLines[player] = nil
        end
        if ESP.ArrowCache and ESP.ArrowCache[player] then
            ESP.ArrowCache[player].Visible = false
            ESP.ArrowCache[player]:Remove()
            ESP.ArrowCache[player] = nil
        end
    end)
end
local function UpdateSkeletonLine(line, part1, part2)
    if not line or not part1 or not part2 then
        if line then line.Visible = false end
        return
    end
    if typeof(part1) == "Instance" and not part1.Parent then
        line.Visible = false
        return
    end
    if typeof(part2) == "Instance" and not part2.Parent then
        line.Visible = false
        return
    end
    local position1, position2
    if typeof(part1) == "table" and part1.Position then
        position1 = part1.Position
    elseif typeof(part1) == "Instance" and part1:IsA("BasePart") then
        position1 = part1.Position
    end
    if typeof(part2) == "table" and part2.Position then
        position2 = part2.Position
    elseif typeof(part2) == "Instance" and part2:IsA("BasePart") then
        position2 = part2.Position
    end
    if not position1 or not position2 then
        line.Visible = false
        return
    end
    local camera = workspace.CurrentCamera
    local pos1, visible1 = camera:WorldToViewportPoint(position1)
    local pos2, visible2 = camera:WorldToViewportPoint(position2)
    if visible1 and visible2 and pos1.Z > 0 and pos2.Z > 0 then
        if not ESP.CachedFOV then
            ESP.CachedFOV = {
                baseFOV = 70,
                currentFOV = camera.FieldOfView,
                lastUpdateTime = tick(),
                fovCompensation = 1
            }
        end
        local currentTime = tick()
        if currentTime - ESP.CachedFOV.lastUpdateTime > 0.1 or ESP.CachedFOV.currentFOV ~= camera.FieldOfView then
            ESP.CachedFOV.currentFOV = camera.FieldOfView
            ESP.CachedFOV.lastUpdateTime = currentTime
            ESP.CachedFOV.fovCompensation = math.clamp(
                math.tan(math.rad(ESP.CachedFOV.baseFOV) / 2) / math.tan(math.rad(camera.FieldOfView) / 2),
                0.5, 2.0
            )
        end
        local distanceToCamera = (camera.CFrame.Position - position1).Magnitude
        local distanceFactor = math.clamp(1 - (distanceToCamera / 1000), 0.1, 1)
        local baseThickness = ESP.Drawing.Skeleton.Thickness or 1
        local finalThickness = baseThickness * ESP.CachedFOV.fovCompensation * distanceFactor
        line.From = Vector2.new(pos1.X, pos1.Y)
        line.To = Vector2.new(pos2.X, pos2.Y)
        line.Thickness = finalThickness
        line.Visible = true
    else
        line.Visible = false
    end
end
local function UpdatePlayerSkeleton(player, skeleton)
    if not player or not skeleton then return end
    local currentTime = tick()
    if not skeleton.lastUpdate or (currentTime - skeleton.lastUpdate > 0.02) then
        skeleton.forceUpdate = true
    end
    local character = player.Character
    if not character then
        if workspace:FindFirstChild("Players") then
            character = workspace.Players:FindFirstChild(player.Name)
        end
    end
    local function hideAllLines()
        if skeleton.allHidden then return end
        for name, line in pairs(skeleton) do
            if type(name) == "string" and name ~= "lastPlayerPos" and name ~= "lastUpdate" and
               name ~= "lastFoV" and name ~= "lastCamPos" and name ~= "allHidden" and
               name ~= "forceUpdate" then
                if line and typeof(line) ~= "table" and type(line) ~= "number" then
                    line.Visible = false
                end
            end
        end
        skeleton.allHidden = true
    end
    if not character or not ESP.Drawing.Skeleton.Enabled then
        hideAllLines()
        return
    end
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid and humanoid.Health <= 0 then
        hideAllLines()
        return
    end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local localPlayer = game:GetService("Players").LocalPlayer
    local localCharacter = localPlayer and localPlayer.Character
    local localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
    if not rootPart or not localRootPart then
        hideAllLines()
        return
    end
    local camera = workspace.CurrentCamera
    local camCFrame = camera.CFrame
    local currentCamPos = camCFrame.Position
    local currentFoV = camera.FieldOfView
    local rootPos = rootPart.Position
    if not skeleton.forceUpdate and skeleton.lastPlayerPos and skeleton.lastCamPos and skeleton.lastFoV then
        local positionDifference = (skeleton.lastPlayerPos - rootPos).Magnitude
        local cameraDifference = (skeleton.lastCamPos - currentCamPos).Magnitude
        local fovDifference = math.abs(skeleton.lastFoV - currentFoV)
        if positionDifference < 0.5 and cameraDifference < 0.5 and fovDifference < 0.1 then
            return
        end
    end
    local distance = (localRootPart.Position - rootPos).Magnitude
    local distanceM = distance / allvars._units.studsPerMeter
    local _, onScreen = camera:WorldToViewportPoint(rootPos)
    if not onScreen or (ESP.MaxDistance and distanceM > ESP.MaxDistance) then
        hideAllLines()
        return
    end
    skeleton.allHidden = false
    skeleton.forceUpdate = false
    skeleton.lastPlayerPos = rootPos
    skeleton.lastUpdate = tick()
    skeleton.lastFoV = currentFoV
    skeleton.lastCamPos = currentCamPos
    for name, line in pairs(skeleton) do
        if type(name) == "string" and name ~= "HeadCircle" and name ~= "lastPlayerPos" and name ~= "lastUpdate" and name ~= "lastFoV" and name ~= "lastCamPos" then
            pcall(function()
                if line and typeof(line) ~= "table" and type(line) ~= "number" and type(line.Color) ~= "nil" then
                    line.Color = ESP.Drawing.Skeleton.Color
                end
            end)
        end
    end
    pcall(function()
        if skeleton.HeadCircle and type(skeleton.HeadCircle) ~= "number" and type(skeleton.HeadCircle.Color) ~= "nil" then
            skeleton.HeadCircle.Color = ESP.Drawing.Skeleton.Color
        end
    end)
    pcall(function()
        local isR15 = (character:FindFirstChild("UpperTorso") ~= nil)
        if isR15 then
            local head = character:FindFirstChild("Head")
            local upperTorso = character:FindFirstChild("UpperTorso")
            local lowerTorso = character:FindFirstChild("LowerTorso")
            local leftUpperArm = character:FindFirstChild("LeftUpperArm")
            local leftLowerArm = character:FindFirstChild("LeftLowerArm")
            local leftHand = character:FindFirstChild("LeftHand")
            local rightUpperArm = character:FindFirstChild("RightUpperArm")
            local rightLowerArm = character:FindFirstChild("RightLowerArm")
            local rightHand = character:FindFirstChild("RightHand")
            if head and skeleton.HeadCircle and type(skeleton.HeadCircle) ~= "number" then
                local headScreen, headOnScreen = camera:WorldToViewportPoint(head.Position)
                if headOnScreen and headScreen.Z > 0 then
                    pcall(function()
                        local baseFOV = 70
                        local currentFOV = camera.FieldOfView
                        local fovRatio = baseFOV / currentFOV
                        local fovCompensation = math.clamp(
                            math.tan(math.rad(baseFOV) / 2) / math.tan(math.rad(currentFOV) / 2),
                            0.5,
                            2.0
                        )
                        local distanceToHead = (camera.CFrame.Position - head.Position).Magnitude
                        local distanceFactor = math.clamp(1 - (distanceToHead / 1000), 0.1, 1)
                        local baseRadius = 3
                        local finalRadius = baseRadius * fovCompensation * distanceFactor
                        skeleton.HeadCircle.Position = Vector2.new(headScreen.X, headScreen.Y)
                        skeleton.HeadCircle.Radius = finalRadius
                        skeleton.HeadCircle.Visible = true
                    end)
                else
                    pcall(function()
                        skeleton.HeadCircle.Visible = false
                    end)
                end
            end
            local leftShoulder, rightShoulder
            if upperTorso then
                local leftShoulderAttachment = upperTorso:FindFirstChild("LeftShoulderRigAttachment")
                if leftShoulderAttachment then
                    leftShoulder = {Position = leftShoulderAttachment.WorldPosition, Parent = upperTorso}
                else
                    leftShoulder = {Position = upperTorso.Position + Vector3.new(-upperTorso.Size.X/2, upperTorso.Size.Y/2.5, 0), Parent = upperTorso}
                end
                local rightShoulderAttachment = upperTorso:FindFirstChild("RightShoulderRigAttachment")
                if rightShoulderAttachment then
                    rightShoulder = {Position = rightShoulderAttachment.WorldPosition, Parent = upperTorso}
                else
                    rightShoulder = {Position = upperTorso.Position + Vector3.new(upperTorso.Size.X/2, upperTorso.Size.Y/2.5, 0), Parent = upperTorso}
                end
            end
            if head and upperTorso then
                UpdateSkeletonLine(skeleton.NeckLine, head, upperTorso)
            end
            if upperTorso and lowerTorso then
                UpdateSkeletonLine(skeleton.UpperSpine, upperTorso, lowerTorso)
            end
            if leftShoulder and leftUpperArm then
                UpdateSkeletonLine(skeleton.LeftUpperArm, leftShoulder, leftUpperArm)
            end
            if leftLowerArm and leftHand then
                UpdateSkeletonLine(skeleton.LeftLowerArm, leftLowerArm, leftHand)
            end
            if rightShoulder and rightUpperArm then
                UpdateSkeletonLine(skeleton.RightUpperArm, rightShoulder, rightUpperArm)
            end
            if rightLowerArm and rightHand then
                UpdateSkeletonLine(skeleton.RightLowerArm, rightLowerArm, rightHand)
            end
            if leftUpperArm and leftLowerArm then
                UpdateSkeletonLine(skeleton.LeftElbow, leftUpperArm, leftLowerArm)
            end
            if rightUpperArm and rightLowerArm then
                UpdateSkeletonLine(skeleton.RightElbow, rightUpperArm, rightLowerArm)
            end
            local leftUpperLeg = character:FindFirstChild("LeftUpperLeg")
            local leftLowerLeg = character:FindFirstChild("LeftLowerLeg")
            local leftFoot = character:FindFirstChild("LeftFoot")
            local rightUpperLeg = character:FindFirstChild("RightUpperLeg")
            local rightLowerLeg = character:FindFirstChild("RightLowerLeg")
            local rightFoot = character:FindFirstChild("RightFoot")
            if lowerTorso and leftUpperLeg then
                UpdateSkeletonLine(skeleton.LeftUpperLeg, lowerTorso, leftUpperLeg)
            end
            if leftUpperLeg and leftLowerLeg then
                UpdateSkeletonLine(skeleton.LeftLowerLeg, leftUpperLeg, leftLowerLeg)
            end
            if leftLowerLeg and leftFoot then
                UpdateSkeletonLine(skeleton.LeftFoot, leftLowerLeg, leftFoot)
            end
            if lowerTorso and rightUpperLeg then
                UpdateSkeletonLine(skeleton.RightUpperLeg, lowerTorso, rightUpperLeg)
            end
            if rightUpperLeg and rightLowerLeg then
                UpdateSkeletonLine(skeleton.RightLowerLeg, rightUpperLeg, rightLowerLeg)
            end
            if rightLowerLeg and rightFoot then
                UpdateSkeletonLine(skeleton.RightFoot, rightLowerLeg, rightFoot)
            end
            if upperTorso then
                local shouldUseLeftClavicle = false
                local shouldUseRightClavicle = false
                if shouldUseLeftClavicle then
                    local leftClavicleAttachment = upperTorso:FindFirstChild("LeftCollarAttachment")
                    if leftClavicleAttachment and leftShoulder then
                        pcall(function()
                            local leftClaviclePos = leftClavicleAttachment.WorldPosition
                            UpdateSkeletonLine(skeleton.LeftClavicle, {Position = leftClaviclePos, Parent = upperTorso}, leftShoulder)
                        end)
                    else
                        UpdateSkeletonLine(skeleton.LeftClavicle,
                            {Position = upperTorso.Position + Vector3.new(-upperTorso.Size.X/4, upperTorso.Size.Y/2.5, 0), Parent = upperTorso},
                            leftShoulder)
                    end
                    local rightClavicleAttachment = upperTorso:FindFirstChild("RightCollarAttachment")
                    if rightClavicleAttachment and rightShoulder then
                        pcall(function()
                            local rightClaviclePos = rightClavicleAttachment.WorldPosition
                            UpdateSkeletonLine(skeleton.RightClavicle, {Position = rightClaviclePos, Parent = upperTorso}, rightShoulder)
                        end)
                    else
                        UpdateSkeletonLine(skeleton.RightClavicle,
                            {Position = upperTorso.Position + Vector3.new(upperTorso.Size.X/4, upperTorso.Size.Y/2.5, 0), Parent = upperTorso},
                            rightShoulder)
                    end
                else
                    pcall(function()
                        if skeleton.LeftClavicle then
                            skeleton.LeftClavicle.Visible = false
                        end
                        if skeleton.RightClavicle then
                            skeleton.RightClavicle.Visible = false
                        end
                    end)
                    if leftShoulder and upperTorso then
                        pcall(function()
                            UpdateSkeletonLine(skeleton.LeftClavicle,
                                leftShoulder,
                                {Position = upperTorso.Position + Vector3.new(0, upperTorso.Size.Y/4, 0), Parent = upperTorso})
                        end)
                    end
                    if rightShoulder and upperTorso then
                        pcall(function()
                            UpdateSkeletonLine(skeleton.RightClavicle,
                                rightShoulder,
                                {Position = upperTorso.Position + Vector3.new(0, upperTorso.Size.Y/4, 0), Parent = upperTorso})
                        end)
                    end
                end
            end
        end
    end)
end
local function ClearSkeletons()
    for player, skeleton in pairs(ESP.Skeletons) do
        for name, element in pairs(skeleton) do
            pcall(function()
                if element and typeof(element) ~= "table" then
                    element:Remove()
                end
            end)
        end
    end
    ESP.Skeletons = {}
end
local originalESPUpdateConnection = ESP.Connections.RunService
if originalESPUpdateConnection and typeof(originalESPUpdateConnection) == "RBXScriptConnection" then
    originalESPUpdateConnection:Disconnect()
end
ESP.Connections.RunService = RunService.RenderStepped:Connect(function()
    if ESP.Enabled then
        if ESP.Drawing.Skeleton.Enabled then
            local currentTime = tick()
            if ESP.Performance and ESP.Performance.LastSkeletonUpdate then
                ESP.Performance.LastSkeletonUpdate = currentTime
                pcall(function()
                    for _, player in pairs(Players:GetPlayers()) do
                        if player ~= Players.LocalPlayer then
                            local character = player.Character
                            if not character and workspace:FindFirstChild("Players") then
                                character = workspace.Players:FindFirstChild(player.Name)
                            end
                            if character and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0 then
                                if not ESP.Skeletons[player] then
                                    pcall(InitializePlayerSkeleton, player)
                                end
                                if ESP.Skeletons[player] then
                                    pcall(function()
                                        UpdatePlayerSkeleton(player, ESP.Skeletons[player])
                                    end)
                                end
                            else
                                if ESP.Skeletons[player] then
                                    for name, element in pairs(ESP.Skeletons[player]) do
                                        pcall(function()
                                            if element and typeof(element) ~= "table" and type(element) ~= "number" and type(name) == "string" and name ~= "lastPlayerPos" and name ~= "lastUpdate" and name ~= "lastFoV" and name ~= "lastCamPos" then
                                                element.Visible = false
                                            end
                                        end)
                                    end
                                end
                            end
                        end
                    end
                end)
            end
        else
            for player, skeleton in pairs(ESP.Skeletons) do
                for name, element in pairs(skeleton) do
                    pcall(function()
                        if element and typeof(element) ~= "table" and type(element) ~= "number" and type(name) == "string" and name ~= "lastPlayerPos" and name ~= "lastUpdate" and name ~= "lastFoV" and name ~= "lastCamPos" then
                            element.Visible = false
        end
    end)
                end
            end
        end
    else
        for player, skeleton in pairs(ESP.Skeletons) do
            for name, element in pairs(skeleton) do
                pcall(function()
                    if element and typeof(element) ~= "table" and type(element) ~= "number" and type(name) == "string" and name ~= "lastPlayerPos" and name ~= "lastUpdate" and name ~= "lastFoV" and name ~= "lastCamPos" then
                        element.Visible = false
                    end
                end)
            end
        end
    end
end)
Players.PlayerAdded:Connect(function(player)
    if ESP.Drawing.Skeleton.Enabled then
        if player ~= Players.LocalPlayer then
            InitializePlayerSkeleton(player)
        end
    end
end)
Players.PlayerRemoving:Connect(function(player)
    if ESP.Skeletons[player] then
        for name, element in pairs(ESP.Skeletons[player]) do
            pcall(function()
                if element and typeof(element) ~= "table" then
                    element:Remove()
                end
            end)
        end
        ESP.Skeletons[player] = nil
    end
end)
game:GetService("Players").LocalPlayer.Destroying:Connect(function()
    ClearSkeletons()
end)
local function IsDrawingAvailable()
    local success = pcall(function()
        local testDrawing = Drawing.new("Line")
        testDrawing:Remove()
    end)
    return success
end
local function SafeCloudAccess()
    local terrain = Workspace:FindFirstChildOfClass("Terrain")
    if not terrain then return nil end
    local cloudExists = false
    pcall(function() cloudExists = terrain.Clouds ~= nil end)
    if not cloudExists then
        return nil
    end
    return {
        terrain = terrain,
        getColor = function()
            local success, result = pcall(function() return terrain.Clouds.Color end)
            return success and result or Color3.fromRGB(255, 255, 255)
        end,
        getCover = function()
            local success, result = pcall(function() return terrain.Clouds.Cover end)
            return success and result or 0.5
        end,
        getDensity = function()
            local success, result = pcall(function() return terrain.Clouds.Density end)
            return success and result or 0.5
        end,
        getEnabled = function()
            local success, result = pcall(function() return terrain.Clouds.Enabled end)
            return success and result or false
        end,
        setColor = function(color)
            pcall(function() terrain.Clouds.Color = color end)
        end,
        setCover = function(cover)
            pcall(function() terrain.Clouds.Cover = cover end)
        end,
        setDensity = function(density)
            pcall(function() terrain.Clouds.Density = density end)
        end,
        setEnabled = function(enabled)
            pcall(function() terrain.Clouds.Enabled = enabled end)
        end
    }
end
local function SetupWeaponChangeListener()
    local camera = workspace.Camera
    if ArmsVisual.WeaponChangeConnection then
        ArmsVisual.WeaponChangeConnection:Disconnect()
        ArmsVisual.WeaponChangeConnection = nil
    end
    if ArmsVisual.WeaponRemoveConnection then
        ArmsVisual.WeaponRemoveConnection:Disconnect()
        ArmsVisual.WeaponRemoveConnection = nil
    end
    if ArmsVisual.ViewModelChildrenConnection then
        ArmsVisual.ViewModelChildrenConnection:Disconnect()
        ArmsVisual.ViewModelChildrenConnection = nil
    end
    if ArmsVisual.ViewModelChildrenRemovedConnection then
        ArmsVisual.ViewModelChildrenRemovedConnection:Disconnect()
        ArmsVisual.ViewModelChildrenRemovedConnection = nil
    end
    local currentSettings = {
        Enabled = ArmsVisual.Enabled,
        Color = ArmsVisual.Color or Color3.fromRGB(0, 255, 255),
        Transparency = ArmsVisual.Transparency or 0.5,
        Material = ArmsVisual.Material or Enum.Material.ForceField
    }
    local function shouldProcess(obj)
        if not obj or not obj:IsA("Model") then
            return false
        end
        local name = obj.Name:lower()
        if (ArmsVisual.IgnoreList and ArmsVisual.IgnoreList[name]) or name:find("camera") then
            return false
        end
        local isViewModel = name:find("view") or name:find("arm") or
                           name:find("weapon") or name:find("hand") or
                           name:find("gun") or name:find("item") or name:find("model")
        return isViewModel
    end
    local function updateViewModel(model)
        if not model or not ArmsVisual.Enabled then return end
        ArmsVisual.LastUsedColor = nil
        ArmsVisual.LastUsedTransparency = nil
        ArmsVisual.LastUsedMaterial = nil
        ArmsVisual.LastViewModelCheck = nil
        ArmsVisual.CachedViewModel = model
        ArmsVisual.LastViewModelCheck = nil
        if ArmsVisual.ViewModelChildrenConnection then
            ArmsVisual.ViewModelChildrenConnection:Disconnect()
            ArmsVisual.ViewModelChildrenConnection = nil
        end
        if ArmsVisual.ViewModelChildrenRemovedConnection then
            ArmsVisual.ViewModelChildrenRemovedConnection:Disconnect()
            ArmsVisual.ViewModelChildrenRemovedConnection = nil
        end
        ArmsVisual.ViewModelChildrenConnection = model.DescendantAdded:Connect(function(child)
            if not ArmsVisual.Enabled then return end
            task.delay(0.05, function()
                if not ArmsVisual.Enabled then return end
                ArmsVisual.LastUsedColor = nil
                ArmsVisual.LastUsedTransparency = nil
                ArmsVisual.LastUsedMaterial = nil
                pcall(function()
                    UpdateArmsVisual(currentSettings.Color, currentSettings.Transparency)
                end)
            end)
        end)
        ArmsVisual.ViewModelChildrenRemovedConnection = model.DescendantRemoving:Connect(function(child)
            if not ArmsVisual.Enabled then return end
            if child:IsA("BasePart") or child:IsA("MeshPart") or child:IsA("Part") or child:IsA("UnionOperation") then
                task.delay(0.1, function()
                    if ArmsVisual.Enabled and model.Parent then
                        ArmsVisual.LastUsedColor = nil
                        ArmsVisual.LastUsedTransparency = nil
                        ArmsVisual.LastUsedMaterial = nil
                        pcall(function()
                            UpdateArmsVisual(currentSettings.Color, currentSettings.Transparency)
                        end)
                    end
                end)
            end
        end)
        task.delay(0.1, function()
            if ArmsVisual.Enabled then
                ArmsVisual.LastUsedColor = nil
                ArmsVisual.LastUsedTransparency = nil
                ArmsVisual.LastUsedMaterial = nil
                pcall(function()
                    UpdateArmsVisual(currentSettings.Color, currentSettings.Transparency)
                end)
            end
        end)
    end
    ArmsVisual.WeaponChangeConnection = camera.ChildAdded:Connect(function(child)
        if shouldProcess(child) then
            task.delay(0.05, function()
                updateViewModel(child)
            end)
        end
    end)
    ArmsVisual.WeaponRemoveConnection = camera.ChildRemoved:Connect(function(child)
        if child == ArmsVisual.CachedViewModel then
            ArmsVisual.CachedViewModel = nil
            ArmsVisual.LastViewModelCheck = nil
            if ArmsVisual.ViewModelChildrenConnection then
                ArmsVisual.ViewModelChildrenConnection:Disconnect()
                ArmsVisual.ViewModelChildrenConnection = nil
            end
            if ArmsVisual.ViewModelChildrenRemovedConnection then
                ArmsVisual.ViewModelChildrenRemovedConnection:Disconnect()
                ArmsVisual.ViewModelChildrenRemovedConnection = nil
            end
            task.delay(0.1, function()
                if not ArmsVisual.Enabled then return end
                for _, model in ipairs(camera:GetChildren()) do
                    if shouldProcess(model) and model ~= child then
                        updateViewModel(model)
                        break
                    end
                end
            end)
        end
    end)
    task.delay(0.05, function()
        for _, model in ipairs(camera:GetChildren()) do
            if shouldProcess(model) then
                updateViewModel(model)
                break
            end
        end
    end)
    return true
end
if ArmsVisual.ViewModelChildrenConnection then
    ArmsVisual.ViewModelChildrenConnection:Disconnect()
    ArmsVisual.ViewModelChildrenConnection = nil
end
local originalToggleCallback = nil
if PlayerHandSection and PlayerHandSection.Objects and PlayerHandSection.Objects["EnableHandSkin"] and
   PlayerHandSection.Objects["EnableHandSkin"].Callback then
    originalToggleCallback = PlayerHandSection.Objects["EnableHandSkin"].Callback
    PlayerHandSection.Objects["EnableHandSkin"].Callback = function(value)
        if originalToggleCallback then
            originalToggleCallback(value)
        end
        if value then
            if type(SetupWeaponChangeListener) == "function" then
                SetupWeaponChangeListener()
            end
        else
            if ArmsVisual.WeaponChangeConnection then
                ArmsVisual.WeaponChangeConnection:Disconnect()
                ArmsVisual.WeaponChangeConnection = nil
            end
            if ArmsVisual.WeaponRemoveConnection then
                ArmsVisual.WeaponRemoveConnection:Disconnect()
                ArmsVisual.WeaponRemoveConnection = nil
            end
        end
    end
end
if ArmsVisual and ArmsVisual.Enabled then
    if type(SetupWeaponChangeListener) == "function" then
        SetupWeaponChangeListener()
    end
end
local function CleanupArmsVisualConnections()
    if not ArmsVisual then
        return
    end
    if ArmsVisual.Connection then
        ArmsVisual.Connection:Disconnect()
        ArmsVisual.Connection = nil
    end
    if ArmsVisual.WeaponChangeConnection then
        ArmsVisual.WeaponChangeConnection:Disconnect()
        ArmsVisual.WeaponChangeConnection = nil
    end
    if ArmsVisual.WeaponRemoveConnection then
        ArmsVisual.WeaponRemoveConnection:Disconnect()
        ArmsVisual.WeaponRemoveConnection = nil
    end
    if ArmsVisual.ViewModelChangeConnection then
        ArmsVisual.ViewModelChangeConnection:Disconnect()
        ArmsVisual.ViewModelChangeConnection = nil
    end
    ArmsVisual.CachedViewModel = nil
    ArmsVisual.LastViewModelCheck = nil
    ArmsVisual.LastUsedColor = nil
    ArmsVisual.LastUsedTransparency = nil
    ArmsVisual.LastUsedMaterial = nil
    ArmsVisual.SavedAppearances = {}
end
game:GetService("Players").PlayerRemoving:Connect(function(player)
    if player == game:GetService("Players").LocalPlayer then
        CleanupArmsVisualConnections()
    end
end)
if Window and Window.unload and _G.allvars and _G.allvars._rt then
    if _G.allvars._rt.__originalUnload == nil then
        _G.allvars._rt.__originalUnload = Window.unload
        Window.unload = function(...)
            CleanupArmsVisualConnections()
            return _G.allvars._rt.__originalUnload(...)
        end
    end
end
_G.allvars._rt.track(RunService.RenderStepped:Connect(function()
    if not ESP.Enabled then return end
    local drawingAvailable = pcall(function()
        local testDrawing = Drawing.new("Line")
        testDrawing:Remove()
    end)
    if not drawingAvailable and ESP.Drawing.Skeleton.Enabled then
        ESP.Drawing.Skeleton.Enabled = false
        pcall(function()
            if ESP and ESP._ui and ESP._ui.skeletonToggleEl and ESP._ui.skeletonToggleEl.set_value then
                ESP._ui.skeletonToggleEl:set_value(false)
            end
        end)
        if not ESP.DrawingUnavailableNotified then
            ESP.DrawingUnavailableNotified = true
            Window:Notify({
                Title = "",
                Description = " Drawing .  .",
                Lifetime = 5
            })
        end
        return
    end
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            if ESP.Drawing.Skeleton.Enabled and drawingAvailable and not ESP.Skeletons[player] then
                InitializePlayerSkeleton(player)
            end
            if ESP.Drawing.Skeleton.Enabled and drawingAvailable and ESP.Skeletons[player] then
                UpdatePlayerSkeleton(player, ESP.Skeletons[player])
            end
        end
    end
end))
sections.WorldVisual:Header({
    Text = "World Color Settings"
})
_G.WorldColorSettings = {
    enabled = false,
    originalAmbient = nil,
    originalOutdoorAmbient = nil,
    customAmbient = Color3.fromRGB(72, 69, 157),
    customOutdoorAmbient = Color3.fromRGB(47, 61, 132),
    connection = nil
}
ESP._ui.worldCustomWorldColorToggleEl = sections.WorldVisual:Toggle({
    Name = "Custom World Color",
    Default = false,
    Callback = function(value)
        _G.WorldColorSettings.enabled = value
        if value then
            if not _G.WorldColorSettings.originalAmbient then
                _G.WorldColorSettings.originalAmbient = Lighting.Ambient
                _G.WorldColorSettings.originalOutdoorAmbient = Lighting.OutdoorAmbient
            end
            if not _G.WorldColorSettings.connection then
                _G.WorldColorSettings.connection = RunService.Heartbeat:Connect(function()
                    if _G.WorldColorSettings.enabled then
                        Lighting.Ambient = _G.WorldColorSettings.customAmbient
                        Lighting.OutdoorAmbient = _G.WorldColorSettings.customOutdoorAmbient
                    end
                end)
            end
        else
            if _G.WorldColorSettings.connection then
                _G.WorldColorSettings.connection:Disconnect()
                _G.WorldColorSettings.connection = nil
            end
            if _G.WorldColorSettings.originalAmbient then
                Lighting.Ambient = _G.WorldColorSettings.originalAmbient
                Lighting.OutdoorAmbient = _G.WorldColorSettings.originalOutdoorAmbient
            end
        end
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "CustomWorldColor")
ESP._ui.worldIndoorAmbientColorPickerEl = sections.WorldVisual:Colorpicker({
    Name = "Indoor Ambient",
    Default = Color3.fromRGB(72, 69, 157),
    Alpha = 0,
    Callback = function(color)
        _G.WorldColorSettings.customAmbient = color
        if _G.WorldColorSettings.enabled then
            Lighting.Ambient = color
        end
    end
}, "IndoorAmbientColor")
ESP._ui.worldOutdoorAmbientColorPickerEl = sections.WorldVisual:Colorpicker({
    Name = "Outdoor Ambient",
    Default = Color3.fromRGB(47, 61, 132),
    Alpha = 0,
    Callback = function(color)
        _G.WorldColorSettings.customOutdoorAmbient = color
        if _G.WorldColorSettings.enabled then
            Lighting.OutdoorAmbient = color
        end
    end
}, "OutdoorAmbientColor")
ESP._ui.worldResetWorldColorButtonEl = sections.WorldVisual:Button({
    Name = "Reset World Color",
    Callback = function()
        if _G.WorldColorSettings.originalAmbient then
            _G.WorldColorSettings.customAmbient = _G.WorldColorSettings.originalAmbient
            _G.WorldColorSettings.customOutdoorAmbient = _G.WorldColorSettings.originalOutdoorAmbient
            if _G.WorldColorSettings.enabled then
                Lighting.Ambient = _G.WorldColorSettings.originalAmbient
                Lighting.OutdoorAmbient = _G.WorldColorSettings.originalOutdoorAmbient
            end
            pcall(function()
                local el = ESP and ESP._ui and ESP._ui.worldIndoorAmbientColorPickerEl
                if el and el.set_value then
                    el:set_value(_G.WorldColorSettings.originalAmbient)
                end
            end)
            pcall(function()
                local el = ESP and ESP._ui and ESP._ui.worldOutdoorAmbientColorPickerEl
                if el and el.set_value then
                    el:set_value(_G.WorldColorSettings.originalOutdoorAmbient)
                end
            end)
        end
    end
})
if ESP and ESP._ui and ESP._ui._syncESPVisibility then
    ESP._ui._syncESPVisibility()
end
sections.PlayerScreen:Header({
    Text = "Resolution Stretch"
})
_G.ResolutionStretch = {
    Enabled = false,
    Amount = 0.6,
    Connection = nil
}
local RESOLUTION_STRETCH_BIND_NAME = "RAILhub_ResolutionStretch"
local function SetResolutionStretchEnabled(enabled)
    local rs = rawget(_G, "ResolutionStretch")
    if not rs then return end
    local runService = game:GetService("RunService")
    pcall(function()
        runService:UnbindFromRenderStep(RESOLUTION_STRETCH_BIND_NAME)
    end)
    rs.Connection = nil
    if not enabled then
        return
    end
    runService:BindToRenderStep(RESOLUTION_STRETCH_BIND_NAME, Enum.RenderPriority.Camera.Value + 1, function()
        local cam = workspace.CurrentCamera
        if not cam then return end
        local amt = rs.Amount
        if type(amt) ~= "number" or amt == 1 then
            return
        end
        cam.CFrame = cam.CFrame * CFrame.new(0, 0, 0, 1, 0, 0, 0, amt, 0, 0, 0, 1)
    end)
    rs.Connection = {
        Disconnect = function()
            pcall(function()
                runService:UnbindFromRenderStep(RESOLUTION_STRETCH_BIND_NAME)
            end)
        end
    }
end
ESP._ui.resStretchToggleEl = sections.PlayerScreen:Toggle({
    Name = "Resolution Stretch",
    Default = false,
    Callback = function(value)
        _G.ResolutionStretch.Enabled = value
        SetResolutionStretchEnabled(value)
        if ESP and ESP.Enabled and type(ForceESPRefresh) == "function" then
            pcall(ForceESPRefresh)
        end
        if ESP and ESP._ui and ESP._ui._syncResStretchVisibility then
            ESP._ui._syncResStretchVisibility()
        end
    end
}, "ResolutionStretch")
ESP._ui.resStretchSliderEl = sections.PlayerScreen:Slider({
    Name = "Stretch Amount",
    Default = 0.6,
    Minimum = 0.1,
    Maximum = 1.22,
    Precision = 2,
    Callback = function(value)
        _G.ResolutionStretch.Amount = value
    end
}, "ResolutionStretchAmount")
ESP._ui._syncResStretchVisibility = function()
    local setVisible = ESP and ESP._ui and ESP._ui._setVisible
    if not setVisible then return end
    local enabled = _G.ResolutionStretch.Enabled
    setVisible(ESP._ui.resStretchSliderEl, enabled)
end
if ESP and ESP._ui and ESP._ui._syncResStretchVisibility then
    ESP._ui._syncResStretchVisibility()
end
local function ForceUpdateArmsVisual()
    if not ArmsVisual then return end
    ArmsVisual.LastUsedColor = nil
    ArmsVisual.LastUsedTransparency = nil
    ArmsVisual.LastUsedMaterial = nil
    ArmsVisual.LastUpdateTime = nil
    ArmsVisual.LastViewModelCheck = nil
    ArmsVisual.CachedViewModel = nil
    pcall(function()
        for _, child in ipairs(workspace.Camera:GetChildren()) do
            if child:IsA("Model") and not child.Name:lower():find("camera") then
                ArmsVisual.CachedViewModel = child
                break
            end
        end
    end)
    task.delay(0.05, function()
        pcall(function()
            if ArmsVisual.Enabled then
                local safeColor = ArmsVisual.Color or Color3.fromRGB(0, 255, 255)
                local safeTransparency = ArmsVisual.Transparency or 0.5
                UpdateArmsVisual(safeColor, safeTransparency)
            end
        end)
    end)
    if ArmsVisual.Enabled then
        pcall(SetupWeaponChangeListener)
    end
end
local cameraProtectionConnection = nil
local function PreventCameraConflicts()
    if cameraProtectionConnection then
        cameraProtectionConnection:Disconnect()
        cameraProtectionConnection = nil
    end
    cameraProtectionConnection = game:GetService("RunService").Heartbeat:Connect(function()
        if not ArmsVisual.Enabled then
            cameraProtectionConnection:Disconnect()
            cameraProtectionConnection = nil
            return
        end
        pcall(function()
            for _, child in ipairs(workspace.Camera:GetChildren()) do
                if child.Name:lower():find("camera") then
                    for _, subChild in ipairs(child:GetDescendants()) do
                        if subChild:IsA("BasePart") or subChild:IsA("MeshPart") or
                           subChild:IsA("Part") or subChild:IsA("UnionOperation") then
                            pcall(function()
                                subChild.Transparency = 0
                                subChild.Material = Enum.Material.SmoothPlastic
                                subChild.Color = Color3.fromRGB(163, 162, 165)
                            end)
                        elseif subChild:IsA("Decal") or subChild:IsA("Texture") then
                            pcall(function()
                                subChild.Transparency = 0
                            end)
                        end
                    end
                end
            end
        end)
    end)
    return cameraProtectionConnection
end
local prevArmsVisualEnabled = false
_G.allvars._rt.track(game:GetService("RunService").Heartbeat:Connect(function()
    if ArmsVisual and ArmsVisual.Enabled ~= prevArmsVisualEnabled then
        prevArmsVisualEnabled = ArmsVisual.Enabled
        if ArmsVisual.Enabled then
            PreventCameraConflicts()
        elseif cameraProtectionConnection then
            cameraProtectionConnection:Disconnect()
            cameraProtectionConnection = nil
        end
    end
end))
_G.allvars._rt.track(localplayer.CharacterAdded:Connect(function(lchar)
    local maingui = localplayer.PlayerGui:WaitForChild("MainGui")
    if maingui then
        _G.allvars._rt.track(maingui.ChildAdded:Connect(function(Sound)
            if Sound:IsA("Sound") and hitsoundbool then
                if Sound.SoundId == "rbxassetid://4585351098" or Sound.SoundId == "rbxassetid://4585382589" then
                    Sound.SoundId = hitsoundlib[hitsoundhead]
                elseif Sound.SoundId == "rbxassetid://4585382046" or Sound.SoundId == "rbxassetid://4585364605" then
                    Sound.SoundId = hitsoundlib[hitsoundbody]
                end
            end
        end))
    end
end))
if localplayer.PlayerGui:FindFirstChild("MainGui") then
    _G.allvars._rt.track(localplayer.PlayerGui.MainGui.ChildAdded:Connect(function(Sound)
        if Sound:IsA("Sound") and hitsoundbool then
            if Sound.SoundId == "rbxassetid://4585351098" or Sound.SoundId == "rbxassetid://4585382589" then
                Sound.SoundId = hitsoundlib[hitsoundhead]
            elseif Sound.SoundId == "rbxassetid://4585382046" or Sound.SoundId == "rbxassetid://4585364605" then
                Sound.SoundId = hitsoundlib[hitsoundbody]
            end
        end
    end))
end
local fpsrequired = require(game.ReplicatedStorage.Modules.FPS)
local a1table
localplayer.CharacterAdded:Connect(function()
    task.wait(1)
    for i,v in pairs(getgc(true)) do
        if type(v) == 'table' and rawget(v, 'humanoid') and rawget(v, 'settings') then
            a1table = v
            break
        end
    end
end)
runs.RenderStepped:Connect(function()
    pcall(function()
        if aimtarget ~= nil and aimtargetname and aimtargetname.Visible then
            pcall(function()
                local _, gun = getcurrentgun(localplayer)
                if gun then
                    local ammo = gun:FindFirstChild("LoadedAmmo", true)
                    if ammo then
                        local shots = #ammo:GetChildren()
                        aimtargetshots.Text = "Shots: " .. shots
                        aimtargetshots.Visible = true
                        aimtargetshots.Position = getCenter() + Vector2.new(0, aimfov + 40)
                        return
                    end
                end
                aimtargetshots.Text = " "
                aimtargetshots.Visible = false
            end)
        else
            aimtargetshots.Text = " "
            aimtargetshots.Visible = false
        end
    end)
end)
runs.Heartbeat:Connect(function(delta)
    if not localplayer.Character or not localplayer.Character:FindFirstChild("HumanoidRootPart") or not localplayer.Character:FindFirstChild("Humanoid") then
        return
    end
    pcall(function()
        choosetarget()
    end)
    if aimbool then
        pcall(function()
            local bulletModule = getSafeBulletModule()
            if bulletModule and aimmodfunc ~= nil then
                local currentFunc = require(bulletModule).CreateBullet
                if currentFunc ~= aimmodfunc then
                    require(bulletModule).CreateBullet = aimmodfunc
                end
            end
        end)
    end
    if aimtrigger and aimtarget ~= nil and a1table and fpsrequired and fpsrequired.action then
        pcall(function()
            fpsrequired.action(a1table, true)
            wait()
            fpsrequired.action(a1table, false)
        end)
    end
    if aimselftrack and localplayer.Character and localplayer.Character:FindFirstChild("HumanoidRootPart") then
        pcall(function()
            selftrack_update += 1
            if selftrack_update >= 30 then
                selftrack_update = 0
                local ping = localplayer:GetNetworkPing() * 1000 + 5
                local key = math.floor(ping / 30) * 30
                local added = false
                for i, entry in ipairs(selftrack_data) do
                    if entry.ms == key then
                        entry.vpos = localplayer.Character.HumanoidRootPart.Position + Vector3.new(0, 1.5, 0)
                        added = true
                        break
                    end
                end
                if not added then
                    table.insert(selftrack_data, {
                        ms = key,
                        vpos = localplayer.Character.HumanoidRootPart.Position + Vector3.new(0, 1.5, 0)
                    })
                end
                if #selftrack_data > 30 then
                    table.remove(selftrack_data, 1)
                end
            end
        end)
    end
end)
pcall(function()
    local bulletModule = getSafeBulletModule()
    if bulletModule and not aimogfunc then
        aimogfunc = require(bulletModule).CreateBullet
    end
end)
sections.GunMod:Header({
    Text = "Gun Mod Settings"
})
_G.allvars = _G.allvars or allvars or {}
_G.allvars._rt = _G.allvars._rt or {}
_G.allvars._rt.__fpsModule = _G.allvars._rt.__fpsModule or require(game.ReplicatedStorage.Modules.FPS)
_G.allvars._rt.__instaReloadSyncBullets = _G.allvars._rt.__instaReloadSyncBullets or function(ctx)
    local weapon = ctx and ctx.weapon
    if not weapon then return end
    local itemProps = weapon:FindFirstChild("ItemProperties")
    local attachments = weapon:FindFirstChild("Attachments")
    local magFolder = attachments and attachments:FindFirstChild("Magazine")
    local loadedAmmoFolder
    local loadedAmmoCount
    if magFolder then
        local mags = magFolder:GetChildren()
        local mag = mags[#mags]
        local magProps = mag and mag:FindFirstChild("ItemProperties")
        loadedAmmoCount = magProps and magProps:GetAttribute("LoadedAmmo") or nil
        loadedAmmoFolder = magProps and magProps:FindFirstChild("LoadedAmmo") or nil
    else
        loadedAmmoCount = itemProps and itemProps:GetAttribute("LoadedAmmo") or nil
        loadedAmmoFolder = itemProps and itemProps:FindFirstChild("LoadedAmmo") or nil
    end
    if loadedAmmoCount ~= nil then
        ctx.Bullets = loadedAmmoCount
    end
    ctx.BulletsList = {}
    if loadedAmmoFolder then
        for _, ammoNode in ipairs(loadedAmmoFolder:GetChildren()) do
            local idx = tonumber(ammoNode.Name)
            if idx then
                ctx.BulletsList[idx] = {
                    AmmoType = ammoNode:GetAttribute("AmmoType"),
                    Amount = ammoNode:GetAttribute("Amount"),
                }
            end
        end
    end
end
_G.allvars._rt.__instaReloadSyncMovement = _G.allvars._rt.__instaReloadSyncMovement or function(ctx)
    local weapon = ctx and ctx.weapon
    if not weapon then return end
    local modifier = 0
    local itemProps = weapon:FindFirstChild("ItemProperties")
    local tool = itemProps and itemProps:FindFirstChild("Tool")
    if tool then
        modifier += tool:GetAttribute("MovementModifer") or 0
    end
    local attachments = weapon:FindFirstChild("Attachments")
    if attachments then
        for _, att in ipairs(attachments:GetChildren()) do
            local sv = att:FindFirstChildOfClass("StringValue")
            local props = sv and sv:FindFirstChild("ItemProperties")
            local attachmentProps = props and props:FindFirstChild("Attachment")
            if attachmentProps then
                modifier += attachmentProps:GetAttribute("MovementModifer") or 0
            end
        end
    end
    ctx.movementModifier = modifier
end
_G.allvars._rt.__instaReloadSyncViewModel = _G.allvars._rt.__instaReloadSyncViewModel or function(ctx)
    local vm = ctx and ctx.viewModel
    local weapon = ctx and ctx.weapon
    if not (vm and weapon) then return end
    local item = vm:FindFirstChild("Item")
    if not item then return end
    local itemProps = weapon:FindFirstChild("ItemProperties")
    local ammoTypeValue = itemProps and itemProps:FindFirstChild("AmmoType")
    local ammoTypeName = ammoTypeValue and ammoTypeValue.Value or nil
    if not ammoTypeName then return end
    local types = item:FindFirstChild("AmmoTypes")
    if types then
        for _, v in ipairs(types:GetChildren()) do
            v.Transparency = 1
        end
        local sel = types:FindFirstChild(ammoTypeName)
        if sel then sel.Transparency = 0 end
    end
    local types2 = item:FindFirstChild("AmmoTypes2")
    if types2 then
        for _, v in ipairs(types2:GetChildren()) do
            v.Transparency = 1
        end
        local sel2 = types2:FindFirstChild(ammoTypeName)
        if sel2 then sel2.Transparency = 0 end
    end
end
_G.allvars._rt.instrelMODfunc = _G.allvars._rt.instrelMODfunc or function(ctx, a2)
    if not ctx then return end
    if ctx.reloading or ctx.cancellingReload then return end
    if (tonumber(ctx.MaxAmmo) or 0) <= 0 then return end
    local canReload = true
    local cancelTables = ctx.CancelTables
    if type(cancelTables) == "table" then
        for i = 1, #cancelTables do
            local t = cancelTables[i]
            if t and t.Visible == true then
                canReload = false
                break
            end
        end
    end
    if not canReload then return end
    pcall(function()
        local tr = ctx.clientAnimationTracks and ctx.clientAnimationTracks.Inspect
        if tr then tr:Stop() end
    end)
    pcall(function()
        local tr = ctx.serverAnimationTracks and ctx.serverAnimationTracks.Inspect
        if tr then tr:Stop() end
    end)
    pcall(function()
        local snd = ctx.WeldedTool and ctx.WeldedTool.ItemRoot and ctx.WeldedTool.ItemRoot:FindFirstChild("Sounds")
        snd = snd and snd:FindFirstChild("Inspect")
        if snd then snd:Stop() end
    end)
    if not (ctx.settings and ctx.settings.AimWhileActing) and ctx.isAiming then
        pcall(function() ctx:aim(false) end)
    end
    local remotes = game.ReplicatedStorage:FindFirstChild("Remotes")
    local reloadRemote = remotes and remotes:FindFirstChild("Reload")
    local fps = (_G.allvars and _G.allvars._rt and _G.allvars._rt.__fpsModule) or require(game.ReplicatedStorage.Modules.FPS)
    if not (reloadRemote and reloadRemote.InvokeServer) then
        return fps.reload(ctx, a2)
    end
    if ctx.reloadType == "loadByHand" then
        local count = tonumber(ctx.Bullets) or 0
        local maxCount = tonumber(ctx.MaxAmmo) or 0
        for _ = count, maxCount do
            pcall(function() reloadRemote:InvokeServer(nil, 0.001, nil) end)
        end
    else
        pcall(function() reloadRemote:InvokeServer(nil, 0.001, nil) end)
        pcall(function() fps.equip(ctx, ctx.weapon, nil) end)
    end
    _G.allvars._rt.__instaReloadSyncBullets(ctx)
    _G.allvars._rt.__instaReloadSyncMovement(ctx)
    _G.allvars._rt.__instaReloadSyncViewModel(ctx)
end
_G.allvars._rt.track(workspace.Camera.ChildAdded:Connect(function(ch)
    if allvars and allvars.instaequip and ch:IsA("Model") then
        task.wait(0.015)
        local humanoid = ch:FindFirstChild("Humanoid")
        if humanoid and humanoid:FindFirstChild("Animator") then
            for i,v in pairs(humanoid.Animator:GetPlayingAnimationTracks()) do
                if v.Animation.Name == "Equip" then
                    v.TimePosition = v.Length - 0.01
                end
            end
        end
    end
end))
_G.allvars._rt.track(runs.Heartbeat:Connect(function(delta)
    local inv = game.ReplicatedStorage.Players:FindFirstChild(localplayer.Name)
    if inv then
        inv = inv.Inventory
        if inv then
            for _, v in pairs(inv:GetChildren()) do
                if v:FindFirstChild("SettingsModule") then
                    local sett = require(v.SettingsModule)
                    if allvars and allvars.noswaybool then
                        sett.swayModifier = 0
                        sett.aimSwayModifier = 0
                        sett.breathSwayModifier = 0
                    end
                end
            end
        end
    end
end))
_G.allvars.toggleForceUnderground = function(enabled)
    if enabled then
        pcall(function()
            if DesyncModule and (not DesyncModule.Enabled) and type(desyncSetEnabled) == "function" then
                desyncSetEnabled(true)
            end
        end)
    end
    local desyncEnabled = (DesyncModule and DesyncModule.Enabled) or (desyncbool == true)
    if not desyncEnabled then
        enabled = false
    end
    invisbool = enabled
    if invisnum == nil then invisnum = 0 end
    if not invisanim then
        invisanim = Instance.new("Animation")
        invisanim.AnimationId = "rbxassetid://15609995579"
    end
    if localplayer.Character and localplayer.Character:FindFirstChild("Humanoid") then
        local humanoid = localplayer.Character.Humanoid
        local animator = humanoid:FindFirstChildOfClass("Animator")
        if enabled then
            pcall(function()
                if invistrack then
                    invistrack:Stop()
                    invistrack:Destroy()
                    invistrack = nil
                end
                if animator then
                    invistrack = animator:LoadAnimation(invisanim)
                    invistrack:Play(0.01, 1, 0)
                end
            end)
            camthirdp = true
            thirdpshow = true
            pcall(function()
                _G.allvars.camthirdp = true
                _G.thirdpshow = true
            end)
            task.spawn(function()
                for _ = 1, 3 do
                    game.Players.LocalPlayer.CameraMode = Enum.CameraMode.Classic
                    task.wait(0.1)
                end
            end)
            pcall(function()
                game.Players.LocalPlayer.CameraMode = Enum.CameraMode.Classic
                local dist = (allvars and allvars.camthirdpDist) or (_G.allvars and _G.allvars.camthirdpDist) or 5
                game.Players.LocalPlayer.CameraMaxZoomDistance = dist
                game.Players.LocalPlayer.CameraMinZoomDistance = dist
                humanoid.CameraOffset = Vector3.new(1.75, 0, 0)
                task.delay(0.1, function()
                    if localplayer.Character and localplayer.Character:FindFirstChild("Humanoid") then
                        localplayer.Character.Humanoid.CameraOffset = Vector3.new(1.75, 0, 0)
                    end
                end)
            end)
            if _G.allvars and _G.allvars._rt and _G.allvars._rt.setThirdPersonShiftLock then
                _G.allvars._rt.setThirdPersonShiftLock(true, humanoid)
            end
        else
            pcall(function()
                if invistrack then
                    invistrack:Stop()
                    invistrack:Destroy()
                    invistrack = nil
                end
                if animator then
                    for _, v in pairs(animator:GetPlayingAnimationTracks()) do
                        if v.Animation and v.Animation.AnimationId == "rbxassetid://15609995579" then
                            v:Stop()
                        end
                    end
                end
            end)
            if camthirdp then
                camthirdp = false
                pcall(function()
                    _G.allvars.camthirdp = false
                end)
            end
            pcall(function()
                humanoid.CameraOffset = Vector3.new(0, 0, 0)
                local original = _G.allvars and _G.allvars._rt and _G.allvars._rt.originalCamera
                if original then
                    if original.CameraMode ~= nil then
                        game.Players.LocalPlayer.CameraMode = original.CameraMode
                    end
                    if original.CameraMaxZoomDistance ~= nil then
                        game.Players.LocalPlayer.CameraMaxZoomDistance = original.CameraMaxZoomDistance
                    end
                    if original.CameraMinZoomDistance ~= nil then
                        game.Players.LocalPlayer.CameraMinZoomDistance = original.CameraMinZoomDistance
                    end
                end
            end)
            if _G.allvars and _G.allvars._rt and _G.allvars._rt.setThirdPersonShiftLock then
                _G.allvars._rt.setThirdPersonShiftLock(false, humanoid)
            end
        end
    end
end
if type(desynctable) ~= "table" then
    desynctable = {}
end
_G.allvars._rt.track(runs.Heartbeat:Connect(function(delta)
    if not localplayer.Character or not localplayer.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    local targetPos = Vector3.new(0, 0, 0)
    local targetRot = Vector3.new(0, 0, 0)
    local isActive = desyncbool and localplayer.Character.Humanoid.Health > 0
    if isActive then
        if invisbool then
            targetPos = Vector3.new(0, -2.55, 0)
            targetRot = Vector3.new(90, 0, 0)
            if invistrack then
                invistrack:Stop()
                invistrack = localplayer.Character.Humanoid.Animator:LoadAnimation(invisanim)
                invistrack:Play(.01, 1, 0)
                invistrack.TimePosition = invisnum
            end
        else
            if desyncPos then
                targetPos = Vector3.new(desynXp or 0, math.max(desynYp or 0, -2), desynZp or 0)
            end
            if desyncOr then
                targetRot = Vector3.new(desynXo or 0, desynYo or 0, desynZo or 0)
            end
        end
    end
    if desynctable._smoothPos == nil then
        desynctable._smoothPos = Vector3.new(0, 0, 0)
    end
    if desynctable._smoothRot == nil then
        desynctable._smoothRot = Vector3.new(0, 0, 0)
    end
    desynctable._smoothPos = desynctable._smoothPos:Lerp(targetPos, 0.1)
    desynctable._smoothRot = desynctable._smoothRot:Lerp(targetRot, 0.1)
    local smoothPos = desynctable._smoothPos
    local smoothRot = desynctable._smoothRot
    if isActive or smoothPos.Magnitude > 0.05 or smoothRot.Magnitude > 0.05 then
        desynctable[1] = localplayer.Character.HumanoidRootPart.CFrame
        desynctable[2] = localplayer.Character.HumanoidRootPart.AssemblyLinearVelocity
        local cf = localplayer.Character.HumanoidRootPart.CFrame
        local spoofedcf = cf
            * CFrame.new(smoothPos)
            * CFrame.Angles(math.rad(smoothRot.X), math.rad(smoothRot.Y), math.rad(smoothRot.Z))
        desynctable[3] = spoofedcf
        localplayer.Character.HumanoidRootPart.CFrame = spoofedcf
        runs.RenderStepped:Wait()
        localplayer.Character.HumanoidRootPart.CFrame = desynctable[1]
        localplayer.Character.HumanoidRootPart.AssemblyLinearVelocity = desynctable[2]
    end
end))
_G.allvars._rt.track(runs.RenderStepped:Connect(function(delta)
    if not localplayer.Character or not localplayer.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    local desyncEnabled = (DesyncModule and DesyncModule.Enabled) or (desyncbool == true)
    if desyncEnabled and invisbool then
        local vel = localplayer.Character.HumanoidRootPart.AssemblyLinearVelocity
        local newvel = Vector3.new(vel.X, math.clamp(vel.Y, -99999, 19), vel.Z)
        localplayer.Character.HumanoidRootPart.AssemblyLinearVelocity = newvel
    elseif (not invisbool) and invistrack then
        invistrack:Stop()
        invistrack:Destroy()
    end
    if desyncvis and desynctable[3] then
        desyncvis.CFrame = desynctable[3] * CFrame.new(0, -0.7, 0)
        localplayer.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
    end
end))
sections.PlayerThirdPerson:Header({
    Text = "Third Person"
})
if not _G.allvars.camthirdpDist then _G.allvars.camthirdpDist = 5 end
if not allvars.camthirdpDist then allvars.camthirdpDist = _G.allvars.camthirdpDist end
if _G.allvars and _G.allvars._rt then
    _G.allvars._rt._tpKeyLastSet = _G.allvars._rt._tpKeyLastSet or 0
end
_G.allvars.thirdPersonKey = Enum.KeyCode.J
allvars.thirdPersonKey = Enum.KeyCode.J
pcall(function()
    if MacLib and MacLib.Flags then
        MacLib.Flags["ThirdPersonKey"] = Enum.KeyCode.J
    end
end)
pcall(function()
    if _G.allvars and _G.allvars._rt then
        _G.allvars._rt._tpKeyLastSet = tick()
    end
end)
if _G.allvars.thirdPersonSelfChams == nil then _G.allvars.thirdPersonSelfChams = false end
if allvars.thirdPersonSelfChams == nil then allvars.thirdPersonSelfChams = _G.allvars.thirdPersonSelfChams end
_G.allvars._rt.applyThirdPersonState = function(value)
    allvars.camthirdp = value
    _G.allvars.camthirdp = value
    if ESP and ESP._ui and ESP._ui._syncESPVisibility then
        ESP._ui._syncESPVisibility()
    end
    local char = localplayer and localplayer.Character
    local hum = char and char:FindFirstChild("Humanoid")
    if value then
        if hum then
            local dist = allvars.camthirdpDist or 5
            localplayer.CameraMode = Enum.CameraMode.Classic
            localplayer.CameraMaxZoomDistance = dist
            localplayer.CameraMinZoomDistance = dist
            hum.CameraOffset = Vector3.new(1.75, 0, 0)
            pcall(function()
                for _, d in ipairs(char:GetDescendants()) do
                    if d:IsA("BasePart") then
                        d.LocalTransparencyModifier = 0
                    end
                end
            end)
            if _G.allvars and _G.allvars._rt and _G.allvars._rt.setThirdPersonShiftLock then
                _G.allvars._rt.setThirdPersonShiftLock(true, hum)
            end
        end
    else
        if hum then
            hum.CameraOffset = Vector3.new(0, 0, 0)
        end
        if char then
            local hl = char:FindFirstChild("ThirdPersonSelfChamsHL")
            if hl and hl.Destroy then
                pcall(function() hl:Destroy() end)
            end
        end
        local original = _G.allvars and _G.allvars._rt and _G.allvars._rt.originalCamera
        if original and localplayer then
            if original.CameraMode ~= nil then
                localplayer.CameraMode = original.CameraMode
            end
            if original.CameraMaxZoomDistance ~= nil then
                localplayer.CameraMaxZoomDistance = original.CameraMaxZoomDistance
            end
            if original.CameraMinZoomDistance ~= nil then
                localplayer.CameraMinZoomDistance = original.CameraMinZoomDistance
            end
        end
        if hum then
            if _G.allvars and _G.allvars._rt and _G.allvars._rt.setThirdPersonShiftLock then
                _G.allvars._rt.setThirdPersonShiftLock(false, hum)
            end
        else
            if _G.allvars and _G.allvars._rt and _G.allvars._rt.clearThirdPersonShiftLock then
                _G.allvars._rt.clearThirdPersonShiftLock()
            end
        end
    end
end
_G.allvars._rt.setThirdPersonToggle = function(state)
    local rt = _G.allvars and _G.allvars._rt
    if not rt then
        return false
    end
    local before = (_G.allvars and _G.allvars.camthirdp) == true
    rt._tpSetting = true
    pcall(function()
        if MacLib and MacLib.Flags then
            MacLib.Flags["ThirdPersonToggle"] = state
        end
        if rt.applyThirdPersonState then
            rt.applyThirdPersonState(state)
        end
        if state and _G.SetThirdPersonCamera then
            _G.SetThirdPersonCamera()
        end
    end)
    local primaryEl = (MacLib and MacLib.Elements and MacLib.Elements["ThirdPersonToggle"])
    local secondaryEl = rt.thirdPersonToggleEl
    local function syncEl(el)
        if not el then
            return
        end
        pcall(function()
            if rawget(el, "Value") ~= nil then
                el.Value = state
            end
            if rawget(el, "State") ~= nil then
                el.State = state
            end
        end)
        if el.UpdateState then
            local ok = pcall(function() el:UpdateState(state) end)
            if not ok then
                pcall(function() el.UpdateState(el, state) end)
            end
        end
        if el.Set then
            local ok = pcall(function() el:Set(state) end)
            if not ok then
                ok = pcall(function() el.Set(el, state) end)
            end
            if not ok then
                pcall(function() el.Set(state) end)
            end
        end
        if el.SetValue then
            local ok = pcall(function() el:SetValue(state) end)
            if not ok then
                ok = pcall(function() el.SetValue(el, state) end)
            end
            if not ok then
                pcall(function() el.SetValue(state) end)
            end
        end
        if el.UpdateVisuals then
            local ok = pcall(function() el:UpdateVisuals(state) end)
            if not ok then
                ok = pcall(function() el.UpdateVisuals(el, state) end)
            end
            if not ok then
                pcall(function() el.UpdateVisuals(state) end)
            end
        end
    end
    syncEl(primaryEl)
    if secondaryEl ~= primaryEl then
        syncEl(secondaryEl)
    end
    task.defer(function()
        local rt2 = _G.allvars and _G.allvars._rt
        if rt2 then
            rt2._tpSetting = true
        end
        syncEl(primaryEl)
        if secondaryEl ~= primaryEl then
            syncEl(secondaryEl)
        end
        if rt2 then
            rt2._tpSetting = false
        end
    end)
    rt._tpSetting = false
    return before ~= state
end
_G.allvars._rt.thirdPersonToggleEl = sections.PlayerThirdPerson:Toggle({
    Name = "Third Person",
    Default = false,
    Callback = function(value)
        local rt = _G.allvars and _G.allvars._rt
        if rt and rt._tpSetting then
            return
        end
        task.spawn(function()
            pcall(function()
                if _G.allvars and _G.allvars._rt and _G.allvars._rt.applyThirdPersonState then
                    _G.allvars._rt.applyThirdPersonState(value)
                end
                if value and _G.SetThirdPersonCamera then
                    _G.SetThirdPersonCamera()
                end
            end)
        end)
        if ESP and ESP._ui and ESP._ui._syncESPVisibility then
            ESP._ui._syncESPVisibility()
        end
    end
}, "ThirdPersonToggle")
ESP._ui.playerThirdPersonSelfChamsToggleEl = sections.PlayerThirdPerson:Toggle({
    Name = "Self Chams",
    Default = allvars.thirdPersonSelfChams == true,
    Callback = function(value)
        allvars.thirdPersonSelfChams = value
        _G.allvars.thirdPersonSelfChams = value
    end
}, "ThirdPersonSelfChams")
ESP._ui.playerThirdPersonDistanceSliderEl = sections.PlayerThirdPerson:Slider({
    Name = "Camera Distance",
    Default = allvars.camthirdpDist or 5,
    Minimum = 2,
    Maximum = 20,
    Precision = 1,
    Callback = function(value)
        allvars.camthirdpDist = value
        _G.allvars.camthirdpDist = value
        if allvars.camthirdp and localplayer then
            localplayer.CameraMaxZoomDistance = value
            localplayer.CameraMinZoomDistance = value
        end
    end
}, "ThirdPersonDistance")
ESP._ui.playerThirdPersonKeybindEl = sections.PlayerThirdPerson:Keybind({
    Name = "Third Person Key",
    Default = allvars.thirdPersonKey,
    Flag = "ThirdPersonKey",
    Callback = function(key)
        if key == nil then
            return
        end
        allvars.thirdPersonKey = key
        _G.allvars.thirdPersonKey = key
        if MacLib and MacLib.Flags then
            MacLib.Flags["ThirdPersonKey"] = key
        end
        if _G.allvars and _G.allvars._rt then
            _G.allvars._rt._tpKeyLastSet = tick()
        end
    end,
    KeyChanged = function(key)
        allvars.thirdPersonKey = key
        _G.allvars.thirdPersonKey = key
        if MacLib and MacLib.Flags then
            MacLib.Flags["ThirdPersonKey"] = key
        end
        if _G.allvars and _G.allvars._rt then
            _G.allvars._rt._tpKeyLastSet = tick()
        end
    end
})
if _G.allvars and _G.allvars._rt then
    if _G.allvars._rt.thirdPersonKeySyncConn then
        _G.allvars._rt.disconnect(_G.allvars._rt.thirdPersonKeySyncConn)
        _G.allvars._rt.thirdPersonKeySyncConn = nil
    end
    _G.allvars._rt.thirdPersonKeySyncConn = _G.allvars._rt.track(runs.Heartbeat:Connect(function()
        local flags = MacLib and MacLib.Flags
        local flagKey = flags and flags["ThirdPersonKey"]
        local el = ESP and ESP._ui and ESP._ui.playerThirdPersonKeybindEl
        local elKey = nil
        if el then
            elKey =
                rawget(el, "Key") or rawget(el, "Bind") or rawget(el, "Value") or rawget(el, "CurrentKey") or rawget(el, "SelectedKey")
        end
        local rt = _G.allvars and _G.allvars._rt
        local lastSet = (rt and rt._tpKeyLastSet) or 0
        local canAcceptExternal = (tick() - lastSet) > 0.25
        local candidate = nil
        if typeof(elKey) == "EnumItem" then
            candidate = elKey
        elseif typeof(flagKey) == "EnumItem" then
            candidate = flagKey
        end
        if canAcceptExternal and candidate and allvars.thirdPersonKey ~= candidate then
            allvars.thirdPersonKey = candidate
            _G.allvars.thirdPersonKey = candidate
        end
        local want = allvars.thirdPersonKey or (_G.allvars and _G.allvars.thirdPersonKey)
        if typeof(want) == "EnumItem" then
            if flags and flags["ThirdPersonKey"] ~= want then
                flags["ThirdPersonKey"] = want
                if rt then
                    rt._tpKeyLastSet = tick()
                end
            end
            if el then
                pcall(function()
                    if el.Set then
                        el:Set(want)
                    elseif el.SetValue then
                        el:SetValue(want)
                    elseif el.UpdateVisuals then
                        el:UpdateVisuals(want)
                    end
                end)
            end
        end
    end))
end
if ESP and ESP._ui and ESP._ui._syncESPVisibility then
    ESP._ui._syncESPVisibility()
end
if _G.ThirdPersonKeyConn then
    _G.allvars._rt.disconnect(_G.ThirdPersonKeyConn)
    _G.ThirdPersonKeyConn = nil
end
_G.ThirdPersonKeyConn = _G.allvars._rt.track(uis.InputBegan:Connect(function(input, gameProcessed)
    if uis:GetFocusedTextBox() then return end
    local key = allvars.thirdPersonKey or (_G.allvars and _G.allvars.thirdPersonKey) or (MacLib and MacLib.Flags and MacLib.Flags["ThirdPersonKey"])
    if key and input.KeyCode == key then
        local newState = not (_G.allvars and _G.allvars.camthirdp)
        if _G.allvars and _G.allvars._rt and _G.allvars._rt.setThirdPersonToggle then
            _G.allvars._rt.setThirdPersonToggle(newState)
        end
    end
end))
if _G.ThirdPersonCameraConnection then _G.ThirdPersonCameraConnection:Disconnect() _G.ThirdPersonCameraConnection = nil end
if _G.ThirdPersonCameraConnection2 then _G.ThirdPersonCameraConnection2:Disconnect() _G.ThirdPersonCameraConnection2 = nil end
runs:UnbindFromRenderStep("ThirdPersonFix")
runs:BindToRenderStep("ThirdPersonFix", Enum.RenderPriority.Camera.Value + 1, function()
    if not (allvars.camthirdp and localplayer.Character) then return end
    local hum = localplayer.Character:FindFirstChild("Humanoid")
    if hum then
        do
            local rt = _G.allvars and _G.allvars._rt
            if rt and rt.setThirdPersonInputLock then
                local wantsCursor = false
                pcall(function()
                    if gui and gui.MenuIsOpen then
                        wantsCursor = true
                    end
                end)
                if not wantsCursor and uis:GetFocusedTextBox() then
                    wantsCursor = true
                end
                if not wantsCursor then
                    local now = tick()
                    rt._tpCursorCheckAt = rt._tpCursorCheckAt or 0
                    if now - rt._tpCursorCheckAt > 0.15 then
                        rt._tpCursorCheckAt = now
                        local found = false
                        local viewportSize = Vector2New(1920, 1080)
                        pcall(function()
                            local cam = workspace.CurrentCamera
                            if cam then
                                viewportSize = cam.ViewportSize
                            end
                        end)
                        local function isLargeOverlayGuiObject(obj)
                            if not obj or not obj.Visible then return false end
                            local ok, absSize = pcall(function() return obj.AbsoluteSize end)
                            if not ok or not absSize then return false end
                            return absSize.X >= (viewportSize.X * 0.6) and absSize.Y >= (viewportSize.Y * 0.6)
                        end
                        local function isHierarchyEnabled(obj)
                            local cur = obj
                            for _ = 1, 30 do
                                cur = cur and cur.Parent
                                if not cur then
                                    return true
                                end
                                if cur:IsA("ScreenGui") then
                                    return cur.Enabled ~= false
                                end
                            end
                            return true
                        end
                        pcall(function()
                            local coreGui = game:GetService("CoreGui")
                            local bp = coreGui and coreGui:FindFirstChild("Backpack")
                            if bp and bp:IsA("ScreenGui") then
                                for _, d in ipairs(bp:GetDescendants()) do
                                    if d:IsA("GuiObject") and isLargeOverlayGuiObject(d) and isHierarchyEnabled(d) then
                                        found = true
                                        break
                                    end
                                end
                            end
                        end)
                        if not found then
                            local pg = localplayer:FindFirstChildOfClass("PlayerGui") or localplayer:FindFirstChild("PlayerGui")
                            if pg then
                                for _, d in ipairs(pg:GetDescendants()) do
                                    if d:IsA("GuiObject") and isLargeOverlayGuiObject(d) and isHierarchyEnabled(d) then
                                        found = true
                                        break
                                    end
                                end
                            end
                        end
                        rt._tpCursorWanted = found
                    end
                    wantsCursor = (rt._tpCursorWanted == true)
                end
                rt.thirdPerson = rt.thirdPerson or {}
                local tp = rt.thirdPerson
                local prevWants = tp.wantsCursor == true
                tp.wantsCursor = wantsCursor == true
                if rt.setThirdPersonShiftLock then
                    rt.setThirdPersonShiftLock(not wantsCursor, hum)
                end
                rt.setThirdPersonInputLock(not wantsCursor)
                if prevWants and (not wantsCursor) then
                    if rt.setThirdPersonShiftLock then
                        rt.setThirdPersonShiftLock(true, hum)
                    end
                    if _G.SetThirdPersonCamera then
                        _G.SetThirdPersonCamera()
                    end
                    task.defer(function()
                        local rt2 = _G.allvars and _G.allvars._rt
                        if rt2 and rt2.setThirdPersonInputLock then
                            rt2.setThirdPersonInputLock(true)
                        end
                    end)
                    task.delay(0.05, function()
                        local rt2 = _G.allvars and _G.allvars._rt
                        if rt2 and rt2.setThirdPersonInputLock then
                            rt2.setThirdPersonInputLock(true)
                        end
                    end)
                end
            end
        end
        local dist = allvars.camthirdpDist or 5
        localplayer.CameraMaxZoomDistance = dist
        localplayer.CameraMinZoomDistance = dist
        hum.CameraOffset = Vector3.new(1.75, 0, 0)
    end
    do
        local ctl = tostring(CurrentChamsType or ""):lower():gsub("%s+", "")
        local isBeast = (ctl == "opaqueforcefield" or ctl == "forcefield" or ctl == "model")
        local playersChamsOn = (ChamsToggleState == true)
        local ch = localplayer.Character
        local wantSelf = playersChamsOn and (allvars.thirdPersonSelfChams == true) and ch
        local hl = ch and ch:FindFirstChild("ThirdPersonSelfChamsHL")
        if wantSelf and (not isBeast) and ctl == "default" then
            if not hl then
                hl = CreateInstance("Highlight", { Name = "ThirdPersonSelfChamsHL", Parent = ch })
            end
            hl.Adornee = ch
            hl.Enabled = true
            if ESP and ESP.Drawing and ESP.Drawing.Chams then
                local cd = ESP.Drawing.Chams
                if typeof(cd.FillRGB) == "Color3" then hl.FillColor = cd.FillRGB end
                if typeof(cd.OutlineRGB) == "Color3" then hl.OutlineColor = cd.OutlineRGB end
                hl.FillTransparency = (tonumber(cd.Fill_Transparency) or 50) / 100
                hl.OutlineTransparency = (tonumber(cd.Outline_Transparency) or 0) / 100
                hl.DepthMode = cd.XRay and Enum.HighlightDepthMode.AlwaysOnTop or (cd.VisibleCheck and Enum.HighlightDepthMode.Occluded or Enum.HighlightDepthMode.AlwaysOnTop)
            end
        else
            if hl and hl.Destroy then
                pcall(function() hl:Destroy() end)
            end
        end
    end
    local cam = workspace.CurrentCamera
    local root = localplayer.Character:FindFirstChild("HumanoidRootPart")
    if cam and root then
        local _, yaw, _ = cam.CFrame:ToOrientation()
        root.CFrame = CFrame.new(root.Position) * CFrame.Angles(0, yaw, 0)
    end
end)
task.spawn(function()
    pcall(function()
        local transparencyController = require(game.Players.LocalPlayer.PlayerScripts.PlayerModule.CameraModule.TransparencyController)
        local originalUpdate = transparencyController.Update
        transparencyController.Update = function(self, dt)
            pcall(function()
                if _G.allvars and _G.allvars.camthirdp and _G.thirdpshow then
                    if self.cachedParts then
                        for part, _ in pairs(self.cachedParts) do
                            part.LocalTransparencyModifier = 0
                        end
                    end
                    self.transparencyDirty = false
                    self.lastTransparency = 0
                else
                    originalUpdate(self, dt)
                end
            end)
        end
    end)
end)
sections.GunMod:Toggle({
    Name = "No Sway",
    Default = false,
    Callback = function(value)
        if allvars then
            allvars.noswaybool = value
        end
    end
}, "NoSway")
sections.GunMod:Toggle({
    Name = "No Recoil",
    Default = false,
    Callback = function(value)
        if not game.ReplicatedStorage:FindFirstChild("AmmoTypes") then return end
        local ammoTypes = game.ReplicatedStorage.AmmoTypes
        if not _G.RealAmmoData then _G.RealAmmoData = {} end
        if value then
            for _, ammo in pairs(ammoTypes:GetChildren()) do
                if not _G.RealAmmoData[ammo.Name] then
                    _G.RealAmmoData[ammo.Name] = {
                        AccuracyDeviation = ammo:GetAttribute("AccuracyDeviation"),
                        RecoilStrength = ammo:GetAttribute("RecoilStrength")
                    }
                end
                if ammo:GetAttribute("AccuracyDeviation") then
                    ammo:SetAttribute("AccuracyDeviation", 0)
                end
                if ammo:GetAttribute("RecoilStrength") then
                    ammo:SetAttribute("RecoilStrength", 0)
                end
            end
        else
            for _, ammo in pairs(ammoTypes:GetChildren()) do
                local data = _G.RealAmmoData[ammo.Name]
                if data then
                    if ammo:GetAttribute("AccuracyDeviation") then
                        ammo:SetAttribute("AccuracyDeviation", data.AccuracyDeviation)
                    end
                    if ammo:GetAttribute("RecoilStrength") then
                        ammo:SetAttribute("RecoilStrength", data.RecoilStrength)
                    end
                end
            end
        end
    end
}, "NoRecoil")
sections.GunMod:Toggle({
    Name = "Fast Equip",
    Default = false,
    Callback = function(value)
        if allvars then
            allvars.instaequip = value
        end
    end
}, "InstantEquip")
allvars._autoFire = EnsureDefaults(allvars._autoFire, {
    enabled = false,
    reactionTime = 0.05,
    maxDistance = 250,
    lastTime = 0
})
do
    _G.__RAIL_UI = _G.__RAIL_UI or {}
    local root = _G.__RAIL_UI
    root.gunmod = root.gunmod or {}
    local ui = root.gunmod
    ui.sync = ui.sync or function()
        if _G.__OBLIVION_CONFIG_LOADING == true then
            return
        end
        local setVisible = ESP and ESP._ui and ESP._ui._setVisible
        if not setVisible then return end
        local on = (allvars and allvars._autoFire and allvars._autoFire.enabled) and true or false
        setVisible(ui.autoFireReactionSliderEl, on)
        setVisible(ui.autoFireDistanceSliderEl, on)
    end
    ui.autoFireToggleEl = sections.GunMod:Toggle({
        Name = "Auto Fire",
        Default = false,
        Callback = function(value)
            allvars._autoFire.enabled = value
            if ui.sync then
                ui.sync()
            end
        end
    }, "AutoFireToggle")
    ui.autoFireReactionSliderEl = sections.GunMod:Slider({
        Name = "AF Reaction (s)",
        Default = 0.05,
        Minimum = 0.01,
        Maximum = 0.5,
        Precision = 2,
        Callback = function(value)
            allvars._autoFire.reactionTime = value
        end
    }, "AutoFireReaction")
    ui.autoFireDistanceSliderEl = sections.GunMod:Slider({
        Name = "AF Distance (m)",
        Default = 250,
        Minimum = 0,
        Maximum = 1000,
        Precision = 0,
        Callback = function(value)
            allvars._autoFire.maxDistance = value
        end
    }, "AutoFireDistance")
    pcall(ui.sync)
end
_G.allvars._rt.track(runs.Heartbeat:Connect(function()
    if not localplayer.Character or not localplayer.Character:FindFirstChild("Humanoid") or localplayer.Character.Humanoid.Health <= 0 then return end
    local af = allvars._autoFire
    local currentTime = tick()
    local mouse = localplayer:GetMouse()
    if af.enabled and aimbool and (currentTime - af.lastTime > af.reactionTime) then
        if aimtarget and aimtargetpart then
             local distStuds = (localplayer.Character.PrimaryPart.Position - aimtargetpart.Position).Magnitude
             local distM = distStuds / allvars._units.studsPerMeter
             if distM <= af.maxDistance then
                 local targetChar = aimtarget:IsA("Model") and aimtarget or aimtarget.Character
                 if isvisible(targetChar, aimtargetpart) then
                     mouse1press()
                     task.delay(0.05, function() mouse1release() end)
                     af.lastTime = currentTime
                 end
             end
        end
    end
end))

;(function()
    local RS = game:GetService("ReplicatedStorage")
    local HttpService = game:GetService("HttpService")
    local Players = game:GetService("Players")

    local Player = Players.LocalPlayer
    local FuncLib = nil
    pcall(function() FuncLib = require(RS.Modules.FunctionLibraryExtension) end)

    local ConfigName = "VisualSkins_Final_Fixed.json"
    local SkinCache = {}
    local Connections = {}
    local enabled = true

    if _G.allvars and _G.allvars.skinChangerEnabled == false then
        enabled = false
    end

    if isfile and isfile(ConfigName) then
        pcall(function()
            SkinCache = HttpService:JSONDecode(readfile(ConfigName))
        end)
    end

    local function SaveConfig()
        if writefile then
            writefile(ConfigName, HttpService:JSONEncode(SkinCache))
        end
    end

    local function GetInventoryItem(name)
        local inv = RS.Players:FindFirstChild(Player.Name) and RS.Players[Player.Name]:FindFirstChild("Inventory")
        if not inv then return nil end
        for _, obj in pairs(inv:GetDescendants()) do
            if obj:IsA("ObjectValue") and obj.Value and obj.Value.Name == name then
                return obj
            end
        end
        return nil
    end

    local function ApplyVisualsToTool(tool, itemObj)
        if not tool or not itemObj or not FuncLib then return end
        task.spawn(function()
            local model = tool:FindFirstChild("Model") or tool
            pcall(function()
                FuncLib:UpdateSkin(itemObj, model)
            end)
        end)
    end

    local function SetSkinAttribute(obj, skinName)
        if obj:GetAttribute("Skin") ~= skinName then
            obj:SetAttribute("Skin", skinName)
        end
    end

    local function ApplySkinGlobal(itemName, skinName)
        if not enabled then return end
        SkinCache[itemName] = skinName
        SaveConfig()

        local inv = RS.Players:FindFirstChild(Player.Name) and RS.Players[Player.Name]:FindFirstChild("Inventory")
        if inv then
            for _, obj in pairs(inv:GetDescendants()) do
                if obj:IsA("ObjectValue") and obj.Value and obj.Value.Name == itemName then
                    SetSkinAttribute(obj, skinName)
                end
            end
        end

        local char = Player.Character
        if char then
            local tool = char:FindFirstChild(itemName)
            if tool then
                local logical = GetInventoryItem(itemName)
                if logical then
                    ApplyVisualsToTool(tool, logical)
                end
            end
        end
    end

    local function SetupSkinUI(frame)
        if not enabled then return end
        task.wait()
        if not frame:FindFirstChild("Item") then return end
        local itemVal = frame.Item.Value
        if not itemVal or not itemVal.Value then return end

        local itemName = itemVal.Value.Name
        local skinFolder = itemVal.Value.ItemProperties:GetAttribute("SpecialSkinItem") or itemName
        local container = RS.Skins:FindFirstChild(skinFolder)
        if not container then return end

        local scroll = frame:WaitForChild("BottomFrame"):WaitForChild("ScrollingFrame")
        local template = scroll:WaitForChild("SkinFrameTemplate")

        for _, c in pairs(scroll:GetChildren()) do
            if c:IsA("ImageButton") and c ~= template then
                c:Destroy()
            end
        end

        local sorted = container:GetChildren()
        table.sort(sorted, function(a, b) return a.Name < b.Name end)

        for i, skin in ipairs(sorted) do
            local btn = template:Clone()
            btn.Name = skin.Name
            btn.LayoutOrder = i
            btn.Image = skin:GetAttribute("ItemIcon") or ""
            btn.Visible = true
            btn.Parent = scroll
            btn.MouseButton1Click:Connect(function()
                if not enabled then return end
                ApplySkinGlobal(itemName, skin.Name)
                frame:Destroy()
            end)
        end
    end

    local function HookUI()
        if Connections.UI_Added then
            Connections.UI_Added:Disconnect()
        end
        Connections.UI_Added = nil
        if not enabled then return end

        local PlayerGui = Player:WaitForChild("PlayerGui", 10)
        if not PlayerGui then return end
        local MainGui = PlayerGui:WaitForChild("MainGui", 10)
        if not MainGui then return end

        local InteractionFrame = MainGui:WaitForChild("MainFrame"):WaitForChild("InteractionFrame")
        local ActiveSkinBoxes = InteractionFrame:WaitForChild("ActiveSkinBoxes")

        Connections.UI_Added = ActiveSkinBoxes.ChildAdded:Connect(function(c)
            if c:IsA("Frame") then
                SetupSkinUI(c)
            end
        end)

        for _, c in pairs(ActiveSkinBoxes:GetChildren()) do
            if c:IsA("Frame") then
                SetupSkinUI(c)
            end
        end
    end

    local function MonitorInventory()
        if Connections.Inv_Added then
            Connections.Inv_Added:Disconnect()
        end
        Connections.Inv_Added = nil
        if not enabled then return end

        local inv = RS.Players:WaitForChild(Player.Name):WaitForChild("Inventory")

        local function registerItem(obj)
            if obj:IsA("ObjectValue") and obj.Value then
                local name = obj.Value.Name
                if enabled and SkinCache[name] then
                    SetSkinAttribute(obj, SkinCache[name])
                end
                obj:GetAttributeChangedSignal("Skin"):Connect(function()
                    if not enabled then return end
                    if SkinCache[name] and obj:GetAttribute("Skin") ~= SkinCache[name] then
                        SetSkinAttribute(obj, SkinCache[name])
                    end
                end)
            end
        end

        Connections.Inv_Added = inv.DescendantAdded:Connect(registerItem)
        for _, c in pairs(inv:GetDescendants()) do
            registerItem(c)
        end
    end

    local function MonitorCharacter(char)
        if Connections.Char_Child then
            Connections.Char_Child:Disconnect()
        end
        Connections.Char_Child = nil
        if not enabled then return end
        Connections.Char_Child = char.ChildAdded:Connect(function(child)
            if not enabled then return end
            if child:IsA("Tool") then
                task.wait()
                local name = child.Name
                if SkinCache[name] then
                    local logical = GetInventoryItem(name)
                    if logical then
                        SetSkinAttribute(logical, SkinCache[name])
                        ApplyVisualsToTool(child, logical)
                    end
                end
            end
        end)
    end

    Player.CharacterAdded:Connect(function(newChar)
        if not enabled then return end
        task.wait(0.5)
        HookUI()
        MonitorCharacter(newChar)
        MonitorInventory()
    end)

    _G.Skin = function(item, skin)
        ApplySkinGlobal(item, skin)
    end

    _G.ToggleSkinChanger = function(value)
        enabled = value and true or false
        if _G.allvars then
            _G.allvars.skinChangerEnabled = enabled
        end

        if not enabled then
            if Connections.UI_Added then
                Connections.UI_Added:Disconnect()
                Connections.UI_Added = nil
            end
            if Connections.Inv_Added then
                Connections.Inv_Added:Disconnect()
                Connections.Inv_Added = nil
            end
            if Connections.Char_Child then
                Connections.Char_Child:Disconnect()
                Connections.Char_Child = nil
            end
            return
        end

        task.spawn(HookUI)
        task.spawn(MonitorInventory)
        if Player.Character then
            MonitorCharacter(Player.Character)
        end
    end

    _G.ToggleSkinChanger(enabled)
end)()

